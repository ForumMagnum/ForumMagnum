import React from "react";
import type { RelevantTestGroupAllocation } from "./abTestImpl";
import { ServerRequestStatusContextType } from "./vulcan-core/appContext";
import { isProduction } from "./executionEnvironment";

/**
 * Log of errors/warnings that have occured during a function execution. The intended use case is to pass
 * an instance of this by reference to a function that may generate errors/warnings that are non-blocking,
 * and then use this info to incrementally reduce the number that are generated.
 */
export interface WarningLog {
  count: number
  /** Info about the warnings, may be selectively captured for performance reasons, hence the independent `count` */
  info?: string[]
}

/**
 * Metadata generated by a render that may be relevant to the server (such as changing the
 * decision on whether to cache a page). For each item passing `undefined` means that the item
 * won't be tracked.
 */
export interface RenderSideEffects {
  /** Allows components to set statuscodes and redirects that will get executed on the server */
  serverRequestStatus?: ServerRequestStatusContextType;
  /** The A/B test groups that are used during the render */
  abTestGroupsUsed?: RelevantTestGroupAllocation;
  /**
   * Cases where something occured during the render that means the page should not be cached.
   * E.g. accessing the current user.
   */
  cacheErrors?: WarningLog;
  /**
   * Cases where something occured during the render that may cause problems with caching the page,
   * but is not a deal breaker. E.g. using a relative date.
   */
  cacheWarnings?: WarningLog;
}

export const CacheErrorsContext = React.createContext<Pick<RenderSideEffects, 'cacheErrors' | 'cacheWarnings'>>({});

const logCacheIssue = (warningLog: WarningLog, message = '') => {
  warningLog.count++;
  if (!isProduction) {
    // Uncomment below for debugging purposes, too slow to run always
    // message = message + "\n" + new Error().stack;{
    warningLog.info?.push(message);
  }
};

export const useCacheErrors = () => {
  const { cacheErrors, cacheWarnings } = React.useContext(CacheErrorsContext);

  const logCacheError = cacheErrors ? (message?: string) => logCacheIssue(cacheErrors, message) : () => {};
  const logCacheWarning = cacheWarnings ? (message?: string) => logCacheIssue(cacheWarnings, message) : () => {};

  return { logCacheError, logCacheWarning };
}

export const userWithSideEffects = (user: UsersCurrent, renderSideEffects: RenderSideEffects) => {
  return new Proxy(user, {
    get(target, property, receiver) {
      if (renderSideEffects.cacheErrors) {
        logCacheIssue(renderSideEffects.cacheErrors, `Accessing property ${String(property)} of currentUser`);
      }
      return Reflect.get(target, property, receiver);
    }
  });
}
