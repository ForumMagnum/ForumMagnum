# Generated file - run 'yarn generate' to update.

type Query

type Mutation

scalar JSON

scalar Date

input SelectorInput {
  _id: String
  documentId: String
}

input EmptyViewInput {
  _: Boolean @deprecated(reason: "GraphQL doesn't support empty input types, so we need to provide a field.  Don't pass anything in, it doesn't do anything.")
}

type EmailPreview {
  to: String
  subject: String
  html: String
  text: String
}

extend type Query {
  EmailPreview(notificationIds: [String], postId: String): [EmailPreview]
}

type ArbitalLinkedPage {
  _id: String!
  name: String!
  slug: String!
}

type ArbitalLinkedPages {
  faster: [ArbitalLinkedPage!]!
  slower: [ArbitalLinkedPage!]!
  moreTechnical: [ArbitalLinkedPage!]!
  lessTechnical: [ArbitalLinkedPage!]!
  requirements: [ArbitalLinkedPage!]!
  teaches: [ArbitalLinkedPage!]!
  parents: [ArbitalLinkedPage!]!
  children: [ArbitalLinkedPage!]!
}

type SocialPreviewType {
  _id: String!
  imageId: String
  imageUrl: String!
  text: String
}

input CoauthorStatusInput {
  userId: String!
  confirmed: Boolean!
  requested: Boolean!
}

input SocialPreviewInput {
  imageId: String
  text: String
}

input CrosspostInput {
  isCrosspost: Boolean!
  hostedHere: Boolean
  foreignPostId: String
}

type CoauthorStatusOutput {
  userId: String!
  confirmed: Boolean!
  requested: Boolean!
}

type SocialPreviewOutput {
  imageId: String
  text: String
}

type CrosspostOutput {
  isCrosspost: Boolean!
  hostedHere: Boolean
  foreignPostId: String
}

scalar ContentTypeData

type ContentType {
  type: String!
  data: ContentTypeData!
}

type TagContributor {
  user: User
  contributionScore: Int!
  currentAttributionCharCount: Int
  numCommits: Int!
  voteCount: Int!
}

type TagContributorsList {
  contributors: [TagContributor!]!
  totalCount: Int!
}

type UserLikingTag {
  _id: String!
  displayName: String!
}

type LatLng {
  lat: Float!
  lng: Float!
}

input ExpandedFrontpageSectionsSettingsInput {
  community: Boolean
  recommendations: Boolean
  quickTakes: Boolean
  quickTakesCommunity: Boolean
  popularComments: Boolean
}

type ExpandedFrontpageSectionsSettingsOutput {
  community: Boolean
  recommendations: Boolean
  quickTakes: Boolean
  quickTakesCommunity: Boolean
  popularComments: Boolean
}

input PartiallyReadSequenceItemInput {
  sequenceId: String
  collectionId: String
  lastReadPostId: String!
  nextPostId: String!
  numRead: Int!
  numTotal: Int!
  lastReadTime: Date
}

type PartiallyReadSequenceItemOutput {
  sequenceId: String
  collectionId: String
  lastReadPostId: String
  nextPostId: String
  numRead: Int
  numTotal: Int
  lastReadTime: Date
}

input PostMetadataInput {
  postId: String!
}

type PostMetadataOutput {
  postId: String!
}

input RecommendationAlgorithmSettingsInput {
  method: String!
  count: Int!
  scoreOffset: Float!
  scoreExponent: Float!
  personalBlogpostModifier: Float!
  frontpageModifier: Float!
  curatedModifier: Float!
  onlyUnread: Boolean!
}

input RecommendationSettingsInput {
  frontpage: RecommendationAlgorithmSettingsInput!
  frontpageEA: RecommendationAlgorithmSettingsInput!
  recommendationspage: RecommendationAlgorithmSettingsInput!
}

type RecommendResumeSequence {
  sequence: Sequence
  collection: Collection
  nextPost: Post!
  numRead: Int
  numTotal: Int
  lastReadTime: Date
}

extend type Query {
  ContinueReading: [RecommendResumeSequence!]
  Recommendations(count: Int, algorithm: JSON): [Post!]
}

extend type Mutation {
  dismissRecommendation(postId: String): Boolean
}

type CommentCountTag {
  name: String!
  comment_count: Int!
}

type TopCommentedTagUser {
  _id: ID!
  username: String!
  displayName: String!
  total_power: Float!
  tag_comment_counts: [CommentCountTag!]!
}

type UpvotedUser {
  _id: ID!
  username: String!
  displayName: String!
  total_power: Float!
  power_values: String!
  vote_counts: Int!
  total_agreement: Float!
  agreement_values: String!
  recently_active_matchmaking: Boolean!
}

type UserDialogueUsefulData {
  dialogueUsers: [User]
  topUsers: [UpvotedUser]
  activeDialogueMatchSeekers: [User]
}

type NewUserCompletedProfile {
  username: String
  slug: String
  displayName: String
  subscribedToDigest: Boolean
  usernameUnset: Boolean
}

type UserCoreTagReads {
  tagId: String!
  userReadCount: Int!
}

extend type Mutation {
  NewUserCompleteProfile(username: String!, subscribeToDigest: Boolean!, email: String, acceptedTos: Boolean): NewUserCompletedProfile
  UserExpandFrontpageSection(section: String!, expanded: Boolean!): Boolean
  UserUpdateSubforumMembership(tagId: String!, member: Boolean!): User
}

extend type Query {
  UserReadsPerCoreTag(userId: String!): [UserCoreTagReads!]!
  GetRandomUser(userIsAuthor: String!): User
  IsDisplayNameTaken(displayName: String!): Boolean!
  GetUserBySlug(slug: String!): User
  NetKarmaChangesForAuthorsOverPeriod(days: Int!, limit: Int!): [NetKarmaChangesForAuthorsOverPeriod!]!
  AirtableLeaderboards: [AirtableLeaderboardResult!]!
}

type NetKarmaChangesForAuthorsOverPeriod {
  userId: String
  netKarma: Int
}

type AirtableLeaderboardResult {
  name: String!
  leaderboardAmount: Int
}

type SuggestedFeedSubscriptionUsersResult {
  results: [User!]!
}

extend type Query {
  SuggestedFeedSubscriptionUsers(limit: Int): SuggestedFeedSubscriptionUsersResult
}

type VoteResultPost {
  document: Post!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVotePost(documentId: String, voteType: String, extendedVote: JSON): Post
  performVotePost(documentId: String, voteType: String, extendedVote: JSON): VoteResultPost
}

type VoteResultComment {
  document: Comment!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteComment(documentId: String, voteType: String, extendedVote: JSON): Comment
  performVoteComment(documentId: String, voteType: String, extendedVote: JSON): VoteResultComment
}

type VoteResultTagRel {
  document: TagRel!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteTagRel(documentId: String, voteType: String, extendedVote: JSON): TagRel
  performVoteTagRel(documentId: String, voteType: String, extendedVote: JSON): VoteResultTagRel
}

type VoteResultRevision {
  document: Revision!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteRevision(documentId: String, voteType: String, extendedVote: JSON): Revision
  performVoteRevision(documentId: String, voteType: String, extendedVote: JSON): VoteResultRevision
}

type VoteResultElectionCandidate {
  document: ElectionCandidate!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteElectionCandidate(documentId: String, voteType: String, extendedVote: JSON): ElectionCandidate
  performVoteElectionCandidate(documentId: String, voteType: String, extendedVote: JSON): VoteResultElectionCandidate
}

type VoteResultTag {
  document: Tag!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteTag(documentId: String, voteType: String, extendedVote: JSON): Tag
  performVoteTag(documentId: String, voteType: String, extendedVote: JSON): VoteResultTag
}

type VoteResultMultiDocument {
  document: MultiDocument!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteMultiDocument(documentId: String, voteType: String, extendedVote: JSON): MultiDocument
  performVoteMultiDocument(documentId: String, voteType: String, extendedVote: JSON): VoteResultMultiDocument
}

extend type Mutation {
  moderateComment(commentId: String, deleted: Boolean, deletedPublic: Boolean, deletedReason: String): Comment
}

type CommentsWithReactsResult {
  results: [Comment!]!
}

extend type Query {
  CommentsWithReacts(limit: Int): CommentsWithReactsResult
}

type PopularCommentsResult {
  results: [Comment!]!
}

extend type Query {
  PopularComments(limit: Int): PopularCommentsResult
}

type PostKarmaChange {
  _id: String!
  collectionName: String!
  scoreChange: Int!
  postId: String!
  title: String
  slug: String!
  addedReacts: [ReactionChange!]
  eaAddedReacts: JSON
}

type CommentKarmaChange {
  _id: String!
  collectionName: String!
  scoreChange: Int!
  commentId: String
  description: String
  postId: String
  postTitle: String
  postSlug: String
  tagSlug: String
  tagName: String
  tagCommentType: TagCommentType
  tagId: String
  addedReacts: [ReactionChange!]
  eaAddedReacts: JSON
}

type RevisionsKarmaChange {
  _id: String!
  collectionName: String!
  scoreChange: Int!
  tagId: String
  tagSlug: String
  tagName: String
  addedReacts: [ReactionChange!]
  eaAddedReacts: JSON
}

type ReactionChange {
  reactionType: String!
  userId: String
}

type KarmaChangesSimple {
  posts: [PostKarmaChange!]!
  comments: [CommentKarmaChange!]!
  tagRevisions: [RevisionsKarmaChange!]!
}

type KarmaChanges {
  totalChange: Int!
  startDate: Date
  endDate: Date
  nextBatchDate: Date
  updateFrequency: String!
  posts: [PostKarmaChange!]!
  comments: [CommentKarmaChange!]!
  tagRevisions: [RevisionsKarmaChange!]!
  todaysKarmaChanges: KarmaChangesSimple
  thisWeeksKarmaChanges: KarmaChangesSimple
}

type UniqueClientViewsSeries {
  uniqueClientViews: Int
  date: Date
}

type PostAnalyticsResult {
  allViews: Int
  uniqueClientViews: Int
  uniqueClientViews10Sec: Int
  medianReadingTime: Int
  uniqueClientViews5Min: Int
  uniqueClientViewsSeries: [UniqueClientViewsSeries]
}

type PostAnalytics2Result {
  _id: String
  title: String
  slug: String
  postedAt: Date
  views: Int
  uniqueViews: Int
  reads: Int
  meanReadingTime: Float
  karma: Int
  comments: Int
}

type MultiPostAnalyticsResult {
  posts: [PostAnalytics2Result]
  totalCount: Int!
}

type AnalyticsSeriesValue {
  date: Date
  views: Int
  reads: Int
  karma: Int
  comments: Int
}

extend type Query {
  PostAnalytics(postId: String!): PostAnalyticsResult!
  MultiPostAnalytics(userId: String, postIds: [String], sortBy: String, desc: Boolean, limit: Int): MultiPostAnalyticsResult!
  AnalyticsSeries(userId: String, postIds: [String], startDate: Date, endDate: Date): [AnalyticsSeriesValue]
}

type ArbitalPageData {
  html: String
  title: String
}

extend type Query {
  ArbitalPageData(pageAlias: String): ArbitalPageData
}

type ElicitUser {
  isQuestionCreator: Boolean
  displayName: String
  _id: String
  sourceUserId: String
  lwUser: User
}

type ElicitPrediction {
  _id: String
  predictionId: String
  prediction: Float
  createdAt: Date
  notes: String
  creator: ElicitUser
  sourceUrl: String
  sourceId: String
  binaryQuestionId: String
}

type ElicitBlockData {
  _id: String
  title: String
  notes: String
  resolvesBy: Date
  resolution: Boolean
  predictions: [ElicitPrediction!]
}

extend type Query {
  ElicitBlockData(questionId: String): ElicitBlockData
}

extend type Mutation {
  MakeElicitPrediction(questionId: String, prediction: Int): ElicitBlockData
}

type NotificationCounts {
  checkedAt: Date!
  unreadNotifications: Int!
  unreadPrivateMessages: Int!
  faviconBadgeNumber: Int!
}

extend type Query {
  unreadNotificationCounts: NotificationCounts!
}

extend type Mutation {
  MarkAllNotificationsAsRead: Boolean
  sendNewDialogueMessageNotification(postId: String!, dialogueHtml: String!): Boolean!
}

type NotificationDisplaysResult {
  results: [JSON!]!
}

extend type Query {
  NotificationDisplays(type: String, limit: Int): NotificationDisplaysResult
}

extend type Query {
  Lightcone2024FundraiserStripeAmounts: [Int!]
}

type PetrovDay2024CheckNumberOfIncomingData {
  count: Int
}

extend type Query {
  PetrovDay2024CheckNumberOfIncoming: PetrovDay2024CheckNumberOfIncomingData
  petrov2024checkIfNuked: Boolean
}

type PetrovDayCheckIfIncomingData {
  launched: Boolean
  createdAt: Date
}

type PetrovDayLaunchMissileData {
  launchCode: String
  createdAt: Date
}

extend type Query {
  PetrovDayCheckIfIncoming: PetrovDayCheckIfIncomingData
}

extend type Mutation {
  PetrovDayLaunchMissile(launchCode: String): PetrovDayLaunchMissileData
}

type GivingSeasonHeart {
  userId: String!
  displayName: String!
  x: Float!
  y: Float!
  theta: Float!
}

extend type Mutation {
  submitReviewVote(postId: String, qualitativeScore: Int, quadraticChange: Int, newQuadraticScore: Int, comment: String, year: String, dummy: Boolean, reactions: [String]): Post
  AddGivingSeasonHeart(electionName: String!, x: Float!, y: Float!, theta: Float!): [GivingSeasonHeart!]!
  RemoveGivingSeasonHeart(electionName: String!): [GivingSeasonHeart!]!
}

extend type Query {
  GivingSeasonHearts(electionName: String!): [GivingSeasonHeart!]!
}

extend type Query {
  UsersReadPostsOfTargetUser(userId: String!, targetUserId: String!, limit: Int): [Post!]
  UserReadHistory(limit: Int, filter: PostReviewFilter, sort: PostReviewSort): UserReadHistoryResult
  PostsUserCommentedOn(limit: Int, filter: PostReviewFilter, sort: PostReviewSort): UserReadHistoryResult
  PostIsCriticism(args: JSON): Boolean
  DigestPlannerData(digestId: String, startDate: Date, endDate: Date): [DigestPlannerPost!]!
  DigestPosts(num: Int): [Post!]
  CanAccessGoogleDoc(fileUrl: String!): Boolean
}

extend type Mutation {
  ImportGoogleDoc(fileUrl: String!, postId: String): Post
}

type UserReadHistoryResult {
  posts: [Post!]
}

type PostsUserCommentedOnResult {
  posts: [Post!]
}

input PostReviewFilter {
  startDate: Date
  endDate: Date
  minKarma: Int
  showEvents: Boolean
}

input PostReviewSort {
  karma: Boolean
}

type DigestPlannerPost {
  post: Post!
  digestPost: DigestPost
  rating: Int!
}

type RecombeeRecommendedPost {
  post: Post!
  scenario: String
  recommId: String
  generatedAt: Date
  curated: Boolean
  stickied: Boolean
}

type VertexRecommendedPost {
  post: Post!
  attributionId: String
}

type PostWithApprovedJargon {
  post: Post!
  jargonTerms: [JargonTerm!]!
}

type DigestHighlightsResult {
  results: [Post!]!
}

extend type Query {
  DigestHighlights(limit: Int): DigestHighlightsResult
}

type DigestPostsThisWeekResult {
  results: [Post!]!
}

extend type Query {
  DigestPostsThisWeek(limit: Int): DigestPostsThisWeekResult
}

type CuratedAndPopularThisWeekResult {
  results: [Post!]!
}

extend type Query {
  CuratedAndPopularThisWeek(limit: Int): CuratedAndPopularThisWeekResult
}

type RecentlyActiveDialoguesResult {
  results: [Post!]!
}

extend type Query {
  RecentlyActiveDialogues(limit: Int): RecentlyActiveDialoguesResult
}

type MyDialoguesResult {
  results: [Post!]!
}

extend type Query {
  MyDialogues(limit: Int): MyDialoguesResult
}

type GoogleVertexPostsResult {
  results: [VertexRecommendedPost!]!
}

extend type Query {
  GoogleVertexPosts(settings: JSON, limit: Int): GoogleVertexPostsResult
}

type CrossedKarmaThresholdResult {
  results: [Post!]!
}

extend type Query {
  CrossedKarmaThreshold(limit: Int): CrossedKarmaThresholdResult
}

type RecombeeLatestPostsResult {
  results: [RecombeeRecommendedPost!]!
}

extend type Query {
  RecombeeLatestPosts(settings: JSON, limit: Int): RecombeeLatestPostsResult
}

type RecombeeHybridPostsResult {
  results: [RecombeeRecommendedPost!]!
}

extend type Query {
  RecombeeHybridPosts(settings: JSON, limit: Int): RecombeeHybridPostsResult
}

type PostsWithActiveDiscussionResult {
  results: [Post!]!
}

extend type Query {
  PostsWithActiveDiscussion(limit: Int): PostsWithActiveDiscussionResult
}

type PostsBySubscribedAuthorsResult {
  results: [Post!]!
}

extend type Query {
  PostsBySubscribedAuthors(limit: Int): PostsBySubscribedAuthorsResult
}

type PostsWithApprovedJargonResult {
  results: [PostWithApprovedJargon!]!
}

extend type Query {
  PostsWithApprovedJargon(limit: Int): PostsWithApprovedJargonResult
}

extend type Mutation {
  revokeGoogleServiceAccountTokens: Boolean!
}

extend type Mutation {
  alignmentComment(commentId: String, af: Boolean): Comment
  alignmentPost(postId: String, af: Boolean): Post
}

type AllTagsActivityFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [AllTagsActivityFeedEntry!]
}

enum AllTagsActivityFeedEntryType {
  tagCreated
  tagRevision
  tagDiscussionComment
}

type AllTagsActivityFeedEntry {
  type: AllTagsActivityFeedEntryType!
  tagCreated: Tag
  tagRevision: Revision
  tagDiscussionComment: Comment
}

extend type Query {
  AllTagsActivityFeed(limit: Int, cutoff: Date, offset: Int): AllTagsActivityFeedQueryResults!
}

type RecentDiscussionFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [RecentDiscussionFeedEntry!]
  sessionId: String
}

enum RecentDiscussionFeedEntryType {
  postCommented
  shortformCommented
  tagDiscussed
  tagRevised
  subscribeReminder
  meetupsPoke
}

type RecentDiscussionFeedEntry {
  type: RecentDiscussionFeedEntryType!
  postCommented: Post
  shortformCommented: Post
  tagDiscussed: Tag
  tagRevised: Revision
}

extend type Query {
  RecentDiscussionFeed(limit: Int, cutoff: Date, offset: Int, af: Boolean): RecentDiscussionFeedQueryResults!
}

type SubscribedPostAndComments {
  _id: String!
  post: Post!
  comments: [Comment!]
  expandCommentIds: [String!]
  postIsFromSubscribedUser: Boolean!
}

type SubscribedFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubscribedFeedEntry!]
}

enum SubscribedFeedEntryType {
  postCommented
}

type SubscribedFeedEntry {
  type: SubscribedFeedEntryType!
  postCommented: SubscribedPostAndComments
}

extend type Query {
  SubscribedFeed(limit: Int, cutoff: Date, offset: Int, af: Boolean): SubscribedFeedQueryResults!
}

type TagHistoryFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [TagHistoryFeedEntry!]
}

enum TagHistoryFeedEntryType {
  tagCreated
  tagApplied
  tagRevision
  tagDiscussionComment
  lensRevision
  summaryRevision
  wikiMetadataChanged
  lensOrSummaryMetadataChanged
}

type TagHistoryFeedEntry {
  type: TagHistoryFeedEntryType!
  tagCreated: Tag
  tagApplied: TagRel
  tagRevision: Revision
  tagDiscussionComment: Comment
  lensRevision: Revision
  summaryRevision: Revision
  wikiMetadataChanged: FieldChange
  lensOrSummaryMetadataChanged: FieldChange
}

extend type Query {
  TagHistoryFeed(limit: Int, cutoff: Date, offset: Int, tagId: String!, options: JSON): TagHistoryFeedQueryResults!
}

type SubforumMagicFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumMagicFeedEntry!]
}

enum SubforumMagicFeedEntryType {
  tagSubforumPosts
  tagSubforumComments
  tagSubforumStickyComments
}

type SubforumMagicFeedEntry {
  type: SubforumMagicFeedEntryType!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumMagicFeed(limit: Int, cutoff: Float, offset: Int, tagId: String!, af: Boolean): SubforumMagicFeedQueryResults!
}

type SubforumTopFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumTopFeedEntry!]
}

enum SubforumTopFeedEntryType {
  tagSubforumPosts
  tagSubforumComments
  tagSubforumStickyComments
}

type SubforumTopFeedEntry {
  type: SubforumTopFeedEntryType!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumTopFeed(limit: Int, cutoff: Int, offset: Int, tagId: String!, af: Boolean): SubforumTopFeedQueryResults!
}

type SubforumRecentCommentsFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumRecentCommentsFeedEntry!]
}

enum SubforumRecentCommentsFeedEntryType {
  tagSubforumPosts
  tagSubforumComments
  tagSubforumStickyComments
}

type SubforumRecentCommentsFeedEntry {
  type: SubforumRecentCommentsFeedEntryType!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumRecentCommentsFeed(limit: Int, cutoff: Date, offset: Int, tagId: String!, af: Boolean): SubforumRecentCommentsFeedQueryResults!
}

type SubforumNewFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumNewFeedEntry!]
}

enum SubforumNewFeedEntryType {
  tagSubforumPosts
  tagSubforumComments
  tagSubforumStickyComments
}

type SubforumNewFeedEntry {
  type: SubforumNewFeedEntryType!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumNewFeed(limit: Int, cutoff: Date, offset: Int, tagId: String!, af: Boolean): SubforumNewFeedQueryResults!
}

type SubforumOldFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumOldFeedEntry!]
}

enum SubforumOldFeedEntryType {
  tagSubforumPosts
  tagSubforumComments
  tagSubforumStickyComments
}

type SubforumOldFeedEntry {
  type: SubforumOldFeedEntryType!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumOldFeed(limit: Int, cutoff: Date, offset: Int, tagId: String!, af: Boolean): SubforumOldFeedQueryResults!
}

extend type Mutation {
  markConversationRead(conversationId: String!): Boolean!
  sendEventTriggeredDM(eventType: String!): Boolean!
  initiateConversation(participantIds: [String!]!, af: Boolean, moderator: Boolean): Conversation
}

input SurveyQuestionInfo {
  _id: String
  question: String!
  format: String!
}

extend type Query {
  CurrentFrontpageSurvey: SurveySchedule
}

extend type Mutation {
  editSurvey(surveyId: String!, name: String!, questions: [SurveyQuestionInfo!]!): Survey
}

enum DocumentDeletionNetChange {
  deleted
  restored
}

enum MultiDocumentType {
  lens
  summary
}

type DocumentDeletion {
  userId: String
  documentId: String!
  netChange: DocumentDeletionNetChange!
  type: MultiDocumentType
  docFields: MultiDocument
  createdAt: Date!
}

type TagUpdates {
  tag: Tag!
  revisionIds: [String!]!
  commentCount: Int!
  commentIds: [String!]!
  lastRevisedAt: Date
  lastCommentedAt: Date
  added: Int!
  removed: Int!
  users: [User!]!
  documentDeletions: [DocumentDeletion!]!
}

type TagPreviewWithSummaries {
  tag: Tag!
  lens: MultiDocument
  summaries: [MultiDocument!]!
}

type TagWithTotalCount {
  tags: [Tag!]!
  totalCount: Int!
}

extend type Mutation {
  mergeTags(sourceTagId: String!, targetTagId: String!, transferSubtags: Boolean!, redirectSource: Boolean!): Boolean
  promoteLensToMain(lensId: String!): Boolean
}

extend type Query {
  TagUpdatesInTimeBlock(before: Date!, after: Date!): [TagUpdates!]!
  TagUpdatesByUser(userId: String!, limit: Int!, skip: Int!): [TagUpdates!]
  RandomTag: Tag!
  ActiveTagCount: Int!
  TagPreview(slug: String!, hash: String): TagPreviewWithSummaries
  TagsByCoreTagId(coreTagId: String, limit: Int, searchTagIds: [String]): TagWithTotalCount!
}

type MostReadTopic {
  slug: String
  name: String
  shortName: String
  count: Int
}

type TagReadLikelihoodRatio {
  tagId: String
  tagName: String
  tagShortName: String
  userReadCount: Int
  readLikelihoodRatio: Float
}

type MostReadAuthor {
  _id: String
  slug: String
  displayName: String
  profileImageId: String
  count: Int
  engagementPercentile: Float
}

type TopCommentContents {
  html: String
}

type TopComment {
  _id: String
  postedAt: Date
  postId: String
  postTitle: String
  postSlug: String
  baseScore: Int
  extendedScore: JSON
  contents: TopCommentContents
}

type MostReceivedReact {
  name: String
  count: Int
}

type CombinedKarmaVals {
  date: Date!
  postKarma: Int!
  commentKarma: Int!
}

type WrappedDataByYear {
  engagementPercentile: Float
  postsReadCount: Int
  totalSeconds: Int
  daysVisited: [String]
  mostReadTopics: [MostReadTopic]
  relativeMostReadCoreTopics: [TagReadLikelihoodRatio]
  mostReadAuthors: [MostReadAuthor]
  topPosts: [Post]
  postCount: Int
  authorPercentile: Float
  topComment: TopComment
  commentCount: Int
  commenterPercentile: Float
  topShortform: Comment
  shortformCount: Int
  shortformPercentile: Float
  karmaChange: Int
  combinedKarmaVals: [CombinedKarmaVals]
  mostReceivedReacts: [MostReceivedReact]
  personality: String!
}

extend type Query {
  UserWrappedDataByYear(userId: String!, year: Int!): WrappedDataByYear
}

extend type Mutation {
  RefreshDbSettings: Boolean
}

type Site {
  title: String
  url: String
  logoUrl: String
}

extend type Query {
  SiteData: Site
}

type LoginReturnData {
  token: String
}

extend type Mutation {
  login(username: String, password: String): LoginReturnData
  signup(username: String, email: String, password: String, subscribeToCurated: Boolean, reCaptchaToken: String, abTestKey: String): LoginReturnData
  logout: LoginReturnData
  resetPassword(email: String): String
}

extend type Query {
  latestDialogueMessages(dialogueId: String!, numMessages: Int!): [String!]
}

extend type Mutation {
  AddForumEventVote(forumEventId: String!, x: Float!, delta: Float, postIds: [String]): Boolean
  RemoveForumEventVote(forumEventId: String!): Boolean
  RemoveForumEventSticker(forumEventId: String!, stickerId: String!): Boolean
}

extend type Query {
  getLinkSharedPost(postId: String!, linkSharingKey: String!): Post
}

extend type Mutation {
  unlockPost(postId: String!, linkSharingKey: String!): Post
  revertPostToRevision(postId: String!, revisionId: String!): Post
}

type MigrationsDashboardData {
  migrations: [MigrationStatus!]
}

type MigrationStatus {
  name: String!
  dateWritten: String
  runs: [MigrationRun!]
  lastRun: String
}

type MigrationRun {
  name: String!
  started: Date!
  finished: Date
  succeeded: Boolean
}

extend type Query {
  MigrationsDashboard: MigrationsDashboardData
}

extend type Query {
  GetAllReviewWinners: [Post!]!
}

extend type Mutation {
  sendVertexViewItemEvent(postId: String!, attributionId: String): Boolean!
  sendVertexMediaCompleteEvent(postId: String!, attributionId: String): Boolean!
  sendVertexViewHomePageEvent: Boolean!
}

type CoauthorStatus {
  userId: String
  confirmed: Boolean
  requested: Boolean
}

type ExternalPost {
  _id: String!
  slug: String
  title: String
  url: String
  postedAt: Date
  createdAt: Date
  userId: String
  modifiedAt: Date
  draft: Boolean
  content: String
  coauthorStatuses: [CoauthorStatus!]
}

type ExternalPostImportData {
  alreadyExists: Boolean
  post: ExternalPost
}

extend type Mutation {
  importUrlAsDraftPost(url: String!): ExternalPostImportData!
}

input AutosaveContentType {
  type: String
  value: ContentTypeData
}

extend type Query {
  convertDocument(document: JSON, targetFormat: String): JSON
  latestGoogleDocMetadata(postId: String!, version: String): JSON
}

extend type Mutation {
  revertTagToRevision(tagId: String!, revertToRevisionId: String!): Tag
  autosaveRevision(postId: String!, contents: AutosaveContentType!): Revision
}

type ModeratorIPAddressInfo {
  ip: String!
  userIds: [String!]!
}

extend type Query {
  moderatorViewIPAddress(ipAddress: String!): ModeratorIPAddressInfo
}

extend type Mutation {
  lockThread(commentId: String!, until: String): Boolean!
  unlockThread(commentId: String!): Boolean!
}

extend type Mutation {
  reorderSummaries(parentDocumentId: String!, parentDocumentCollectionName: String!, summaryIds: [String!]!): Boolean
}

extend type Mutation {
  publishAndDeDuplicateSpotlight(spotlightId: String): Spotlight
}

extend type Query {
  currentSpotlight: Spotlight
}

extend type Mutation {
  upsertUserTypingIndicator(documentId: String!): TypingIndicator
}

extend type Mutation {
  acceptCoauthorRequest(postId: String, userId: String, accept: Boolean): Post
}

input ToggleBookmarkInput {
  documentId: String!
  collectionName: String!
}

type ToggleBookmarkOutput {
  data: Bookmark
}

extend type Mutation {
  toggleBookmark(input: ToggleBookmarkInput!): ToggleBookmarkOutput
}

extend type Mutation {
  setIsHidden(postId: String!, isHidden: Boolean!): User!
}

extend type Mutation {
  markAsReadOrUnread(postId: String, isRead: Boolean): Boolean
  markPostCommentsRead(postId: String!): Boolean
}

type RssPostChangeInfo {
  isChanged: Boolean!
  newHtml: String!
  htmlDiff: String!
}

extend type Mutation {
  resyncRssFeed(feedId: String!): Boolean!
}

extend type Query {
  RssPostChanges(postId: String!): RssPostChangeInfo!
}

extend type Mutation {
  updateContinueReading(sequenceId: String!, postId: String!): Boolean
}

extend type Mutation {
  getNewJargonTerms(postId: String!, glossaryPrompt: String, examplePost: String, exampleTerm: String, exampleAltTerm: String, exampleDefinition: String): [JargonTerm]
}

extend type Mutation {
  RSVPToEvent(postId: String, name: String, email: String, private: Boolean, response: String): Post
  CancelRSVPToEvent(postId: String, name: String, userId: String): Post
}

extend type Query {
  AdminMetadata: String
}

extend type Mutation {
  addOrUpvoteTag(tagId: String, postId: String): TagRel
  addTags(postId: String, tagIds: [String]): Boolean
}

extend type Mutation {
  analyticsEvent(events: [JSON!], now: Date): Boolean
}

extend type Query {
  currentUser: User
}

extend type Query {
  SearchSynonyms: [String!]!
}

extend type Mutation {
  UpdateSearchSynonyms(synonyms: [String!]!): [String!]!
}

extend type Mutation {
  useEmailToken(token: String, args: JSON): JSON
}

extend type Mutation {
  connectCrossposter(token: String): String
  unlinkCrossposter: String
}

extend type Query {
  getCrosspost(args: JSON): JSON
}

extend type Query {
  RevisionsDiff(collectionName: String!, fieldName: String!, id: String, beforeRev: String, afterRev: String!, trim: Boolean): String
}

extend type Mutation {
  observeRecommendation(postId: String!): Boolean
  clickRecommendation(postId: String!): Boolean
}

extend type Mutation {
  increasePostViewCount(postId: String): Float
}

type FeedSpotlightMetaInfo {
  sources: [String!]!
  servedEventId: String!
}

type FeedPost {
  _id: String!
  postMetaInfo: JSON
  post: Post!
}

type FeedCommentThread {
  _id: String!
  commentMetaInfos: JSON
  comments: [Comment!]!
  post: Post
  isOnReadPost: Boolean
  postSources: [String!]
}

type FeedSpotlightItem {
  _id: String!
  spotlight: Spotlight
  post: Post
  spotlightMetaInfo: FeedSpotlightMetaInfo
}

type FeedSubscriptionSuggestions {
  _id: String!
  suggestedUsers: [User!]!
}

type UltraFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [UltraFeedEntry!]
  sessionId: String
}

enum UltraFeedEntryType {
  feedCommentThread
  feedPost
  feedSpotlight
  feedSubscriptionSuggestions
}

type UltraFeedEntry {
  type: UltraFeedEntryType!
  feedCommentThread: FeedCommentThread
  feedPost: FeedPost
  feedSpotlight: FeedSpotlightItem
  feedSubscriptionSuggestions: FeedSubscriptionSuggestions
}

extend type Query {
  UltraFeed(limit: Int, cutoff: Date, offset: Int, sessionId: String, settings: JSON): UltraFeedQueryResults!
}

extend type Mutation {
  generateCoverImagesForPost(postId: String!, prompt: String): [ReviewWinnerArt]
}

extend type Mutation {
  flipSplashArtImage(reviewWinnerArtId: String!): Boolean
}

type ElicitQuestionPredictionCreator {
  _id: String!
  displayName: String!
  isQuestionCreator: Boolean!
  sourceUserId: String
}

type AdvisorRequest {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String
  user: User
  interestedInMetaculus: Boolean
  jobAds: JSON
}

input SingleAdvisorRequestInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleAdvisorRequestOutput {
  result: AdvisorRequest
}

input AdvisorRequestsRequestsByUserInput {
  userId: String
}

input AdvisorRequestSelector {
  default: EmptyViewInput
  requestsByUser: AdvisorRequestsRequestsByUserInput
}

input MultiAdvisorRequestInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiAdvisorRequestOutput {
  results: [AdvisorRequest!]!
  totalCount: Int
}

extend type Query {
  advisorRequest(input: SingleAdvisorRequestInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleAdvisorRequestOutput
  advisorRequests(input: MultiAdvisorRequestInput @deprecated(reason: "Use the selector field instead"), selector: AdvisorRequestSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiAdvisorRequestOutput
}

type ArbitalCaches {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
}

type ArbitalTagContentRel {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  parentDocumentId: String!
  childDocumentId: String!
  parentCollectionName: String!
  childCollectionName: String!
  type: String!
  level: Float!
  isStrong: Boolean!
}

input SingleArbitalTagContentRelInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleArbitalTagContentRelOutput {
  result: ArbitalTagContentRel
}

input ArbitalTagContentRelSelector {
  default: EmptyViewInput
}

input MultiArbitalTagContentRelInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiArbitalTagContentRelOutput {
  results: [ArbitalTagContentRel!]!
  totalCount: Int
}

extend type Query {
  arbitalTagContentRel(input: SingleArbitalTagContentRelInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleArbitalTagContentRelOutput
  arbitalTagContentRels(input: MultiArbitalTagContentRelInput @deprecated(reason: "Use the selector field instead"), selector: ArbitalTagContentRelSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiArbitalTagContentRelOutput
}

type AutomatedContentEvaluation {
  _id: String!
  createdAt: Date!
  revisionId: String!
  score: Float
  sentenceScores: [SentenceScore!]
  aiChoice: String
  aiReasoning: String
  aiCoT: String
}

type SentenceScore {
  sentence: String!
  score: Float!
}

type Ban {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  expirationDate: Date
  userId: String!
  user: User
  ip: String
  reason: String
  comment: String!
  properties: JSON
}

input SingleBanInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleBanOutput {
  result: Ban
}

input BanSelector {
  default: EmptyViewInput
}

input MultiBanInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiBanOutput {
  results: [Ban!]!
  totalCount: Int
}

extend type Query {
  ban(input: SingleBanInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleBanOutput
  bans(input: MultiBanInput @deprecated(reason: "Use the selector field instead"), selector: BanSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiBanOutput
}

type Bookmark {
  _id: String!
  createdAt: Date!
  documentId: String!
  collectionName: String!
  userId: String!
  post: Post
  comment: Comment
  lastUpdated: Date!
  active: Boolean!
}

input SingleBookmarkInput {
  selector: SelectorInput
  resolverArgs: JSON
  allowNull: Boolean
}

type SingleBookmarkOutput {
  result: Bookmark
}

input BookmarksUserDocumentBookmarkInput {
  userId: String
  documentId: String
  collectionName: String
}

input BookmarkSelector {
  myBookmarkedPosts: EmptyViewInput
  myBookmarks: EmptyViewInput
  userDocumentBookmark: BookmarksUserDocumentBookmarkInput
}

input MultiBookmarkInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiBookmarkOutput {
  results: [Bookmark!]!
  totalCount: Int
}

extend type Query {
  bookmark(input: SingleBookmarkInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleBookmarkOutput
  bookmarks(input: MultiBookmarkInput @deprecated(reason: "Use the selector field instead"), selector: BookmarkSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiBookmarkOutput
}

type Book {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  postedAt: Date
  title: String
  subtitle: String
  tocTitle: String
  collectionId: String!
  number: Float
  postIds: [String!]!
  posts: [Post!]!
  sequenceIds: [String!]!
  sequences: [Sequence!]!
  displaySequencesAsGrid: Boolean
  hideProgressBar: Boolean
  showChapters: Boolean
}

input SingleBookInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleBookOutput {
  result: Book
}

input BookSelector {
  default: EmptyViewInput
}

input MultiBookInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiBookOutput {
  results: [Book!]!
  totalCount: Int
}

extend type Query {
  book(input: SingleBookInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleBookOutput
  books(input: MultiBookInput @deprecated(reason: "Use the selector field instead"), selector: BookSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiBookOutput
}

type Chapter {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  title: String
  subtitle: String
  number: Float
  sequenceId: String
  sequence: Sequence
  postIds: [String!]!
  posts: [Post!]!
}

input SingleChapterInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleChapterOutput {
  result: Chapter
}

input ChaptersSequenceChaptersInput {
  sequenceId: String
  limit: String
}

input ChapterSelector {
  default: EmptyViewInput
  SequenceChapters: ChaptersSequenceChaptersInput
}

input MultiChapterInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiChapterOutput {
  results: [Chapter!]!
  totalCount: Int
}

extend type Query {
  chapter(input: SingleChapterInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleChapterOutput
  chapters(input: MultiChapterInput @deprecated(reason: "Use the selector field instead"), selector: ChapterSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiChapterOutput
}

type CkEditorUserSession {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  documentId: String
  userId: String
  endedAt: Date
  endedBy: String
}

input SingleCkEditorUserSessionInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleCkEditorUserSessionOutput {
  result: CkEditorUserSession
}

input CkEditorUserSessionSelector {
  default: EmptyViewInput
}

input MultiCkEditorUserSessionInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiCkEditorUserSessionOutput {
  results: [CkEditorUserSession!]!
  totalCount: Int
}

extend type Query {
  ckEditorUserSession(input: SingleCkEditorUserSessionInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleCkEditorUserSessionOutput
  ckEditorUserSessions(input: MultiCkEditorUserSessionInput @deprecated(reason: "Use the selector field instead"), selector: CkEditorUserSessionSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiCkEditorUserSessionOutput
}

type ClientId {
  _id: String!
  schemaVersion: Float!
  createdAt: Date
  legacyData: JSON
  clientId: String
  firstSeenReferrer: String
  firstSeenLandingPage: String
  userIds: [String!]
  users: [User!]
  invalidated: Boolean
  lastSeenAt: Date
  timesSeen: Float
}

input SingleClientIdInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleClientIdOutput {
  result: ClientId
}

input ClientIdsGetClientIdInput {
  clientId: String
}

input ClientIdSelector {
  default: EmptyViewInput
  getClientId: ClientIdsGetClientIdInput
}

input MultiClientIdInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiClientIdOutput {
  results: [ClientId!]!
  totalCount: Int
}

extend type Query {
  clientId(input: SingleClientIdInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleClientIdOutput
  clientIds(input: MultiClientIdInput @deprecated(reason: "Use the selector field instead"), selector: ClientIdSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiClientIdOutput
}

type Collection {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  userId: String!
  user: User
  title: String!
  slug: String!
  books: [Book!]!
  postsCount: Int!
  readPostsCount: Int!
  gridImageId: String
  firstPageLink: String!
  hideStartReadingButton: Boolean
  noindex: Boolean!
}

input SingleCollectionInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleCollectionOutput {
  result: Collection
}

input CollectionDefaultViewInput {
  collectionIds: [String!]
}

input CollectionSelector {
  default: CollectionDefaultViewInput
}

input MultiCollectionInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiCollectionOutput {
  results: [Collection!]!
  totalCount: Int
}

extend type Query {
  collection(input: SingleCollectionInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleCollectionOutput
  collections(input: MultiCollectionInput @deprecated(reason: "Use the selector field instead"), selector: CollectionSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiCollectionOutput
}

type CommentModeratorAction {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  commentId: String
  comment: Comment
  type: String
  endedAt: Date
  active: Boolean
}

input SingleCommentModeratorActionInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleCommentModeratorActionOutput {
  result: CommentModeratorAction
}

input CommentModeratorActionsActiveCommentModeratorActionsInput {
  limit: String
}

input CommentModeratorActionSelector {
  default: EmptyViewInput
  activeCommentModeratorActions: CommentModeratorActionsActiveCommentModeratorActionsInput
}

input MultiCommentModeratorActionInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiCommentModeratorActionOutput {
  results: [CommentModeratorAction!]!
  totalCount: Int
}

extend type Query {
  commentModeratorAction(input: SingleCommentModeratorActionInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleCommentModeratorActionOutput
  commentModeratorActions(input: MultiCommentModeratorActionInput @deprecated(reason: "Use the selector field instead"), selector: CommentModeratorActionSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiCommentModeratorActionOutput
}

type Comment {
  _id: String!
  schemaVersion: Float!
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  pingbacks: JSON
  parentCommentId: String
  parentComment: Comment
  topLevelCommentId: String
  topLevelComment: Comment
  postedAt: Date!
  lastEditedAt: Date
  author: String
  postId: String
  post: Post
  tagId: String
  tag: Tag
  forumEventId: String
  forumEvent: ForumEvent
  forumEventMetadata: JSON
  tagCommentType: TagCommentType!
  subforumStickyPriority: Float
  userId: String
  user: User
  userIP: String
  userAgent: String
  referrer: String
  authorIsUnreviewed: Boolean!
  pageUrl: String
  pageUrlRelative: String
  answer: Boolean!
  parentAnswerId: String
  parentAnswer: Comment
  directChildrenCount: Float!
  descendentCount: Float!
  latestChildren: [Comment!]!
  shortform: Boolean
  shortformFrontpage: Boolean!
  nominatedForReview: String
  reviewingForReview: String
  lastSubthreadActivity: Date
  postVersion: String
  promoted: Boolean
  promotedByUserId: String
  promotedByUser: User
  promotedAt: Date
  hideKarma: Boolean
  wordCount: Int
  htmlBody: String
  votingSystem: String!
  legacy: Boolean!
  legacyId: String
  legacyPoll: Boolean!
  legacyParentId: String
  draft: Boolean!
  retracted: Boolean!
  deleted: Boolean!
  deletedPublic: Boolean!
  deletedReason: String
  deletedDate: Date
  deletedByUserId: String
  deletedByUser: User
  spam: Boolean!
  repliesBlockedUntil: Date
  needsReview: Boolean
  reviewedByUserId: String
  reviewedByUser: User
  hideAuthor: Boolean!
  moderatorHat: Boolean!
  hideModeratorHat: Boolean
  isPinnedOnProfile: Boolean!
  title: String
  relevantTagIds: [String!]!
  relevantTags: [Tag!]!
  debateResponse: Boolean
  rejected: Boolean!
  modGPTAnalysis: String
  modGPTRecommendation: String
  rejectedReason: String
  rejectedByUserId: String
  rejectedByUser: User
  emojiReactors: JSON
  af: Boolean!
  suggestForAlignmentUserIds: [String!]!
  suggestForAlignmentUsers: [User!]!
  reviewForAlignmentUserId: String
  afDate: Date
  moveToAlignmentUserId: String
  moveToAlignmentUser: User
  agentFoundationsId: String
  originalDialogueId: String
  originalDialogue: Post
  currentUserVote: String
  currentUserExtendedVote: JSON
  allVotes: [Vote!]
  voteCount: Float!
  baseScore: Float
  extendedScore: JSON
  score: Float!
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

enum TagCommentType {
  SUBFORUM
  DISCUSSION
}

enum CommentSortingMode {
  top
  groupByPost
  new
  newest
  old
  oldest
  magic
  recentComments
  recentDiscussion
}

input SingleCommentInput {
  selector: SelectorInput
  resolverArgs: JSON
  allowNull: Boolean
}

type SingleCommentOutput {
  result: Comment
}

input CommentDefaultViewInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
}

input CommentsCommentRepliesInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  parentCommentId: String
}

input CommentsPostCommentsDeletedInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
}

input CommentsAllCommentsDeletedInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
}

input CommentsCheckedByModGPTInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
}

input CommentsPostCommentsTopInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
}

input CommentsPostCommentsRecentRepliesInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
}

input CommentsPostCommentsMagicInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
}

input CommentsAfPostCommentsTopInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
}

input CommentsPostCommentsOldInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
}

input CommentsPostCommentsNewInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
}

input CommentsPostCommentsBestInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
}

input CommentsPostLWCommentsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
}

input CommentsProfileRecentCommentsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  limit: String
}

input CommentsProfileCommentsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  sortBy: String
  drafts: String
  limit: String
}

input CommentsAllRecentCommentsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  sortBy: String
  limit: String
}

input CommentsRecentCommentsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  sortBy: String
  limit: String
}

input CommentsAfSubmissionsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  limit: String
}

input CommentsRejectedInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  limit: String
}

input CommentsRecentDiscussionThreadInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
  limit: String
}

input CommentsAfRecentDiscussionThreadInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
  limit: String
}

input CommentsPostsItemCommentsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
  after: String
  limit: String
}

input CommentsSunshineNewCommentsListInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  limit: String
}

input CommentsQuestionAnswersInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
  sortBy: String
}

input CommentsLegacyIdCommentInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  legacyId: String
}

input CommentsSunshineNewUsersCommentsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
}

input CommentsDefaultModeratorResponsesInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  tagId: String
}

input CommentsRepliesToAnswerInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  parentAnswerId: String
}

input CommentsAnswersAndRepliesInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
  sortBy: String
}

input CommentsTopShortformInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  before: String
  after: String
  shortformFrontpage: Boolean
}

input CommentsShortformInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
}

input CommentsShortformFrontpageInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  maxAgeDays: Int
  showCommunity: Boolean
  relevantTagId: String
}

input CommentsRepliesToCommentThreadInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  topLevelCommentId: String
}

input CommentsRepliesToCommentThreadIncludingRootInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  topLevelCommentId: String!
}

input CommentsShortformLatestChildrenInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  topLevelCommentId: String
}

input CommentsNominations2018Input {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
  sortBy: CommentSortingMode
}

input CommentsNominations2019Input {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
  sortBy: CommentSortingMode
}

input CommentsReviews2018Input {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
  sortBy: CommentSortingMode
}

input CommentsReviews2019Input {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
  sortBy: CommentSortingMode
}

input CommentsReviewsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
  reviewYear: Int
  sortBy: String
}

input CommentsTagDiscussionCommentsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  tagId: String
}

input CommentsTagSubforumCommentsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
}

input CommentsLatestSubforumDiscussionInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  profileTagIds: String
}

input CommentsModeratorCommentsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
}

input CommentsDebateResponsesInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
}

input CommentsRecentDebateResponsesInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
  limit: String
}

input CommentsForumEventCommentsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  forumEventId: String
}

input CommentsAlignmentSuggestedCommentsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
}

input CommentsRssInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
}

input CommentsDraftCommentsInput {
  userId: String
  commentIds: [String!]
  minimumKarma: Int
  authorIsUnreviewed: Boolean
  postId: String
  drafts: String
}

input CommentSelector {
  default: CommentDefaultViewInput
  commentReplies: CommentsCommentRepliesInput
  postCommentsDeleted: CommentsPostCommentsDeletedInput
  allCommentsDeleted: CommentsAllCommentsDeletedInput
  checkedByModGPT: CommentsCheckedByModGPTInput
  postCommentsTop: CommentsPostCommentsTopInput
  postCommentsRecentReplies: CommentsPostCommentsRecentRepliesInput
  postCommentsMagic: CommentsPostCommentsMagicInput
  afPostCommentsTop: CommentsAfPostCommentsTopInput
  postCommentsOld: CommentsPostCommentsOldInput
  postCommentsNew: CommentsPostCommentsNewInput
  postCommentsBest: CommentsPostCommentsBestInput
  postLWComments: CommentsPostLWCommentsInput
  profileRecentComments: CommentsProfileRecentCommentsInput
  profileComments: CommentsProfileCommentsInput
  allRecentComments: CommentsAllRecentCommentsInput
  recentComments: CommentsRecentCommentsInput
  afSubmissions: CommentsAfSubmissionsInput
  rejected: CommentsRejectedInput
  recentDiscussionThread: CommentsRecentDiscussionThreadInput
  afRecentDiscussionThread: CommentsAfRecentDiscussionThreadInput
  postsItemComments: CommentsPostsItemCommentsInput
  sunshineNewCommentsList: CommentsSunshineNewCommentsListInput
  questionAnswers: CommentsQuestionAnswersInput
  legacyIdComment: CommentsLegacyIdCommentInput
  sunshineNewUsersComments: CommentsSunshineNewUsersCommentsInput
  defaultModeratorResponses: CommentsDefaultModeratorResponsesInput
  repliesToAnswer: CommentsRepliesToAnswerInput
  answersAndReplies: CommentsAnswersAndRepliesInput
  topShortform: CommentsTopShortformInput
  shortform: CommentsShortformInput
  shortformFrontpage: CommentsShortformFrontpageInput
  repliesToCommentThread: CommentsRepliesToCommentThreadInput
  shortformLatestChildren: CommentsShortformLatestChildrenInput
  repliesToCommentThreadIncludingRoot: CommentsRepliesToCommentThreadIncludingRootInput
  nominations2018: CommentsNominations2018Input
  nominations2019: CommentsNominations2019Input
  reviews2018: CommentsReviews2018Input
  reviews2019: CommentsReviews2019Input
  reviews: CommentsReviewsInput
  tagDiscussionComments: CommentsTagDiscussionCommentsInput
  tagSubforumComments: CommentsTagSubforumCommentsInput
  latestSubforumDiscussion: CommentsLatestSubforumDiscussionInput
  moderatorComments: CommentsModeratorCommentsInput
  debateResponses: CommentsDebateResponsesInput
  recentDebateResponses: CommentsRecentDebateResponsesInput
  forumEventComments: CommentsForumEventCommentsInput
  alignmentSuggestedComments: CommentsAlignmentSuggestedCommentsInput
  rss: CommentsRssInput
  draftComments: CommentsDraftCommentsInput
}

input MultiCommentInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiCommentOutput {
  results: [Comment!]!
  totalCount: Int
}

extend type Query {
  comment(input: SingleCommentInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput, allowNull: Boolean): SingleCommentOutput
  comments(input: MultiCommentInput @deprecated(reason: "Use the selector field instead"), selector: CommentSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiCommentOutput
}

type Conversation {
  _id: String!
  schemaVersion: Float!
  createdAt: Date
  legacyData: JSON
  title: String
  participantIds: [String!]
  participants: [User!]
  latestActivity: Date
  af: Boolean
  messageCount: Float!
  moderator: Boolean
  archivedByIds: [String!]!
  archivedBy: [User!]!
  latestMessage: Message
  hasUnreadMessages: Boolean
}

input SingleConversationInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleConversationOutput {
  result: Conversation
}

input ConversationsModeratorConversationsInput {
  showArchive: Boolean
  userId: String
}

input ConversationsUserConversationsInput {
  showArchive: Boolean
  userId: String
}

input ConversationsUserConversationsAllInput {
  showArchive: Boolean
  userId: String
}

input ConversationsUserGroupUntitledConversationsInput {
  moderator: String
  participantIds: String
  userId: String
}

input ConversationSelector {
  default: EmptyViewInput
  moderatorConversations: ConversationsModeratorConversationsInput
  userConversations: ConversationsUserConversationsInput
  userConversationsAll: ConversationsUserConversationsAllInput
  userGroupUntitledConversations: ConversationsUserGroupUntitledConversationsInput
}

input MultiConversationInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiConversationOutput {
  results: [Conversation!]!
  totalCount: Int
}

extend type Query {
  conversation(input: SingleConversationInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleConversationOutput
  conversations(input: MultiConversationInput @deprecated(reason: "Use the selector field instead"), selector: ConversationSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiConversationOutput
}

type CronHistory {
  _id: String
  intendedAt: Date
  name: String
  startedAt: Date
  finishedAt: Date
  result: JSON
}

type CurationEmail {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String
  postId: String
}

type CurationNotice {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  userId: String!
  user: User
  commentId: String
  comment: Comment
  postId: String!
  post: Post
  deleted: Boolean!
}

input SingleCurationNoticeInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleCurationNoticeOutput {
  result: CurationNotice
}

input CurationNoticeSelector {
  default: EmptyViewInput
  curationNoticesPage: EmptyViewInput
}

input MultiCurationNoticeInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiCurationNoticeOutput {
  results: [CurationNotice!]!
  totalCount: Int
}

extend type Query {
  curationNotice(input: SingleCurationNoticeInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleCurationNoticeOutput
  curationNotices(input: MultiCurationNoticeInput @deprecated(reason: "Use the selector field instead"), selector: CurationNoticeSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiCurationNoticeOutput
}

type DatabaseMetadata {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
}

type DebouncerEvents {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
}

type DialogueCheck {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String
  targetUserId: String
  checked: Boolean
  checkedAt: Date
  hideInRecommendations: Boolean
  matchPreference: DialogueMatchPreference
  reciprocalMatchPreference: DialogueMatchPreference
}

input SingleDialogueCheckInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleDialogueCheckOutput {
  result: DialogueCheck
}

input DialogueChecksUserDialogueChecksInput {
  userId: String
}

input DialogueChecksUserTargetDialogueChecksInput {
  userId: String
  targetUserIds: String
}

input DialogueCheckSelector {
  default: EmptyViewInput
  userDialogueChecks: DialogueChecksUserDialogueChecksInput
  userTargetDialogueChecks: DialogueChecksUserTargetDialogueChecksInput
}

input MultiDialogueCheckInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiDialogueCheckOutput {
  results: [DialogueCheck!]!
  totalCount: Int
}

extend type Query {
  dialogueCheck(input: SingleDialogueCheckInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleDialogueCheckOutput
  dialogueChecks(input: MultiDialogueCheckInput @deprecated(reason: "Use the selector field instead"), selector: DialogueCheckSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiDialogueCheckOutput
}

type DialogueMatchPreference {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  dialogueCheckId: String
  dialogueCheck: DialogueCheck
  topicPreferences: [JSON!]
  topicNotes: String
  syncPreference: String
  asyncPreference: String
  formatNotes: String
  calendlyLink: String
  generatedDialogueId: String
  deleted: Boolean!
}

input SingleDialogueMatchPreferenceInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleDialogueMatchPreferenceOutput {
  result: DialogueMatchPreference
}

input DialogueMatchPreferencesDialogueMatchPreferencesInput {
  dialogueCheckId: String
}

input DialogueMatchPreferenceSelector {
  default: EmptyViewInput
  dialogueMatchPreferences: DialogueMatchPreferencesDialogueMatchPreferencesInput
}

input MultiDialogueMatchPreferenceInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiDialogueMatchPreferenceOutput {
  results: [DialogueMatchPreference!]!
  totalCount: Int
}

extend type Query {
  dialogueMatchPreference(input: SingleDialogueMatchPreferenceInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleDialogueMatchPreferenceOutput
  dialogueMatchPreferences(input: MultiDialogueMatchPreferenceInput @deprecated(reason: "Use the selector field instead"), selector: DialogueMatchPreferenceSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiDialogueMatchPreferenceOutput
}

type DigestPost {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  digestId: String!
  digest: Digest!
  postId: String!
  post: Post
  emailDigestStatus: String
  onsiteDigestStatus: String
}

input SingleDigestPostInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleDigestPostOutput {
  result: DigestPost
}

input DigestPostSelector {
  default: EmptyViewInput
}

input MultiDigestPostInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiDigestPostOutput {
  results: [DigestPost!]!
  totalCount: Int
}

extend type Query {
  digestPost(input: SingleDigestPostInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleDigestPostOutput
  digestPosts(input: MultiDigestPostInput @deprecated(reason: "Use the selector field instead"), selector: DigestPostSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiDigestPostOutput
}

type Digest {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  num: Float!
  startDate: Date!
  endDate: Date
  publishedDate: Date
  onsiteImageId: String
  onsitePrimaryColor: String
}

input SingleDigestInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleDigestOutput {
  result: Digest
}

input DigestsFindByNumInput {
  num: Int
}

input DigestSelector {
  default: EmptyViewInput
  findByNum: DigestsFindByNumInput
  all: EmptyViewInput
}

input MultiDigestInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiDigestOutput {
  results: [Digest!]!
  totalCount: Int
}

extend type Query {
  digest(input: SingleDigestInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleDigestOutput
  digests(input: MultiDigestInput @deprecated(reason: "Use the selector field instead"), selector: DigestSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiDigestOutput
}

type ElectionCandidate {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  electionName: String!
  name: String!
  logoSrc: String!
  href: String!
  fundraiserLink: String
  gwwcLink: String
  gwwcId: String
  description: String!
  userId: String!
  user: User
  postCount: Float!
  tagId: String!
  tag: Tag
  isElectionFundraiser: Boolean!
  amountRaised: Float
  targetAmount: Float
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float!
  baseScore: Float!
  extendedScore: JSON
  score: Float!
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input SingleElectionCandidateInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleElectionCandidateOutput {
  result: ElectionCandidate
}

input ElectionCandidateDefaultViewInput {
  electionName: String
  sortBy: String
}

input ElectionCandidateSelector {
  default: ElectionCandidateDefaultViewInput
}

input MultiElectionCandidateInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiElectionCandidateOutput {
  results: [ElectionCandidate!]!
  totalCount: Int
}

extend type Query {
  electionCandidate(input: SingleElectionCandidateInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleElectionCandidateOutput
  electionCandidates(input: MultiElectionCandidateInput @deprecated(reason: "Use the selector field instead"), selector: ElectionCandidateSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiElectionCandidateOutput
}

type ElectionVote {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  electionName: String
  userId: String
  user: User
  compareState: JSON
  vote: JSON
  submittedAt: Date
  submissionComments: JSON
  userExplanation: String
  userOtherComments: String
}

input SingleElectionVoteInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleElectionVoteOutput {
  result: ElectionVote
}

input ElectionVoteDefaultViewInput {
  electionName: String
  userId: String
}

input ElectionVotesAllSubmittedVotesInput {
  electionName: String
  userId: String
}

input ElectionVoteSelector {
  default: ElectionVoteDefaultViewInput
  allSubmittedVotes: ElectionVotesAllSubmittedVotesInput
}

input MultiElectionVoteInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiElectionVoteOutput {
  results: [ElectionVote!]!
  totalCount: Int
}

extend type Query {
  electionVote(input: SingleElectionVoteInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleElectionVoteOutput
  electionVotes(input: MultiElectionVoteInput @deprecated(reason: "Use the selector field instead"), selector: ElectionVoteSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiElectionVoteOutput
}

type ElicitQuestionPrediction {
  _id: String!
  predictionId: String
  prediction: Float
  createdAt: Date!
  notes: String
  creator: ElicitQuestionPredictionCreator!
  userId: String
  user: User
  sourceUrl: String
  sourceId: String
  binaryQuestionId: String!
  question: ElicitQuestion!
  isDeleted: Boolean!
}

input SingleElicitQuestionPredictionInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleElicitQuestionPredictionOutput {
  result: ElicitQuestionPrediction
}

input ElicitQuestionPredictionSelector {
  default: EmptyViewInput
}

input MultiElicitQuestionPredictionInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiElicitQuestionPredictionOutput {
  results: [ElicitQuestionPrediction!]!
  totalCount: Int
}

extend type Query {
  elicitQuestionPrediction(input: SingleElicitQuestionPredictionInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleElicitQuestionPredictionOutput
  elicitQuestionPredictions(input: MultiElicitQuestionPredictionInput @deprecated(reason: "Use the selector field instead"), selector: ElicitQuestionPredictionSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiElicitQuestionPredictionOutput
}

type ElicitQuestion {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  title: String!
  notes: String
  resolution: String
  resolvesBy: Date
}

input SingleElicitQuestionInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleElicitQuestionOutput {
  result: ElicitQuestion
}

input ElicitQuestionSelector {
  default: EmptyViewInput
}

input MultiElicitQuestionInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiElicitQuestionOutput {
  results: [ElicitQuestion!]!
  totalCount: Int
}

extend type Query {
  elicitQuestion(input: SingleElicitQuestionInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleElicitQuestionOutput
  elicitQuestions(input: MultiElicitQuestionInput @deprecated(reason: "Use the selector field instead"), selector: ElicitQuestionSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiElicitQuestionOutput
}

type EmailTokens {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
}

type FeaturedResource {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  title: String!
  body: String
  ctaText: String!
  ctaUrl: String!
  expiresAt: Date!
}

input SingleFeaturedResourceInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleFeaturedResourceOutput {
  result: FeaturedResource
}

input FeaturedResourceSelector {
  default: EmptyViewInput
  activeResources: EmptyViewInput
}

input MultiFeaturedResourceInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiFeaturedResourceOutput {
  results: [FeaturedResource!]!
  totalCount: Int
}

extend type Query {
  featuredResource(input: SingleFeaturedResourceInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleFeaturedResourceOutput
  featuredResources(input: MultiFeaturedResourceInput @deprecated(reason: "Use the selector field instead"), selector: FeaturedResourceSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiFeaturedResourceOutput
}

type FieldChange {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String
  user: User
  changeGroup: String
  documentId: String
  fieldName: String
  oldValue: JSON
  newValue: JSON
}

input SingleFieldChangeInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleFieldChangeOutput {
  result: FieldChange
}

input FieldChangeSelector {
  default: EmptyViewInput
}

input MultiFieldChangeInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
}

type MultiFieldChangeOutput {
  results: [FieldChange!]!
  totalCount: Int
}

extend type Query {
  fieldChange(input: SingleFieldChangeInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleFieldChangeOutput
  fieldChanges(input: MultiFieldChangeInput @deprecated(reason: "Use the selector field instead"), selector: FieldChangeSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiFieldChangeOutput
}

type ForumEvent {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  frontpageDescription(version: String): Revision
  frontpageDescription_latest: String
  frontpageDescriptionMobile(version: String): Revision
  frontpageDescriptionMobile_latest: String
  postPageDescription(version: String): Revision
  postPageDescription_latest: String
  title: String!
  startDate: Date!
  endDate: Date
  darkColor: String!
  lightColor: String!
  bannerTextColor: String!
  contrastColor: String
  tagId: String
  tag: Tag
  postId: String
  post: Post
  commentId: String
  comment: Comment
  bannerImageId: String
  includesPoll: Boolean!
  isGlobal: Boolean!
  eventFormat: ForumEventFormat!
  pollQuestion(version: String): Revision
  pollQuestion_latest: String
  pollAgreeWording: String
  pollDisagreeWording: String
  maxStickersPerUser: Float!
  customComponent: ForumEventCustomComponent
  commentPrompt: String
  publicData: JSON
  voteCount: Int!
}

enum ForumEventCustomComponent {
  GivingSeason2024Banner
}

enum ForumEventFormat {
  BASIC
  POLL
  STICKERS
}

input SingleForumEventInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleForumEventOutput {
  result: ForumEvent
}

input ForumEventsUpcomingForumEventsInput {
  limit: String
}

input ForumEventsPastForumEventsInput {
  limit: String
}

input ForumEventsCurrentAndRecentForumEventsInput {
  limit: String
}

input ForumEventSelector {
  default: EmptyViewInput
  upcomingForumEvents: ForumEventsUpcomingForumEventsInput
  pastForumEvents: ForumEventsPastForumEventsInput
  currentForumEvent: EmptyViewInput
  currentAndRecentForumEvents: ForumEventsCurrentAndRecentForumEventsInput
}

input MultiForumEventInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiForumEventOutput {
  results: [ForumEvent!]!
  totalCount: Int
}

extend type Query {
  forumEvent(input: SingleForumEventInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleForumEventOutput
  forumEvents(input: MultiForumEventInput @deprecated(reason: "Use the selector field instead"), selector: ForumEventSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiForumEventOutput
}

type GardenCode {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  pingbacks: JSON
  slug: String!
  code: String!
  title: String!
  userId: String!
  user: User
  startTime: Date
  endTime: Date!
  fbLink: String
  type: String!
  hidden: Boolean!
  deleted: Boolean!
  afOnly: Boolean!
}

input SingleGardenCodeInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleGardenCodeOutput {
  result: GardenCode
}

input GardenCodeDefaultViewInput {
  types: String
  userId: String
  code: String
}

input GardenCodesUsersPrivateGardenCodesInput {
  types: String
  userId: String
  code: String
}

input GardenCodesPublicGardenCodesInput {
  types: String
  userId: String
  code: String
}

input GardenCodesGardenCodeByCodeInput {
  types: String
  userId: String
  code: String
}

input GardenCodeSelector {
  default: GardenCodeDefaultViewInput
  usersPrivateGardenCodes: GardenCodesUsersPrivateGardenCodesInput
  publicGardenCodes: GardenCodesPublicGardenCodesInput
  gardenCodeByCode: GardenCodesGardenCodeByCodeInput
}

input MultiGardenCodeInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiGardenCodeOutput {
  results: [GardenCode!]!
  totalCount: Int
}

extend type Query {
  gardenCode(input: SingleGardenCodeInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleGardenCodeOutput
  gardenCodes(input: MultiGardenCodeInput @deprecated(reason: "Use the selector field instead"), selector: GardenCodeSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiGardenCodeOutput
}

type GoogleServiceAccountSession {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  email: String
  refreshToken: String
  estimatedExpiry: Date
  active: Boolean
  revoked: Boolean
}

input SingleGoogleServiceAccountSessionInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleGoogleServiceAccountSessionOutput {
  result: GoogleServiceAccountSession
}

input GoogleServiceAccountSessionSelector {
  default: EmptyViewInput
}

input MultiGoogleServiceAccountSessionInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiGoogleServiceAccountSessionOutput {
  results: [GoogleServiceAccountSession!]!
  totalCount: Int
}

extend type Query {
  googleServiceAccountSession(input: SingleGoogleServiceAccountSessionInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleGoogleServiceAccountSessionOutput
  googleServiceAccountSessions(input: MultiGoogleServiceAccountSessionInput @deprecated(reason: "Use the selector field instead"), selector: GoogleServiceAccountSessionSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiGoogleServiceAccountSessionOutput
}

type Images {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
}

type JargonTerm {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  postId: String!
  post: Post
  term: String!
  humansAndOrAIEdited: String
  approved: Boolean!
  deleted: Boolean!
  altTerms: [String!]!
}

input SingleJargonTermInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleJargonTermOutput {
  result: JargonTerm
}

input JargonTermsPostEditorJargonTermsInput {
  postId: String
}

input JargonTermsPostsApprovedJargonInput {
  postIds: String
}

input JargonTermSelector {
  default: EmptyViewInput
  postEditorJargonTerms: JargonTermsPostEditorJargonTermsInput
  glossaryEditAll: EmptyViewInput
  postsApprovedJargon: JargonTermsPostsApprovedJargonInput
}

input MultiJargonTermInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiJargonTermOutput {
  results: [JargonTerm!]!
  totalCount: Int
}

extend type Query {
  jargonTerm(input: SingleJargonTermInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleJargonTermOutput
  jargonTerms(input: MultiJargonTermInput @deprecated(reason: "Use the selector field instead"), selector: JargonTermSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiJargonTermOutput
}

type LWEvent {
  _id: String!
  schemaVersion: Float!
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  name: String
  documentId: String
  important: Boolean
  properties: JSON
  intercom: Boolean
}

input SingleLWEventInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleLWEventOutput {
  result: LWEvent
}

input LWEventsAdminViewInput {
  name: String
}

input LWEventsPostVisitsInput {
  postId: String
  userId: String
  limit: String
}

input LWEventsEmailHistoryInput {
  userId: String
}

input LWEventSelector {
  default: EmptyViewInput
  adminView: LWEventsAdminViewInput
  postVisits: LWEventsPostVisitsInput
  emailHistory: LWEventsEmailHistoryInput
  gatherTownUsers: EmptyViewInput
}

input MultiLWEventInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiLWEventOutput {
  results: [LWEvent!]!
  totalCount: Int
}

extend type Query {
  lWEvent(input: SingleLWEventInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleLWEventOutput
  lWEvents(input: MultiLWEventInput @deprecated(reason: "Use the selector field instead"), selector: LWEventSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiLWEventOutput
}

type LegacyData {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
}

type LlmConversation {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String
  user: User
  title: String
  model: String
  systemPrompt: String
  lastUpdatedAt: Date
  messages: [LlmMessage!]
  deleted: Boolean
  totalCharacterCount: Int
}

input SingleLlmConversationInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleLlmConversationOutput {
  result: LlmConversation
}

input LlmConversationsLlmConversationsWithUserInput {
  userId: String
}

input LlmConversationsLlmConversationsAllInput {
  showDeleted: Boolean
}

input LlmConversationSelector {
  default: EmptyViewInput
  llmConversationsWithUser: LlmConversationsLlmConversationsWithUserInput
  llmConversationsAll: LlmConversationsLlmConversationsAllInput
}

input MultiLlmConversationInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiLlmConversationOutput {
  results: [LlmConversation!]!
  totalCount: Int
}

extend type Query {
  llmConversation(input: SingleLlmConversationInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleLlmConversationOutput
  llmConversations(input: MultiLlmConversationInput @deprecated(reason: "Use the selector field instead"), selector: LlmConversationSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiLlmConversationOutput
}

type LlmMessage {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String
  conversationId: String
  role: String
  content: String
}

type Localgroup {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  name: String!
  nameInAnotherLanguage: String
  organizerIds: [String!]!
  organizers: [User!]!
  lastActivity: Date!
  types: [String!]!
  categories: [String!]
  isOnline: Boolean!
  mongoLocation: JSON
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  facebookPageLink: String
  meetupLink: String
  slackLink: String
  website: String
  bannerImageId: String
  inactive: Boolean!
  deleted: Boolean!
}

input SingleLocalgroupInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleLocalgroupOutput {
  result: Localgroup
}

input LocalgroupDefaultViewInput {
  filters: [String!]
  includeInactive: Boolean
}

input LocalgroupsUserOrganizesGroupsInput {
  filters: [String!]
  includeInactive: Boolean
  userId: String
}

input LocalgroupsUserActiveGroupsInput {
  filters: [String!]
  includeInactive: Boolean
  userId: String
}

input LocalgroupsUserInactiveGroupsInput {
  filters: [String!]
  includeInactive: Boolean
  userId: String
}

input LocalgroupsAllInput {
  filters: [String!]
  includeInactive: Boolean
}

input LocalgroupsNearbyInput {
  filters: [String!]
  includeInactive: Boolean
  lng: Float
  lat: Float
}

input LocalgroupsSingleInput {
  filters: [String!]
  includeInactive: Boolean
  groupId: String
}

input LocalgroupsLocalInput {
  filters: [String!]
  includeInactive: Boolean
}

input LocalgroupsOnlineInput {
  filters: [String!]
  includeInactive: Boolean
}

input LocalgroupSelector {
  default: LocalgroupDefaultViewInput
  userOrganizesGroups: LocalgroupsUserOrganizesGroupsInput
  userActiveGroups: LocalgroupsUserActiveGroupsInput
  userInactiveGroups: LocalgroupsUserInactiveGroupsInput
  all: LocalgroupsAllInput
  nearby: LocalgroupsNearbyInput
  single: LocalgroupsSingleInput
  local: LocalgroupsLocalInput
  online: LocalgroupsOnlineInput
}

input MultiLocalgroupInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiLocalgroupOutput {
  results: [Localgroup!]!
  totalCount: Int
}

extend type Query {
  localgroup(input: SingleLocalgroupInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleLocalgroupOutput
  localgroups(input: MultiLocalgroupInput @deprecated(reason: "Use the selector field instead"), selector: LocalgroupSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiLocalgroupOutput
}

type ManifoldProbabilitiesCache {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  marketId: String!
  probability: Float!
  isResolved: Boolean!
  year: Float!
  lastUpdated: Date!
  url: String
}

type Message {
  _id: String!
  schemaVersion: Float!
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  userId: String
  user: User
  conversationId: String
  conversation: Conversation
  noEmail: Boolean
}

input SingleMessageInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleMessageOutput {
  result: Message
}

input MessagesMessagesConversationInput {
  conversationId: String
}

input MessagesConversationPreviewInput {
  conversationId: String
}

input MessageSelector {
  default: EmptyViewInput
  messagesConversation: MessagesMessagesConversationInput
  conversationPreview: MessagesConversationPreviewInput
}

input MultiMessageInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiMessageOutput {
  results: [Message!]!
  totalCount: Int
}

extend type Query {
  message(input: SingleMessageInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleMessageOutput
  messages(input: MultiMessageInput @deprecated(reason: "Use the selector field instead"), selector: MessageSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiMessageOutput
}

type Migration {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
}

type ModerationTemplate {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  name: String!
  collectionName: ModerationTemplateType!
  order: Float!
  deleted: Boolean!
}

enum ModerationTemplateType {
  Messages
  Comments
  Rejections
}

input SingleModerationTemplateInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleModerationTemplateOutput {
  result: ModerationTemplate
}

input ModerationTemplatesModerationTemplatesListInput {
  collectionName: String
}

input ModerationTemplateSelector {
  default: EmptyViewInput
  moderationTemplatesPage: EmptyViewInput
  moderationTemplatesList: ModerationTemplatesModerationTemplatesListInput
}

input MultiModerationTemplateInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiModerationTemplateOutput {
  results: [ModerationTemplate!]!
  totalCount: Int
}

extend type Query {
  moderationTemplate(input: SingleModerationTemplateInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleModerationTemplateOutput
  moderationTemplates(input: MultiModerationTemplateInput @deprecated(reason: "Use the selector field instead"), selector: ModerationTemplateSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiModerationTemplateOutput
}

type ModeratorAction {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String!
  user: User
  type: ModeratorActionType!
  endedAt: Date
  active: Boolean!
}

enum ModeratorActionType {
  rateLimitOnePerDay
  rateLimitOnePerThreeDays
  rateLimitOnePerWeek
  rateLimitOnePerFortnight
  rateLimitOnePerMonth
  rateLimitThreeCommentsPerPost
  recentlyDownvotedContentAlert
  lowAverageKarmaCommentAlert
  lowAverageKarmaPostAlert
  negativeUserKarmaAlert
  movedPostToDraft
  sentModeratorMessage
  manualFlag
  votingPatternWarningDelivered
  flaggedForNDMs
  autoBlockedFromSendingDMs
  rejectedPost
  rejectedComment
  potentialTargetedDownvoting
  exemptFromRateLimits
  receivedSeniorDownvotesAlert
}

input SingleModeratorActionInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleModeratorActionOutput {
  result: ModeratorAction
}

input ModeratorActionsUserModeratorActionsInput {
  userIds: [String!]
}

input ModeratorActionSelector {
  default: EmptyViewInput
  userModeratorActions: ModeratorActionsUserModeratorActionsInput
  restrictionModerationActions: EmptyViewInput
}

input MultiModeratorActionInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiModeratorActionOutput {
  results: [ModeratorAction!]!
  totalCount: Int
}

extend type Query {
  moderatorAction(input: SingleModeratorActionInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleModeratorActionOutput
  moderatorActions(input: MultiModeratorActionInput @deprecated(reason: "Use the selector field instead"), selector: ModeratorActionSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiModeratorActionOutput
}

type MultiDocument {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  pingbacks: JSON
  slug: String!
  oldSlugs: [String!]!
  title: String
  preview: String
  tabTitle: String!
  tabSubtitle: String
  userId: String!
  user: User
  parentDocumentId: String!
  parentTag: Tag
  parentLens: MultiDocument
  collectionName: MultiDocumentCollectionName!
  fieldName: MultiDocumentFieldName!
  index: Float!
  tableOfContents(version: String): JSON
  contributors(limit: Int, version: String): TagContributorsList
  contributionStats: JSON
  arbitalLinkedPages: ArbitalLinkedPages
  htmlWithContributorAnnotations: String
  summaries: [MultiDocument!]!
  textLastUpdatedAt: Date
  deleted: Boolean!
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float!
  baseScore: Float!
  extendedScore: JSON
  score: Float!
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

enum MultiDocumentCollectionName {
  Tags
  MultiDocuments
}

enum MultiDocumentFieldName {
  description
  summary
}

input SingleMultiDocumentInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleMultiDocumentOutput {
  result: MultiDocument
}

input MultiDocumentDefaultViewInput {
  excludedDocumentIds: [String!]
}

input MultiDocumentsLensBySlugInput {
  excludedDocumentIds: [String!]
  slug: String
}

input MultiDocumentsSummariesByParentIdInput {
  excludedDocumentIds: [String!]
  parentDocumentId: String
}

input MultiDocumentsPingbackLensPagesInput {
  excludedDocumentIds: [String!]
  documentId: String
}

input MultiDocumentSelector {
  default: MultiDocumentDefaultViewInput
  lensBySlug: MultiDocumentsLensBySlugInput
  summariesByParentId: MultiDocumentsSummariesByParentIdInput
  pingbackLensPages: MultiDocumentsPingbackLensPagesInput
}

input MultiMultiDocumentInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiMultiDocumentOutput {
  results: [MultiDocument!]!
  totalCount: Int
}

extend type Query {
  multiDocument(input: SingleMultiDocumentInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleMultiDocumentOutput
  multiDocuments(input: MultiMultiDocumentInput @deprecated(reason: "Use the selector field instead"), selector: MultiDocumentSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiMultiDocumentOutput
}

type Notification {
  _id: String!
  schemaVersion: Float!
  createdAt: Date
  legacyData: JSON
  userId: String
  documentId: String
  documentType: String
  extraData: JSON
  link: String
  title: String
  message: String
  type: String
  deleted: Boolean
  viewed: Boolean
  emailed: Boolean
  waitingForBatch: Boolean
}

input SingleNotificationInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleNotificationOutput {
  result: Notification
}

input NotificationsUserNotificationsInput {
  userId: String
  type: String
  viewed: String
}

input NotificationsUnreadUserNotificationsInput {
  userId: String
  type: String
  lastViewedDate: String
}

input NotificationsAdminAlertNotificationsInput {
  type: String
}

input NotificationSelector {
  default: EmptyViewInput
  userNotifications: NotificationsUserNotificationsInput
  unreadUserNotifications: NotificationsUnreadUserNotificationsInput
  adminAlertNotifications: NotificationsAdminAlertNotificationsInput
}

input MultiNotificationInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiNotificationOutput {
  results: [Notification!]!
  totalCount: Int
}

extend type Query {
  notification(input: SingleNotificationInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleNotificationOutput
  notifications(input: MultiNotificationInput @deprecated(reason: "Use the selector field instead"), selector: NotificationSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiNotificationOutput
}

type PageCacheEntry {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
}

type PetrovDayAction {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  actionType: String!
  data: JSON
  userId: String
}

input SinglePetrovDayActionInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SinglePetrovDayActionOutput {
  result: PetrovDayAction
}

input PetrovDayActionsGetActionInput {
  userId: String
  actionType: String
}

input PetrovDayActionsLaunchDashboardInput {
  side: String
}

input PetrovDayActionsWarningConsoleInput {
  side: String
}

input PetrovDayActionSelector {
  default: EmptyViewInput
  getAction: PetrovDayActionsGetActionInput
  launchDashboard: PetrovDayActionsLaunchDashboardInput
  adminConsole: EmptyViewInput
  warningConsole: PetrovDayActionsWarningConsoleInput
}

input MultiPetrovDayActionInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiPetrovDayActionOutput {
  results: [PetrovDayAction!]!
  totalCount: Int
}

extend type Query {
  petrovDayAction(input: SinglePetrovDayActionInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SinglePetrovDayActionOutput
  petrovDayActions(input: MultiPetrovDayActionInput @deprecated(reason: "Use the selector field instead"), selector: PetrovDayActionSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiPetrovDayActionOutput
}

type PetrovDayLaunch {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  launchCode: String!
  hashedLaunchCode: String
  userId: String
}

type PodcastEpisode {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  podcastId: String!
  podcast: Podcast!
  title: String!
  episodeLink: String!
  externalEpisodeId: String!
}

input SinglePodcastEpisodeInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SinglePodcastEpisodeOutput {
  result: PodcastEpisode
}

input PodcastEpisodeByExternalIdInput {
  externalEpisodeId: String
  _id: String
}

input PodcastEpisodeSelector {
  default: EmptyViewInput
  episodeByExternalId: PodcastEpisodeByExternalIdInput
}

input MultiPodcastEpisodeInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiPodcastEpisodeOutput {
  results: [PodcastEpisode!]!
  totalCount: Int
}

extend type Query {
  podcastEpisode(input: SinglePodcastEpisodeInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SinglePodcastEpisodeOutput
  podcastEpisodes(input: MultiPodcastEpisodeInput @deprecated(reason: "Use the selector field instead"), selector: PodcastEpisodeSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiPodcastEpisodeOutput
}

type Podcast {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  title: String!
  applePodcastLink: String
  spotifyPodcastLink: String
}

input SinglePodcastInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SinglePodcastOutput {
  result: Podcast
}

input PodcastSelector {
  default: EmptyViewInput
}

input MultiPodcastInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiPodcastOutput {
  results: [Podcast!]!
  totalCount: Int
}

extend type Query {
  podcast(input: SinglePodcastInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SinglePodcastOutput
  podcasts(input: MultiPodcastInput @deprecated(reason: "Use the selector field instead"), selector: PodcastSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiPodcastOutput
}

type PostRecommendation {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String
  user: User
  clientId: String
  postId: String
  post: Post
  strategyName: String
  strategySettings: JSON
  recommendationCount: Int
  lastRecommendedAt: Date
  clickedAt: Date
}

type PostRelation {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  type: String!
  sourcePostId: String!
  sourcePost: Post
  targetPostId: String!
  targetPost: Post
  order: Float
}

input SinglePostRelationInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SinglePostRelationOutput {
  result: PostRelation
}

input PostRelationsAllPostRelationsInput {
  postId: String
}

input PostRelationSelector {
  default: EmptyViewInput
  allPostRelations: PostRelationsAllPostRelationsInput
}

input MultiPostRelationInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiPostRelationOutput {
  results: [PostRelation!]!
  totalCount: Int
}

extend type Query {
  postRelation(input: SinglePostRelationInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SinglePostRelationOutput
  postRelations(input: MultiPostRelationInput @deprecated(reason: "Use the selector field instead"), selector: PostRelationSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiPostRelationOutput
}

type Post {
  _id: String!
  schemaVersion: Float!
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  revisions(limit: Int = 5): [Revision!]
  version: String
  pingbacks: JSON
  moderationGuidelines(version: String): Revision
  moderationGuidelines_latest: String
  customHighlight(version: String): Revision
  customHighlight_latest: String
  slug: String!
  postedAt: Date!
  modifiedAt: Date
  url: String
  postCategory: PostCategory!
  title: String!
  viewCount: Float
  lastCommentedAt: Date!
  clickCount: Float
  deletedDraft: Boolean!
  status: Float!
  isFuture: Boolean!
  sticky: Boolean!
  stickyPriority: Int!
  userIP: String
  userAgent: String
  referrer: String
  author: String
  userId: String
  user: User
  domain: String
  pageUrl: String!
  pageUrlRelative: String
  linkUrl: String
  postedAtFormatted: String
  emailShareUrl: String
  twitterShareUrl: String
  facebookShareUrl: String
  socialPreviewImageUrl: String
  question: Boolean!
  authorIsUnreviewed: Boolean!
  readTimeMinutesOverride: Float
  readTimeMinutes: Int!
  wordCount: Int
  htmlBody: String
  submitToFrontpage: Boolean!
  hiddenRelatedQuestion: Boolean!
  originalPostRelationSourceId: String
  sourcePostRelations: [PostRelation!]!
  targetPostRelations: [PostRelation!]!
  shortform: Boolean!
  canonicalSource: String
  nominationCount2018: Float!
  nominationCount2019: Float!
  reviewCount2018: Float!
  reviewCount2019: Float!
  reviewCount: Float!
  reviewVoteCount: Float!
  positiveReviewVoteCount: Float!
  manifoldReviewMarketId: String
  annualReviewMarketProbability: Float
  annualReviewMarketIsResolved: Boolean
  annualReviewMarketYear: Int
  annualReviewMarketUrl: String
  glossary: [JargonTerm!]!
  reviewVoteScoreAF: Float!
  reviewVotesAF: [Float!]!
  reviewVoteScoreHighKarma: Float!
  reviewVotesHighKarma: [Float!]!
  reviewVoteScoreAllKarma: Float!
  reviewVotesAllKarma: [Float!]!
  finalReviewVoteScoreHighKarma: Float!
  finalReviewVotesHighKarma: [Float!]!
  finalReviewVoteScoreAllKarma: Float!
  finalReviewVotesAllKarma: [Float!]!
  finalReviewVoteScoreAF: Float!
  finalReviewVotesAF: [Float!]!
  lastCommentPromotedAt: Date
  tagRel(tagId: String): TagRel
  tags: [Tag!]!
  tagRelevance: JSON
  lastPromotedComment: Comment
  bestAnswer: Comment
  noIndex: Boolean!
  rsvps: [JSON!]
  rsvpCounts: JSON!
  activateRSVPs: Boolean
  nextDayReminderSent: Boolean!
  onlyVisibleToLoggedIn: Boolean!
  onlyVisibleToEstablishedAccounts: Boolean!
  hideFromRecentDiscussions: Boolean!
  currentUserReviewVote: ReviewVote
  reviewWinner: ReviewWinner
  spotlight: Spotlight
  votingSystem: String
  myEditorAccess: String!
  podcastEpisodeId: String
  podcastEpisode: PodcastEpisode
  forceAllowType3Audio: Boolean!
  legacy: Boolean!
  legacyId: String
  legacySpam: Boolean!
  feedId: String
  feed: RSSFeed
  feedLink: String
  lastVisitedAt: Date
  isRead: Boolean
  curatedDate: Date
  metaDate: Date
  suggestForCuratedUserIds: [String!]
  suggestForCuratedUsernames: String
  frontpageDate: Date
  autoFrontpage: String
  collectionTitle: String
  coauthorStatuses: [CoauthorStatusOutput!]
  coauthors: [User!]
  hasCoauthorPermission: Boolean!
  socialPreviewImageId: String
  socialPreviewImageAutoUrl: String
  socialPreview: SocialPreviewOutput
  socialPreviewData: SocialPreviewType!
  fmCrosspost: CrosspostOutput
  canonicalSequenceId: String
  canonicalSequence: Sequence
  canonicalCollectionSlug: String
  canonicalCollection: Collection
  canonicalBookId: String
  canonicalBook: Book
  canonicalNextPostSlug: String
  canonicalPrevPostSlug: String
  nextPost(sequenceId: String): Post
  prevPost(sequenceId: String): Post
  sequence(sequenceId: String, prevOrNext: String): Sequence
  unlisted: Boolean!
  disableRecommendation: Boolean!
  defaultRecommendation: Boolean!
  hideFromPopularComments: Boolean
  draft: Boolean
  wasEverUndrafted: Boolean
  meta: Boolean!
  hideFrontpageComments: Boolean!
  maxBaseScore: Float!
  scoreExceeded2Date: Date
  scoreExceeded30Date: Date
  scoreExceeded45Date: Date
  scoreExceeded75Date: Date
  scoreExceeded125Date: Date
  scoreExceeded200Date: Date
  bannedUserIds: [String!]
  commentsLocked: Boolean
  commentsLockedToAccountsCreatedAfter: Date
  organizerIds: [String!]
  organizers: [User!]
  groupId: String
  group: Localgroup
  eventType: String
  isEvent: Boolean!
  reviewedByUserId: String
  reviewedByUser: User
  reviewForCuratedUserId: String
  startTime: Date
  localStartTime: Date
  endTime: Date
  localEndTime: Date
  eventRegistrationLink: String
  joinEventLink: String
  onlineEvent: Boolean!
  globalEvent: Boolean!
  mongoLocation: JSON
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  meetupLink: String
  website: String
  eventImageId: String
  types: [String!]
  metaSticky: Boolean!
  sharingSettings: JSON
  shareWithUsers: [String!]
  usersSharedWith: [User!]
  linkSharingKey: String
  linkSharingKeyUsedBy: [String!]
  commentSortOrder: String
  hideAuthor: Boolean!
  tableOfContents: JSON
  tableOfContentsRevision(version: String): JSON
  sideComments: JSON
  sideCommentsCache: SideCommentCache
  sideCommentVisibility: String
  disableSidenotes: Boolean!
  moderationStyle: String
  ignoreRateLimits: Boolean
  hideCommentKarma: Boolean!
  commentCount: Float!
  topLevelCommentCount: Float!
  recentComments(commentsLimit: Int, maxAgeHours: Int, af: Boolean): [Comment!]
  languageModelSummary: String
  debate: Boolean!
  collabEditorDialogue: Boolean!
  totalDialogueResponseCount: Int!
  mostRecentPublishedDialogueResponseDate: Date
  unreadDebateResponseCount: Int!
  emojiReactors: JSON
  commentEmojiReactors: JSON
  rejected: Boolean!
  rejectedReason: String
  rejectedByUserId: String
  rejectedByUser: User
  dialogTooltipPreview: String
  dialogueMessageContents(dialogueMessageId: String): String
  firstVideoAttribsForPreview: JSON
  subforumTagId: String
  subforumTag: Tag
  af: Boolean!
  afDate: Date
  afCommentCount: Float!
  afLastCommentedAt: Date
  afSticky: Boolean!
  suggestForAlignmentUserIds: [String!]!
  suggestForAlignmentUsers: [User!]!
  reviewForAlignmentUserId: String
  agentFoundationsId: String
  swrCachingEnabled: Boolean
  generateDraftJargon: Boolean
  curationNotices: [CurationNotice!]
  reviews: [Comment!]
  automatedContentEvaluations: AutomatedContentEvaluation
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float!
  baseScore: Float!
  extendedScore: JSON
  score: Float!
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

enum PostCategory {
  post
  linkpost
  question
}

input SinglePostInput {
  selector: SelectorInput
  resolverArgs: JSON
  allowNull: Boolean
}

type SinglePostOutput {
  result: Post
}

input PostDefaultViewInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsUserPostsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsMagicInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  meta: Boolean
  forum: Boolean
  limit: Int
}

input PostsTopInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  meta: Boolean
  forum: Boolean
}

input PostsNewInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  meta: Boolean
  forum: Boolean
}

input PostsRecentCommentsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsOldInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsTimeframeInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  limit: Int
}

input PostsDailyInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsTagRelevanceInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  tagId: String
}

input PostsFrontpageInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsFrontpageRssInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsCuratedInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsCuratedRssInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsCommunityInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsCommunityRssInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsMetaRssInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsRssInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  meta: Boolean
  forum: Boolean
}

input PostsTopQuestionsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsRecentQuestionActivityInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsScheduledInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsRejectedInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsDraftsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  includeDraftEvents: Boolean
  includeArchived: Boolean
  includeShared: Boolean
  sortDraftsBy: String
}

input PostsAll_draftsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsUnlistedInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsUserAFSubmissionsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsSlugPostInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  slug: String
}

input PostsLegacyIdPostInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  legacyId: String
}

input PostsRecentDiscussionThreadsListInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  limit: String
}

input PostsAfRecentDiscussionThreadsListInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  limit: String
}

input PostsReviewRecentDiscussionThreadsList2018Input {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  limit: String
}

input PostsReviewRecentDiscussionThreadsList2019Input {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  limit: String
}

input PostsGlobalEventsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  onlineEvent: Boolean
  eventType: [String!]
  filters: [String!]
}

input PostsNearbyEventsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  onlineEvent: Boolean
  eventType: [String!]
  lng: Float
  lat: Float
  distance: Float
  filters: [String!]
}

input PostsEventsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  globalEvent: Boolean
  onlineEvent: Boolean
  filters: [String!]
}

input PostsEventsInTimeRangeInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsUpcomingEventsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsPastEventsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsTbdEventsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsNonEventGroupPostsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsPostsWithBannedUsersInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsCommunityResourcePostsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsSunshineNewPostsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsSunshineNewUsersPostsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsSunshineCuratedSuggestionsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  audioOnly: Boolean
}

input PostsHasEverDialoguedInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsPingbackPostsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  postId: String
}

input PostsNominations2018Input {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  sortByMost: Boolean
}

input PostsNominations2019Input {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  sortByMost: Boolean
}

input PostsReviews2018Input {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  sortBy: String
}

input PostsReviews2019Input {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  sortBy: String
}

input PostsVoting2019Input {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  sortBy: String
}

input PostsStickiedInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  forum: Boolean
}

input PostsNominatablePostsByVoteInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  requiredUnnominated: Boolean
  requiredFrontpage: Boolean
}

input PostsReviewVotingInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  reviewPhase: String
}

input PostsFrontpageReviewWidgetInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  reviewYear: Int
  reviewPhase: String
}

input PostsReviewQuickPageInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsReviewFinalVotingInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsMyBookmarkedPostsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
  limit: String
}

input PostsAlignmentSuggestedPostsInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostsCurrentOpenThreadInput {
  postIds: [String!]
  notPostIds: [String!]
  groupId: String
  af: Boolean
  question: Boolean
  authorIsUnreviewed: Boolean
  exactPostIds: [String!]
  hideCommunity: Boolean
  karmaThreshold: Int
  excludeEvents: Boolean
  userId: String
  includeRelatedQuestions: String
  filter: String
  view: String
  filterSettings: JSON
  sortedBy: String
  after: String
  before: String
  timeField: String
  curatedAfter: String
}

input PostSelector {
  default: PostDefaultViewInput
  userPosts: PostsUserPostsInput
  magic: PostsMagicInput
  top: PostsTopInput
  new: PostsNewInput
  recentComments: PostsRecentCommentsInput
  old: PostsOldInput
  timeframe: PostsTimeframeInput
  daily: PostsDailyInput
  tagRelevance: PostsTagRelevanceInput
  frontpage: PostsFrontpageInput
  frontpageRss: PostsFrontpageRssInput
  curated: PostsCuratedInput
  curatedRss: PostsCuratedRssInput
  community: PostsCommunityInput
  communityRss: PostsCommunityRssInput
  metaRss: PostsMetaRssInput
  rss: PostsRssInput
  topQuestions: PostsTopQuestionsInput
  recentQuestionActivity: PostsRecentQuestionActivityInput
  scheduled: PostsScheduledInput
  rejected: PostsRejectedInput
  drafts: PostsDraftsInput
  all_drafts: PostsAll_draftsInput
  unlisted: PostsUnlistedInput
  userAFSubmissions: PostsUserAFSubmissionsInput
  slugPost: PostsSlugPostInput
  legacyIdPost: PostsLegacyIdPostInput
  recentDiscussionThreadsList: PostsRecentDiscussionThreadsListInput
  afRecentDiscussionThreadsList: PostsAfRecentDiscussionThreadsListInput
  reviewRecentDiscussionThreadsList2018: PostsReviewRecentDiscussionThreadsList2018Input
  reviewRecentDiscussionThreadsList2019: PostsReviewRecentDiscussionThreadsList2019Input
  globalEvents: PostsGlobalEventsInput
  nearbyEvents: PostsNearbyEventsInput
  events: PostsEventsInput
  eventsInTimeRange: PostsEventsInTimeRangeInput
  upcomingEvents: PostsUpcomingEventsInput
  pastEvents: PostsPastEventsInput
  tbdEvents: PostsTbdEventsInput
  nonEventGroupPosts: PostsNonEventGroupPostsInput
  postsWithBannedUsers: PostsPostsWithBannedUsersInput
  communityResourcePosts: PostsCommunityResourcePostsInput
  sunshineNewPosts: PostsSunshineNewPostsInput
  sunshineNewUsersPosts: PostsSunshineNewUsersPostsInput
  sunshineCuratedSuggestions: PostsSunshineCuratedSuggestionsInput
  hasEverDialogued: PostsHasEverDialoguedInput
  pingbackPosts: PostsPingbackPostsInput
  nominations2018: PostsNominations2018Input
  nominations2019: PostsNominations2019Input
  reviews2018: PostsReviews2018Input
  reviews2019: PostsReviews2019Input
  voting2019: PostsVoting2019Input
  stickied: PostsStickiedInput
  nominatablePostsByVote: PostsNominatablePostsByVoteInput
  reviewVoting: PostsReviewVotingInput
  frontpageReviewWidget: PostsFrontpageReviewWidgetInput
  reviewQuickPage: PostsReviewQuickPageInput
  reviewFinalVoting: PostsReviewFinalVotingInput
  myBookmarkedPosts: PostsMyBookmarkedPostsInput
  alignmentSuggestedPosts: PostsAlignmentSuggestedPostsInput
  currentOpenThread: PostsCurrentOpenThreadInput
}

input MultiPostInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiPostOutput {
  results: [Post!]!
  totalCount: Int
}

extend type Query {
  post(input: SinglePostInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput, allowNull: Boolean): SinglePostOutput
  posts(input: MultiPostInput @deprecated(reason: "Use the selector field instead"), selector: PostSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiPostOutput
}

type RSSFeed {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String!
  user: User
  ownedByUser: Boolean!
  displayFullContent: Boolean!
  nickname: String!
  url: String!
  status: String
  rawFeed: JSON
  setCanonicalUrl: Boolean!
  importAsDraft: Boolean!
}

input SingleRSSFeedInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleRSSFeedOutput {
  result: RSSFeed
}

input RSSFeedsUsersFeedInput {
  userId: String
}

input RSSFeedSelector {
  default: EmptyViewInput
  usersFeed: RSSFeedsUsersFeedInput
}

input MultiRSSFeedInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiRSSFeedOutput {
  results: [RSSFeed!]!
  totalCount: Int
}

extend type Query {
  rSSFeed(input: SingleRSSFeedInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleRSSFeedOutput
  rSSFeeds(input: MultiRSSFeedInput @deprecated(reason: "Use the selector field instead"), selector: RSSFeedSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiRSSFeedOutput
}

type ReadStatus {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
}

type RecommendationsCache {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String
  postId: String
  source: String
  scenario: String
  attributionId: String
  ttlMs: Float
}

type Report {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String!
  user: User
  reportedUserId: String
  reportedUser: User
  commentId: String
  comment: Comment
  postId: String
  post: Post
  link: String!
  claimedUserId: String
  claimedUser: User
  description: String
  closedAt: Date
  markedAsSpam: Boolean
  reportedAsSpam: Boolean
}

input SingleReportInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleReportOutput {
  result: Report
}

input ReportsAdminClaimedReportsInput {
  userId: String
}

input ReportSelector {
  default: EmptyViewInput
  allReports: EmptyViewInput
  unclaimedReports: EmptyViewInput
  claimedReports: EmptyViewInput
  adminClaimedReports: ReportsAdminClaimedReportsInput
  sunshineSidebarReports: EmptyViewInput
  closedReports: EmptyViewInput
}

input MultiReportInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiReportOutput {
  results: [Report!]!
  totalCount: Int
}

extend type Query {
  report(input: SingleReportInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleReportOutput
  reports(input: MultiReportInput @deprecated(reason: "Use the selector field instead"), selector: ReportSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiReportOutput
}

type ReviewVote {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String!
  user: User
  postId: String!
  post: Post
  qualitativeScore: Int!
  quadraticScore: Int!
  comment: String
  year: String!
  dummy: Boolean!
  reactions: [String!]
}

input SingleReviewVoteInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleReviewVoteOutput {
  result: ReviewVote
}

input ReviewVotesReviewVotesFromUserInput {
  userId: String
  year: String
}

input ReviewVotesReviewVotesAdminDashboardInput {
  year: Int
}

input ReviewVoteSelector {
  default: EmptyViewInput
  reviewVotesFromUser: ReviewVotesReviewVotesFromUserInput
  reviewVotesForPost: EmptyViewInput
  reviewVotesForPostAndUser: EmptyViewInput
  reviewVotesAdminDashboard: ReviewVotesReviewVotesAdminDashboardInput
}

input MultiReviewVoteInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiReviewVoteOutput {
  results: [ReviewVote!]!
  totalCount: Int
}

extend type Query {
  reviewVote(input: SingleReviewVoteInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleReviewVoteOutput
  reviewVotes(input: MultiReviewVoteInput @deprecated(reason: "Use the selector field instead"), selector: ReviewVoteSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiReviewVoteOutput
}

type ReviewWinnerArt {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  postId: String!
  splashArtImagePrompt: String!
  splashArtImageUrl: String!
  activeSplashArtCoordinates: SplashArtCoordinate
}

input SingleReviewWinnerArtInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleReviewWinnerArtOutput {
  result: ReviewWinnerArt
}

input ReviewWinnerArtsPostArtInput {
  postId: String
}

input ReviewWinnerArtsAllForYearInput {
  year: Int
}

input ReviewWinnerArtSelector {
  default: EmptyViewInput
  postArt: ReviewWinnerArtsPostArtInput
  allForYear: ReviewWinnerArtsAllForYearInput
}

input MultiReviewWinnerArtInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiReviewWinnerArtOutput {
  results: [ReviewWinnerArt!]!
  totalCount: Int
}

extend type Query {
  reviewWinnerArt(input: SingleReviewWinnerArtInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleReviewWinnerArtOutput
  reviewWinnerArts(input: MultiReviewWinnerArtInput @deprecated(reason: "Use the selector field instead"), selector: ReviewWinnerArtSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiReviewWinnerArtOutput
}

type ReviewWinner {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  postId: String!
  post: Post
  reviewWinnerArt: ReviewWinnerArt
  competitorCount: Int
  reviewYear: Float!
  category: String!
  curatedOrder: Float
  reviewRanking: Float!
  isAI: Boolean
}

input SingleReviewWinnerInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleReviewWinnerOutput {
  result: ReviewWinner
}

input ReviewWinnersReviewWinnerSingleInput {
  category: String
  reviewYear: String
  reviewRanking: String
}

input ReviewWinnerSelector {
  default: EmptyViewInput
  reviewWinnerSingle: ReviewWinnersReviewWinnerSingleInput
  bestOfLessWrongAnnouncement: EmptyViewInput
}

input MultiReviewWinnerInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiReviewWinnerOutput {
  results: [ReviewWinner!]!
  totalCount: Int
}

extend type Query {
  reviewWinner(input: SingleReviewWinnerInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleReviewWinnerOutput
  reviewWinners(input: MultiReviewWinnerInput @deprecated(reason: "Use the selector field instead"), selector: ReviewWinnerSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiReviewWinnerOutput
}

type Revision {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  documentId: String
  collectionName: String
  fieldName: String
  editedAt: Date!
  updateType: String
  version: String!
  commitMessage: String
  userId: String
  user: User
  draft: Boolean
  originalContents: ContentType!
  html: String
  markdown: String
  ckEditorMarkup: String
  wordCount: Float!
  htmlHighlight: String!
  htmlHighlightStartingAtHash(hash: String): String!
  plaintextDescription: String!
  plaintextMainText: String!
  hasFootnotes: Boolean
  changeMetrics: JSON!
  googleDocMetadata: JSON
  skipAttributions: Boolean!
  tag: Tag
  post: Post
  lens: MultiDocument
  summary: MultiDocument
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float!
  baseScore: Float!
  extendedScore: JSON
  score: Float!
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input SingleRevisionInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleRevisionOutput {
  result: Revision
}

input RevisionsRevisionsByUserInput {
  userId: String
}

input RevisionsRevisionsOnDocumentInput {
  documentId: String
  fieldName: String
  before: String
  after: String
}

input RevisionsRevisionByVersionNumberInput {
  documentId: String
  version: String
  fieldName: String
}

input RevisionSelector {
  default: EmptyViewInput
  revisionsByUser: RevisionsRevisionsByUserInput
  revisionsOnDocument: RevisionsRevisionsOnDocumentInput
  revisionByVersionNumber: RevisionsRevisionByVersionNumberInput
}

input MultiRevisionInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiRevisionOutput {
  results: [Revision!]!
  totalCount: Int
}

extend type Query {
  revision(input: SingleRevisionInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleRevisionOutput
  revisions(input: MultiRevisionInput @deprecated(reason: "Use the selector field instead"), selector: RevisionSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiRevisionOutput
}

type Sequence {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  lastUpdated: Date!
  userId: String!
  user: User
  title: String!
  bannerImageId: String
  gridImageId: String
  hideFromAuthorPage: Boolean!
  draft: Boolean!
  isDeleted: Boolean!
  curatedOrder: Float
  userProfileOrder: Float
  canonicalCollectionSlug: String
  canonicalCollection: Collection
  hidden: Boolean!
  noindex: Boolean!
  postsCount: Int!
  readPostsCount: Int!
  chapters: [Chapter!]!
  af: Boolean!
}

input SingleSequenceInput {
  selector: SelectorInput
  resolverArgs: JSON
  allowNull: Boolean
}

type SingleSequenceOutput {
  result: Sequence
}

input SequenceDefaultViewInput {
  sequenceIds: [String!]
}

input SequencesUserProfileInput {
  sequenceIds: [String!]
  userId: String
}

input SequencesUserProfilePrivateInput {
  sequenceIds: [String!]
  userId: String
}

input SequencesUserProfileAllInput {
  sequenceIds: [String!]
  userId: String
}

input SequencesCuratedSequencesInput {
  sequenceIds: [String!]
  userId: String
}

input SequencesCommunitySequencesInput {
  sequenceIds: [String!]
  userId: String
}

input SequenceSelector {
  default: SequenceDefaultViewInput
  userProfile: SequencesUserProfileInput
  userProfilePrivate: SequencesUserProfilePrivateInput
  userProfileAll: SequencesUserProfileAllInput
  curatedSequences: SequencesCuratedSequencesInput
  communitySequences: SequencesCommunitySequencesInput
}

input MultiSequenceInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiSequenceOutput {
  results: [Sequence!]!
  totalCount: Int
}

extend type Query {
  sequence(input: SingleSequenceInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput, allowNull: Boolean): SingleSequenceOutput
  sequences(input: MultiSequenceInput @deprecated(reason: "Use the selector field instead"), selector: SequenceSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiSequenceOutput
}

type Session {
  _id: String
  session: JSON
  expires: Date
  lastModified: Date
}

type SideCommentCache {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  postId: String
  annotatedHtml: String
  commentsByBlock: JSON
  version: Float
}

type SplashArtCoordinate {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  reviewWinnerArtId: String
  reviewWinnerArt: ReviewWinnerArt
  leftXPct: Float!
  leftYPct: Float!
  leftHeightPct: Float!
  leftWidthPct: Float!
  leftFlipped: Boolean!
  middleXPct: Float!
  middleYPct: Float!
  middleHeightPct: Float!
  middleWidthPct: Float!
  middleFlipped: Boolean!
  rightXPct: Float!
  rightYPct: Float!
  rightHeightPct: Float!
  rightWidthPct: Float!
  rightFlipped: Boolean!
}

input SingleSplashArtCoordinateInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleSplashArtCoordinateOutput {
  result: SplashArtCoordinate
}

input SplashArtCoordinateSelector {
  default: EmptyViewInput
}

input MultiSplashArtCoordinateInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiSplashArtCoordinateOutput {
  results: [SplashArtCoordinate!]!
  totalCount: Int
}

extend type Query {
  splashArtCoordinate(input: SingleSplashArtCoordinateInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleSplashArtCoordinateOutput
  splashArtCoordinates(input: MultiSplashArtCoordinateInput @deprecated(reason: "Use the selector field instead"), selector: SplashArtCoordinateSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiSplashArtCoordinateOutput
}

type Spotlight {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  description(version: String): Revision
  description_latest: String
  documentId: String!
  document: Post
  post: Post
  sequence: Sequence
  tag: Tag
  documentType: SpotlightDocumentType!
  position: Float!
  duration: Float!
  customTitle: String
  customSubtitle: String
  subtitleUrl: String
  headerTitle: String
  headerTitleLeftColor: String
  headerTitleRightColor: String
  lastPromotedAt: Date!
  spotlightSplashImageUrl: String
  draft: Boolean!
  deletedDraft: Boolean!
  showAuthor: Boolean!
  imageFade: Boolean!
  imageFadeColor: String
  spotlightImageId: String
  spotlightDarkImageId: String
  sequenceChapters: [Chapter!]
}

enum SpotlightDocumentType {
  Post
  Sequence
  Tag
}

input SingleSpotlightInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleSpotlightOutput {
  result: Spotlight
}

input SpotlightsMostRecentlyPromotedSpotlightsInput {
  limit: Int
}

input SpotlightsSpotlightsPageInput {
  limit: Int
}

input SpotlightsSpotlightsPageDraftInput {
  limit: Int
}

input SpotlightsSpotlightsByDocumentIdsInput {
  documentIds: String
}

input SpotlightsSpotlightsByIdInput {
  spotlightIds: String
}

input SpotlightSelector {
  default: EmptyViewInput
  mostRecentlyPromotedSpotlights: SpotlightsMostRecentlyPromotedSpotlightsInput
  spotlightsPage: SpotlightsSpotlightsPageInput
  spotlightsPageDraft: SpotlightsSpotlightsPageDraftInput
  spotlightsByDocumentIds: SpotlightsSpotlightsByDocumentIdsInput
  spotlightsById: SpotlightsSpotlightsByIdInput
}

input MultiSpotlightInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiSpotlightOutput {
  results: [Spotlight!]!
  totalCount: Int
}

extend type Query {
  spotlight(input: SingleSpotlightInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleSpotlightOutput
  spotlights(input: MultiSpotlightInput @deprecated(reason: "Use the selector field instead"), selector: SpotlightSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiSpotlightOutput
}

type Subscription {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String
  user: User
  state: String
  documentId: String
  collectionName: String
  deleted: Boolean
  type: String
}

input SingleSubscriptionInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleSubscriptionOutput {
  result: Subscription
}

input SubscriptionsSubscriptionStateInput {
  documentId: String
  userId: String
  type: String
  collectionName: String
}

input SubscriptionsSubscriptionsOfTypeInput {
  userId: String
  collectionName: String
  subscriptionType: String
}

input SubscriptionsMembersOfGroupInput {
  documentId: String
}

input SubscriptionSelector {
  default: EmptyViewInput
  subscriptionState: SubscriptionsSubscriptionStateInput
  subscriptionsOfType: SubscriptionsSubscriptionsOfTypeInput
  membersOfGroup: SubscriptionsMembersOfGroupInput
}

input MultiSubscriptionInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiSubscriptionOutput {
  results: [Subscription!]!
  totalCount: Int
}

extend type Query {
  subscription(input: SingleSubscriptionInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleSubscriptionOutput
  subscriptions(input: MultiSubscriptionInput @deprecated(reason: "Use the selector field instead"), selector: SubscriptionSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiSubscriptionOutput
}

type SurveyQuestion {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  surveyId: String!
  survey: Survey!
  question: String!
  format: SurveyQuestionFormat!
  order: Float!
}

enum SurveyQuestionFormat {
  rank0To10
  text
  multilineText
}

input SingleSurveyQuestionInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleSurveyQuestionOutput {
  result: SurveyQuestion
}

input SurveyQuestionSelector {
  default: EmptyViewInput
}

input MultiSurveyQuestionInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiSurveyQuestionOutput {
  results: [SurveyQuestion!]!
  totalCount: Int
}

extend type Query {
  surveyQuestion(input: SingleSurveyQuestionInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleSurveyQuestionOutput
  surveyQuestions(input: MultiSurveyQuestionInput @deprecated(reason: "Use the selector field instead"), selector: SurveyQuestionSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiSurveyQuestionOutput
}

type SurveyResponse {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  surveyId: String
  survey: Survey
  surveyScheduleId: String
  surveySchedule: SurveySchedule
  userId: String
  user: User
  clientId: String
  client: ClientId
  response: JSON
}

input SingleSurveyResponseInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleSurveyResponseOutput {
  result: SurveyResponse
}

input SurveyResponseSelector {
  default: EmptyViewInput
}

input MultiSurveyResponseInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiSurveyResponseOutput {
  results: [SurveyResponse!]!
  totalCount: Int
}

extend type Query {
  surveyResponse(input: SingleSurveyResponseInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleSurveyResponseOutput
  surveyResponses(input: MultiSurveyResponseInput @deprecated(reason: "Use the selector field instead"), selector: SurveyResponseSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiSurveyResponseOutput
}

type SurveySchedule {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  surveyId: String!
  survey: Survey
  name: String
  impressionsLimit: Float
  maxVisitorPercentage: Float
  minKarma: Float
  maxKarma: Float
  target: SurveyScheduleTarget
  startDate: Date
  endDate: Date
  deactivated: Boolean
  clientIds: [String!]
  clients: [ClientId!]
}

enum SurveyScheduleTarget {
  allUsers
  loggedInOnly
  loggedOutOnly
}

input SingleSurveyScheduleInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleSurveyScheduleOutput {
  result: SurveySchedule
}

input SurveyScheduleSelector {
  default: EmptyViewInput
  surveySchedulesByCreatedAt: EmptyViewInput
}

input MultiSurveyScheduleInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiSurveyScheduleOutput {
  results: [SurveySchedule!]!
  totalCount: Int
}

extend type Query {
  surveySchedule(input: SingleSurveyScheduleInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleSurveyScheduleOutput
  surveySchedules(input: MultiSurveyScheduleInput @deprecated(reason: "Use the selector field instead"), selector: SurveyScheduleSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiSurveyScheduleOutput
}

type Survey {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  name: String!
  questions: [SurveyQuestion!]!
}

input SingleSurveyInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleSurveyOutput {
  result: Survey
}

input SurveySelector {
  default: EmptyViewInput
  surveysByCreatedAt: EmptyViewInput
}

input MultiSurveyInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiSurveyOutput {
  results: [Survey!]!
  totalCount: Int
}

extend type Query {
  survey(input: SingleSurveyInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleSurveyOutput
  surveys(input: MultiSurveyInput @deprecated(reason: "Use the selector field instead"), selector: SurveySelector, limit: Int, offset: Int, enableTotal: Boolean): MultiSurveyOutput
}

type TagFlag {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  slug: String!
  name: String!
  deleted: Boolean!
  order: Float
}

input SingleTagFlagInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleTagFlagOutput {
  result: TagFlag
}

input TagFlagSelector {
  default: EmptyViewInput
  allTagFlags: EmptyViewInput
}

input MultiTagFlagInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiTagFlagOutput {
  results: [TagFlag!]!
  totalCount: Int
}

extend type Query {
  tagFlag(input: SingleTagFlagInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleTagFlagOutput
  tagFlags(input: MultiTagFlagInput @deprecated(reason: "Use the selector field instead"), selector: TagFlagSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiTagFlagOutput
}

type TagRel {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  tagId: String!
  tag: Tag
  postId: String!
  post: Post
  deleted: Boolean!
  userId: String
  user: User
  currentUserCanVote: Boolean!
  autoApplied: Boolean!
  backfilled: Boolean!
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float!
  baseScore: Float!
  extendedScore: JSON
  score: Float!
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input SingleTagRelInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleTagRelOutput {
  result: TagRel
}

input TagRelsPostsWithTagInput {
  tagId: String
}

input TagRelsTagsOnPostInput {
  postId: String
}

input TagRelSelector {
  default: EmptyViewInput
  postsWithTag: TagRelsPostsWithTagInput
  tagsOnPost: TagRelsTagsOnPostInput
}

input MultiTagRelInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiTagRelOutput {
  results: [TagRel!]!
  totalCount: Int
}

extend type Query {
  tagRel(input: SingleTagRelInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleTagRelOutput
  tagRels(input: MultiTagRelInput @deprecated(reason: "Use the selector field instead"), selector: TagRelSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiTagRelOutput
}

type Tag {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  description(version: String): Revision
  description_latest: String
  pingbacks: JSON
  subforumWelcomeText(version: String): Revision
  subforumWelcomeText_latest: String
  moderationGuidelines(version: String): Revision
  moderationGuidelines_latest: String
  slug: String!
  oldSlugs: [String!]!
  name: String!
  shortName: String
  subtitle: String
  core: Boolean!
  isPostType: Boolean!
  suggestedAsFilter: Boolean!
  defaultOrder: Float!
  descriptionTruncationCount: Float!
  postCount: Float!
  userId: String
  user: User
  adminOnly: Boolean!
  canEditUserIds: [String!]
  charsAdded: Float
  charsRemoved: Float
  deleted: Boolean!
  lastCommentedAt: Date
  lastSubforumCommentAt: Date
  needsReview: Boolean!
  reviewedByUserId: String
  reviewedByUser: User
  wikiGrade: Int!
  recentComments(tagCommentsLimit: Int, maxAgeHours: Int, af: Boolean, tagCommentType: String): [Comment!]!
  wikiOnly: Boolean!
  bannerImageId: String
  squareImageId: String
  tagFlagsIds: [String!]!
  tagFlags: [TagFlag!]!
  lesswrongWikiImportRevision: String
  lesswrongWikiImportSlug: String
  lesswrongWikiImportCompleted: Boolean
  lastVisitedAt: Date
  isRead: Boolean
  tableOfContents(version: String): JSON
  htmlWithContributorAnnotations: String
  contributors(limit: Int, version: String): TagContributorsList!
  contributionStats: JSON
  introSequenceId: String
  sequence: Sequence
  postsDefaultSortOrder: String
  canVoteOnRels: [TagRelVoteGroup!]
  isSubforum: Boolean!
  subforumUnreadMessagesCount: Int
  subforumModeratorIds: [String!]!
  subforumModerators: [User!]!
  subforumIntroPostId: String
  subforumIntroPost: Post
  parentTagId: String
  parentTag: Tag
  subTagIds: [String!]!
  subTags: [Tag!]!
  autoTagModel: String
  autoTagPrompt: String
  noindex: Boolean!
  lenses(lensSlug: String, version: String): [MultiDocument!]!
  lensesIncludingDeleted(lensSlug: String, version: String): [MultiDocument!]!
  isPlaceholderPage: Boolean!
  summaries: [MultiDocument!]!
  textLastUpdatedAt: Date
  isArbitalImport: Boolean
  arbitalLinkedPages: ArbitalLinkedPages
  coreTagId: String
  maxScore: Int
  usersWhoLiked: [UserLikingTag!]!
  forceAllowType3Audio: Boolean!
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float!
  baseScore: Float!
  extendedScore: JSON
  score: Float!
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input SingleTagInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleTagOutput {
  result: Tag
}

input TagDefaultViewInput {
  excludedTagIds: [String!]
}

input TagsTagsByTagIdsInput {
  excludedTagIds: [String!]
  tagIds: [String!]!
}

input TagsAllTagsAlphabeticalInput {
  excludedTagIds: [String!]
}

input TagsUserTagsInput {
  excludedTagIds: [String!]
  userId: String
}

input TagsCurrentUserSubforumsInput {
  excludedTagIds: [String!]
}

input TagsAllPagesByNewestInput {
  excludedTagIds: [String!]
}

input TagsAllTagsHierarchicalInput {
  excludedTagIds: [String!]
  wikiGrade: String
}

input TagsTagBySlugInput {
  excludedTagIds: [String!]
  slug: String
}

input TagsTagsBySlugsInput {
  excludedTagIds: [String!]
  slugs: [String!]!
}

input TagsCoreTagsInput {
  excludedTagIds: [String!]
}

input TagsPostTypeTagsInput {
  excludedTagIds: [String!]
}

input TagsCoreAndSubforumTagsInput {
  excludedTagIds: [String!]
}

input TagsNewTagsInput {
  excludedTagIds: [String!]
}

input TagsUnreviewedTagsInput {
  excludedTagIds: [String!]
}

input TagsSuggestedFilterTagsInput {
  excludedTagIds: [String!]
}

input TagsAllLWWikiTagsInput {
  excludedTagIds: [String!]
}

input TagsUnprocessedLWWikiTagsInput {
  excludedTagIds: [String!]
}

input TagsTagsByTagFlagInput {
  excludedTagIds: [String!]
  tagFlagId: String
}

input TagsAllPublicTagsInput {
  excludedTagIds: [String!]
}

input TagsAllArbitalTagsInput {
  excludedTagIds: [String!]
}

input TagsPingbackWikiPagesInput {
  excludedTagIds: [String!]
  tagId: String
}

input TagSelector {
  default: TagDefaultViewInput
  tagsByTagIds: TagsTagsByTagIdsInput
  allTagsAlphabetical: TagsAllTagsAlphabeticalInput
  userTags: TagsUserTagsInput
  currentUserSubforums: TagsCurrentUserSubforumsInput
  allPagesByNewest: TagsAllPagesByNewestInput
  allTagsHierarchical: TagsAllTagsHierarchicalInput
  tagBySlug: TagsTagBySlugInput
  tagsBySlugs: TagsTagsBySlugsInput
  coreTags: TagsCoreTagsInput
  postTypeTags: TagsPostTypeTagsInput
  coreAndSubforumTags: TagsCoreAndSubforumTagsInput
  newTags: TagsNewTagsInput
  unreviewedTags: TagsUnreviewedTagsInput
  suggestedFilterTags: TagsSuggestedFilterTagsInput
  allLWWikiTags: TagsAllLWWikiTagsInput
  unprocessedLWWikiTags: TagsUnprocessedLWWikiTagsInput
  tagsByTagFlag: TagsTagsByTagFlagInput
  allPublicTags: TagsAllPublicTagsInput
  allArbitalTags: TagsAllArbitalTagsInput
  pingbackWikiPages: TagsPingbackWikiPagesInput
}

input MultiTagInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiTagOutput {
  results: [Tag!]!
  totalCount: Int
}

extend type Query {
  tag(input: SingleTagInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleTagOutput
  tags(input: MultiTagInput @deprecated(reason: "Use the selector field instead"), selector: TagSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiTagOutput
}

type Tweet {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
}

type TypingIndicator {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String
  documentId: String
  lastUpdated: Date
}

input SingleTypingIndicatorInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleTypingIndicatorOutput {
  result: TypingIndicator
}

input TypingIndicatorSelector {
  default: EmptyViewInput
}

input MultiTypingIndicatorInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiTypingIndicatorOutput {
  results: [TypingIndicator!]!
  totalCount: Int
}

extend type Query {
  typingIndicator(input: SingleTypingIndicatorInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleTypingIndicatorOutput
  typingIndicators(input: MultiTypingIndicatorInput @deprecated(reason: "Use the selector field instead"), selector: TypingIndicatorSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiTypingIndicatorOutput
}

type UltraFeedEvent {
  _id: String!
  createdAt: Date!
  documentId: String
  collectionName: String
  eventType: String
  userId: String
  event: JSON
  feedItemId: String
}

input SingleUltraFeedEventInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleUltraFeedEventOutput {
  result: UltraFeedEvent
}

input UltraFeedEventSelector {
  default: EmptyViewInput
}

input MultiUltraFeedEventInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
}

type MultiUltraFeedEventOutput {
  results: [UltraFeedEvent!]!
  totalCount: Int
}

extend type Query {
  ultraFeedEvent(input: SingleUltraFeedEventInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleUltraFeedEventOutput
  ultraFeedEvents(input: MultiUltraFeedEventInput @deprecated(reason: "Use the selector field instead"), selector: UltraFeedEventSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiUltraFeedEventOutput
}

type UserActivity {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
}

type UserEAGDetail {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String
  user: User
  careerStage: [String!]
  countryOrRegion: String
  nearestCity: String
  willingnessToRelocate: JSON
  experiencedIn: [String!]
  interestedIn: [String!]
  lastUpdated: Date
}

input SingleUserEAGDetailInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleUserEAGDetailOutput {
  result: UserEAGDetail
}

input UserEAGDetailsDataByUserInput {
  userId: String
}

input UserEAGDetailSelector {
  default: EmptyViewInput
  dataByUser: UserEAGDetailsDataByUserInput
}

input MultiUserEAGDetailInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiUserEAGDetailOutput {
  results: [UserEAGDetail!]!
  totalCount: Int
}

extend type Query {
  userEAGDetail(input: SingleUserEAGDetailInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleUserEAGDetailOutput
  userEAGDetails(input: MultiUserEAGDetailInput @deprecated(reason: "Use the selector field instead"), selector: UserEAGDetailSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiUserEAGDetailOutput
}

type UserJobAd {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String
  user: User
  jobName: String
  adState: String
  reminderSetAt: Date
  lastUpdated: Date
}

input SingleUserJobAdInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleUserJobAdOutput {
  result: UserJobAd
}

input UserJobAdsAdsByUserInput {
  userId: String
}

input UserJobAdSelector {
  default: EmptyViewInput
  adsByUser: UserJobAdsAdsByUserInput
}

input MultiUserJobAdInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiUserJobAdOutput {
  results: [UserJobAd!]!
  totalCount: Int
}

extend type Query {
  userJobAd(input: SingleUserJobAdInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleUserJobAdOutput
  userJobAds(input: MultiUserJobAdInput @deprecated(reason: "Use the selector field instead"), selector: UserJobAdSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiUserJobAdOutput
}

type UserMostValuablePost {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String
  user: User
  postId: String
  post: Post
  deleted: Boolean
}

input SingleUserMostValuablePostInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleUserMostValuablePostOutput {
  result: UserMostValuablePost
}

input UserMostValuablePostsCurrentUserPostInput {
  postId: String
}

input UserMostValuablePostSelector {
  default: EmptyViewInput
  currentUserMostValuablePosts: EmptyViewInput
  currentUserPost: UserMostValuablePostsCurrentUserPostInput
}

input MultiUserMostValuablePostInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiUserMostValuablePostOutput {
  results: [UserMostValuablePost!]!
  totalCount: Int
}

extend type Query {
  userMostValuablePost(input: SingleUserMostValuablePostInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleUserMostValuablePostOutput
  userMostValuablePosts(input: MultiUserMostValuablePostInput @deprecated(reason: "Use the selector field instead"), selector: UserMostValuablePostSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiUserMostValuablePostOutput
}

type UserRateLimit {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  userId: String!
  user: User
  type: UserRateLimitType!
  intervalUnit: UserRateLimitIntervalUnit!
  intervalLength: Float!
  actionsPerInterval: Float!
  endedAt: Date!
}

enum UserRateLimitType {
  allComments
  allPosts
}

enum UserRateLimitIntervalUnit {
  minutes
  hours
  days
  weeks
}

input SingleUserRateLimitInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleUserRateLimitOutput {
  result: UserRateLimit
}

input UserRateLimitsUserRateLimitsInput {
  active: Boolean
  userIds: [String!]
}

input UserRateLimitSelector {
  default: EmptyViewInput
  userRateLimits: UserRateLimitsUserRateLimitsInput
  activeUserRateLimits: EmptyViewInput
}

input MultiUserRateLimitInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiUserRateLimitOutput {
  results: [UserRateLimit!]!
  totalCount: Int
}

extend type Query {
  userRateLimit(input: SingleUserRateLimitInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleUserRateLimitOutput
  userRateLimits(input: MultiUserRateLimitInput @deprecated(reason: "Use the selector field instead"), selector: UserRateLimitSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiUserRateLimitOutput
}

type UserTagRel {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  tagId: String!
  tag: Tag
  userId: String!
  user: User
  subforumShowUnreadInSidebar: Boolean
  subforumEmailNotifications: Boolean
  subforumHideIntroPost: Boolean
}

input SingleUserTagRelInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleUserTagRelOutput {
  result: UserTagRel
}

input UserTagRelsSingleInput {
  userId: String
  tagId: String
}

input UserTagRelSelector {
  default: EmptyViewInput
  single: UserTagRelsSingleInput
}

input MultiUserTagRelInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiUserTagRelOutput {
  results: [UserTagRel!]!
  totalCount: Int
}

extend type Query {
  userTagRel(input: SingleUserTagRelInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleUserTagRelOutput
  userTagRels(input: MultiUserTagRelInput @deprecated(reason: "Use the selector field instead"), selector: UserTagRelSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiUserTagRelOutput
}

type User {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  moderationGuidelines(version: String): Revision
  moderationGuidelines_latest: String
  howOthersCanHelpMe(version: String): Revision
  howOthersCanHelpMe_latest: String
  howICanHelpOthers(version: String): Revision
  howICanHelpOthers_latest: String
  slug: String!
  oldSlugs: [String!]!
  biography(version: String): Revision
  biography_latest: String
  username: String
  emails: [JSON!]
  isAdmin: Boolean!
  profile: JSON
  services: JSON
  hasAuth0Id: Boolean
  displayName: String!
  previousDisplayName: String
  email: String
  noindex: Boolean!
  groups: [String!]
  pageUrl: String
  pagePath: String
  editUrl: String
  lwWikiImport: Boolean
  theme: JSON
  lastUsedTimezone: String
  whenConfirmationEmailSent: Date
  legacy: Boolean
  commentSorting: String
  sortDraftsBy: String
  reactPaletteStyle: ReactPaletteStyle
  noKibitz: Boolean
  showHideKarmaOption: Boolean
  showPostAuthorCard: Boolean
  hideIntercom: Boolean!
  markDownPostEditor: Boolean!
  hideElicitPredictions: Boolean
  hideAFNonMemberInitialWarning: Boolean
  noSingleLineComments: Boolean!
  noCollapseCommentsPosts: Boolean!
  noCollapseCommentsFrontpage: Boolean!
  hideCommunitySection: Boolean!
  expandedFrontpageSections: ExpandedFrontpageSectionsSettingsOutput
  showCommunityInRecentDiscussion: Boolean!
  hidePostsRecommendations: Boolean!
  petrovOptOut: Boolean!
  optedOutOfSurveys: Boolean
  postGlossariesPinned: Boolean
  generateJargonForDrafts: Boolean
  generateJargonForPublishedPosts: Boolean
  acceptedTos: Boolean
  hideNavigationSidebar: Boolean
  currentFrontpageFilter: String
  frontpageSelectedTab: String
  frontpageFilterSettings: JSON
  hideFrontpageFilterSettingsDesktop: Boolean
  allPostsTimeframe: String
  allPostsFilter: String
  allPostsSorting: String
  allPostsShowLowKarma: Boolean
  allPostsIncludeEvents: Boolean
  allPostsHideCommunity: Boolean
  allPostsOpenSettings: Boolean
  draftsListSorting: String
  draftsListShowArchived: Boolean
  draftsListShowShared: Boolean
  lastNotificationsCheck: Date
  karma: Float!
  goodHeartTokens: Float
  moderationStyle: String
  moderatorAssistance: Boolean
  collapseModerationGuidelines: Boolean
  bannedUserIds: [String!]
  bannedPersonalUserIds: [String!]
  bookmarkedPostsMetadata: [PostMetadataOutput!]
  bookmarksCount: Int
  hasAnyBookmarks: Boolean
  bookmarkedPosts: [Post!]
  hiddenPostsMetadata: [PostMetadataOutput!]
  hiddenPosts: [Post!]
  legacyId: String
  deleted: Boolean!
  permanentDeletionRequestedAt: Date
  voteBanned: Boolean
  nullifyVotes: Boolean
  deleteContent: Boolean
  banned: Date
  IPs: [String!]
  auto_subscribe_to_my_posts: Boolean!
  auto_subscribe_to_my_comments: Boolean!
  autoSubscribeAsOrganizer: Boolean!
  notificationCommentsOnSubscribedPost: JSON
  notificationShortformContent: JSON
  notificationRepliesToMyComments: JSON
  notificationRepliesToSubscribedComments: JSON
  notificationSubscribedUserPost: JSON
  notificationSubscribedUserComment: JSON
  notificationPostsInGroups: JSON
  notificationSubscribedTagPost: JSON
  notificationSubscribedSequencePost: JSON
  notificationPrivateMessage: JSON
  notificationSharedWithMe: JSON
  notificationAlignmentSubmissionApproved: JSON
  notificationEventInRadius: JSON
  notificationKarmaPowersGained: JSON
  notificationRSVPs: JSON
  notificationGroupAdministration: JSON
  notificationCommentsOnDraft: JSON
  notificationPostsNominatedReview: JSON
  notificationSubforumUnread: JSON
  notificationNewMention: JSON
  notificationDialogueMessages: JSON
  notificationPublishedDialogueMessages: JSON
  notificationAddedAsCoauthor: JSON
  notificationDebateCommentsOnSubscribedPost: JSON
  notificationDebateReplies: JSON
  notificationDialogueMatch: JSON
  notificationNewDialogueChecks: JSON
  notificationYourTurnMatchForm: JSON
  hideDialogueFacilitation: Boolean
  revealChecksToAdmins: Boolean
  optedInToDialogueFacilitation: Boolean
  showDialoguesList: Boolean
  showMyDialogues: Boolean
  showMatches: Boolean
  showRecommendedPartners: Boolean
  hideActiveDialogueUsers: Boolean
  karmaChangeNotifierSettings: JSON
  karmaChangeLastOpened: Date
  karmaChangeBatchStart: Date
  emailSubscribedToCurated: Boolean
  subscribedToDigest: Boolean
  subscribedToNewsletter: Boolean
  unsubscribeFromAll: Boolean
  hideSubscribePoke: Boolean
  hideMeetupsPoke: Boolean
  hideHomeRHS: Boolean
  frontpagePostCount: Float!
  sequenceCount: Float!
  sequenceDraftCount: Float!
  mongoLocation: JSON
  googleLocation: JSON
  location: String
  mapLocation: JSON
  mapLocationLatLng: LatLng
  mapLocationSet: Boolean
  mapMarkerText: String
  htmlMapMarkerText: String
  nearbyEventsNotifications: Boolean!
  nearbyEventsNotificationsLocation: JSON
  nearbyEventsNotificationsMongoLocation: JSON
  nearbyEventsNotificationsRadius: Float
  nearbyPeopleNotificationThreshold: Float
  hideFrontpageMap: Boolean
  hideTaggingProgressBar: Boolean
  hideFrontpageBookAd: Boolean
  hideFrontpageBook2019Ad: Boolean
  hideFrontpageBook2020Ad: Boolean
  sunshineNotes: String
  sunshineFlagged: Boolean
  needsReview: Boolean
  sunshineSnoozed: Boolean
  snoozedUntilContentCount: Float
  reviewedByUserId: String
  reviewedByUser: User
  isReviewed: Boolean
  reviewedAt: Date
  spamRiskScore: Float!
  afKarma: Float!
  voteCount: Float
  smallUpvoteCount: Float
  smallDownvoteCount: Float
  bigUpvoteCount: Float
  bigDownvoteCount: Float
  voteReceivedCount: Float
  smallUpvoteReceivedCount: Float
  smallDownvoteReceivedCount: Float
  bigUpvoteReceivedCount: Float
  bigDownvoteReceivedCount: Float
  usersContactedBeforeReview: [String!]
  fullName: String
  shortformFeedId: String
  shortformFeed: Post
  viewUnreviewedComments: Boolean
  partiallyReadSequences: [PartiallyReadSequenceItemOutput!]
  hasContinueReading: Boolean
  beta: Boolean
  reviewVotesQuadratic: Boolean
  reviewVotesQuadratic2019: Boolean
  reviewVoteCount: Int
  reviewVotesQuadratic2020: Boolean
  petrovPressedButtonDate: Date
  petrovLaunchCodeDate: Date
  defaultToCKEditor: Boolean
  signUpReCaptchaRating: Float
  noExpandUnreadCommentsReview: Boolean!
  postCount: Float!
  maxPostCount: Float!
  posts(limit: Int = 5): [Post!]
  commentCount: Float!
  maxCommentCount: Float!
  tagRevisionCount: Float!
  abTestKey: String
  abTestOverrides: JSON
  walledGardenInvite: Boolean
  hideWalledGardenUI: Boolean
  walledGardenPortalOnboarded: Boolean
  taggingDashboardCollapsed: Boolean
  usernameUnset: Boolean
  paymentEmail: String
  paymentInfo: String
  profileUpdatedAt: Date!
  profileImageId: String
  jobTitle: String
  organization: String
  careerStage: [String!]
  website: String
  bio: String
  htmlBio: String!
  fmCrosspostUserId: String
  linkedinProfileURL: String
  facebookProfileURL: String
  blueskyProfileURL: String
  twitterProfileURL: String
  twitterProfileURLAdmin: String
  githubProfileURL: String
  profileTagIds: [String!]!
  profileTags: [Tag!]!
  organizerOfGroupIds: [String!]!
  organizerOfGroups: [Localgroup!]!
  programParticipation: [String!]
  postingDisabled: Boolean
  allCommentingDisabled: Boolean
  commentingOnOtherUsersDisabled: Boolean
  conversationsDisabled: Boolean
  associatedClientId: ClientId
  associatedClientIds: [ClientId!]
  altAccountsDetected: Boolean
  acknowledgedNewUserGuidelines: Boolean
  moderatorActions: [ModeratorAction!]
  subforumPreferredLayout: SubforumPreferredLayout
  hideJobAdUntil: Date
  criticismTipsDismissed: Boolean
  hideFromPeopleDirectory: Boolean!
  allowDatadogSessionReplay: Boolean!
  afPostCount: Float!
  afCommentCount: Float!
  afSequenceCount: Float!
  afSequenceDraftCount: Float!
  reviewForAlignmentForumUserId: String
  afApplicationText: String
  afSubmittedApplication: Boolean
  rateLimitNextAbleToComment(postId: String): JSON
  rateLimitNextAbleToPost(eventForm: Boolean): JSON
  recentKarmaInfo: JSON
  hideSunshineSidebar: Boolean
  inactiveSurveyEmailSentAt: Date
  userSurveyEmailSentAt: Date
  karmaChanges(startDate: Date, endDate: Date): KarmaChanges
  recommendationSettings: JSON
}

enum ReactPaletteStyle {
  listView
  gridView
}

enum UserGroup {
  guests
  members
  admins
  sunshineRegiment
  alignmentForumAdmins
  alignmentForum
  alignmentVoters
  podcasters
  canBypassPostRateLimit
  trustLevel1
  canModeratePersonal
  canSuggestCuration
  debaters
  realAdmins
}

enum TagRelVoteGroup {
  guests
  members
  admins
  sunshineRegiment
  alignmentForumAdmins
  alignmentForum
  alignmentVoters
  podcasters
  canBypassPostRateLimit
  trustLevel1
  canModeratePersonal
  canSuggestCuration
  debaters
  realAdmins
  userOwns
  userOwnsOnlyUpvote
}

enum SubforumPreferredLayout {
  card
  list
}

input UserSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

input SingleUserInput {
  selector: UserSelectorUniqueInput
  resolverArgs: JSON
}

type SingleUserOutput {
  result: User
}

input UsersUsersByUserIdsInput {
  userIds: [String!]
}

input UsersUsersProfileInput {
  userId: String
  slug: String
}

input UsersTagCommunityMembersInput {
  hasBio: Boolean
  profileTagId: String
}

input UserSelector {
  default: EmptyViewInput
  usersByUserIds: UsersUsersByUserIdsInput
  usersProfile: UsersUsersProfileInput
  LWSunshinesList: EmptyViewInput
  LWTrustLevel1List: EmptyViewInput
  LWUsersAdmin: EmptyViewInput
  usersWithBannedUsers: EmptyViewInput
  sunshineNewUsers: EmptyViewInput
  recentlyActive: EmptyViewInput
  allUsers: EmptyViewInput
  usersMapLocations: EmptyViewInput
  tagCommunityMembers: UsersTagCommunityMembersInput
  reviewAdminUsers: EmptyViewInput
  usersWithPaymentInfo: EmptyViewInput
  usersWithOptedInToDialogueFacilitation: EmptyViewInput
  alignmentSuggestedUsers: EmptyViewInput
  usersTopKarma: EmptyViewInput
}

input MultiUserInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiUserOutput {
  results: [User!]!
  totalCount: Int
}

extend type Query {
  user(input: SingleUserInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleUserOutput
  users(input: MultiUserInput @deprecated(reason: "Use the selector field instead"), selector: UserSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiUserOutput
}

type Vote {
  _id: String!
  schemaVersion: Float!
  createdAt: Date!
  legacyData: JSON
  documentId: String!
  collectionName: String!
  userId: String
  authorIds: [String!]
  authorId: String
  voteType: VoteType!
  extendedVoteType: JSON
  power: Float
  afPower: Float
  cancelled: Boolean!
  isUnvote: Boolean!
  votedAt: Date
  tagRel: TagRel
  comment: Comment
  post: Post
  documentIsAf: Boolean!
  silenceNotification: Boolean!
}

enum VoteType {
  bigDownvote
  bigUpvote
  neutral
  smallDownvote
  smallUpvote
}

input SingleVoteInput {
  selector: SelectorInput
  resolverArgs: JSON
}

type SingleVoteOutput {
  result: Vote
}

input VotesUserPostVotesInput {
  collectionName: String
  voteType: VoteType
  after: String
  before: String
}

input VotesUserVotesInput {
  collectionNames: [String!]!
}

input VoteSelector {
  default: EmptyViewInput
  tagVotes: EmptyViewInput
  userPostVotes: VotesUserPostVotesInput
  userVotes: VotesUserVotesInput
}

input MultiVoteInput {
  terms: JSON
  resolverArgs: JSON
  enableTotal: Boolean
  enableCache: Boolean
}

type MultiVoteOutput {
  results: [Vote!]!
  totalCount: Int
}

extend type Query {
  vote(input: SingleVoteInput @deprecated(reason: "Use the selector field instead"), selector: SelectorInput): SingleVoteOutput
  votes(input: MultiVoteInput @deprecated(reason: "Use the selector field instead"), selector: VoteSelector, limit: Int, offset: Int, enableTotal: Boolean): MultiVoteOutput
}

input CreateAdvisorRequestDataInput {
  legacyData: JSON
  userId: String!
  interestedInMetaculus: Boolean
  jobAds: JSON
}

input CreateAdvisorRequestInput {
  data: CreateAdvisorRequestDataInput!
}

input UpdateAdvisorRequestDataInput {
  legacyData: JSON
  userId: String
  interestedInMetaculus: Boolean
  jobAds: JSON
}

input UpdateAdvisorRequestInput {
  selector: SelectorInput!
  data: UpdateAdvisorRequestDataInput!
}

type AdvisorRequestOutput {
  data: AdvisorRequest
}

extend type Mutation {
  createAdvisorRequest(data: CreateAdvisorRequestDataInput!): AdvisorRequestOutput
  updateAdvisorRequest(selector: SelectorInput!, data: UpdateAdvisorRequestDataInput!): AdvisorRequestOutput
}

input CreateBookDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  title: String
  subtitle: String
  tocTitle: String
  collectionId: String!
  number: Float
  postIds: [String!]
  sequenceIds: [String!]
  displaySequencesAsGrid: Boolean
  hideProgressBar: Boolean
  showChapters: Boolean
}

input CreateBookInput {
  data: CreateBookDataInput!
}

input UpdateBookDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  title: String
  subtitle: String
  tocTitle: String
  collectionId: String
  number: Float
  postIds: [String!]
  sequenceIds: [String!]
  displaySequencesAsGrid: Boolean
  hideProgressBar: Boolean
  showChapters: Boolean
}

input UpdateBookInput {
  selector: SelectorInput!
  data: UpdateBookDataInput!
}

type BookOutput {
  data: Book
}

extend type Mutation {
  createBook(data: CreateBookDataInput!): BookOutput
  updateBook(selector: SelectorInput!, data: UpdateBookDataInput!): BookOutput
}

input CreateChapterDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  title: String
  subtitle: String
  number: Float
  sequenceId: String
  postIds: [String!]!
}

input CreateChapterInput {
  data: CreateChapterDataInput!
}

input UpdateChapterDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  title: String
  subtitle: String
  number: Float
  sequenceId: String
  postIds: [String!]
}

input UpdateChapterInput {
  selector: SelectorInput!
  data: UpdateChapterDataInput!
}

type ChapterOutput {
  data: Chapter
}

extend type Mutation {
  createChapter(data: CreateChapterDataInput!): ChapterOutput
  updateChapter(selector: SelectorInput!, data: UpdateChapterDataInput!): ChapterOutput
}

input CreateCollectionDataInput {
  createdAt: Date!
  legacyData: JSON
  contents: CreateRevisionDataInput
  title: String!
  slug: String!
  gridImageId: String
  firstPageLink: String
  hideStartReadingButton: Boolean
  noindex: Boolean
}

input CreateCollectionInput {
  data: CreateCollectionDataInput!
}

input UpdateCollectionDataInput {
  createdAt: Date
  legacyData: JSON
  contents: CreateRevisionDataInput
  title: String
  slug: String
  gridImageId: String
  firstPageLink: String
  hideStartReadingButton: Boolean
  noindex: Boolean
}

input UpdateCollectionInput {
  selector: SelectorInput!
  data: UpdateCollectionDataInput!
}

type CollectionOutput {
  data: Collection
}

extend type Mutation {
  createCollection(data: CreateCollectionDataInput!): CollectionOutput
  updateCollection(selector: SelectorInput!, data: UpdateCollectionDataInput!): CollectionOutput
}

input CreateCommentModeratorActionDataInput {
  legacyData: JSON
  commentId: String
  type: String!
  endedAt: Date
}

input CreateCommentModeratorActionInput {
  data: CreateCommentModeratorActionDataInput!
}

input UpdateCommentModeratorActionDataInput {
  legacyData: JSON
  commentId: String
  type: String
  endedAt: Date
}

input UpdateCommentModeratorActionInput {
  selector: SelectorInput!
  data: UpdateCommentModeratorActionDataInput!
}

type CommentModeratorActionOutput {
  data: CommentModeratorAction
}

extend type Mutation {
  createCommentModeratorAction(data: CreateCommentModeratorActionDataInput!): CommentModeratorActionOutput
  updateCommentModeratorAction(selector: SelectorInput!, data: UpdateCommentModeratorActionDataInput!): CommentModeratorActionOutput
}

input CreateCommentDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  parentCommentId: String
  topLevelCommentId: String
  postId: String
  tagId: String
  forumEventId: String
  forumEventMetadata: JSON
  tagCommentType: TagCommentType
  subforumStickyPriority: Float
  userId: String
  authorIsUnreviewed: Boolean
  answer: Boolean
  parentAnswerId: String
  shortform: Boolean
  shortformFrontpage: Boolean
  nominatedForReview: String
  reviewingForReview: String
  promotedByUserId: String
  hideKarma: Boolean
  legacy: Boolean
  legacyId: String
  legacyPoll: Boolean
  legacyParentId: String
  draft: Boolean
  retracted: Boolean
  deleted: Boolean
  deletedPublic: Boolean
  deletedReason: String
  deletedDate: Date
  deletedByUserId: String
  spam: Boolean
  needsReview: Boolean
  reviewedByUserId: String
  moderatorHat: Boolean
  hideModeratorHat: Boolean
  isPinnedOnProfile: Boolean
  title: String
  relevantTagIds: [String!]
  debateResponse: Boolean
  rejected: Boolean
  modGPTAnalysis: String
  modGPTRecommendation: String
  rejectedReason: String
  rejectedByUserId: String
  af: Boolean
  afDate: Date
  agentFoundationsId: String
  originalDialogueId: String
}

input CreateCommentInput {
  data: CreateCommentDataInput!
}

input UpdateCommentDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  postedAt: Date
  postId: String
  tagId: String
  subforumStickyPriority: Float
  authorIsUnreviewed: Boolean
  answer: Boolean
  shortform: Boolean
  shortformFrontpage: Boolean
  nominatedForReview: String
  reviewingForReview: String
  promoted: Boolean
  promotedByUserId: String
  hideKarma: Boolean
  legacy: Boolean
  legacyId: String
  legacyPoll: Boolean
  legacyParentId: String
  draft: Boolean
  retracted: Boolean
  deleted: Boolean
  deletedPublic: Boolean
  deletedReason: String
  deletedDate: Date
  deletedByUserId: String
  spam: Boolean
  repliesBlockedUntil: Date
  needsReview: Boolean
  reviewedByUserId: String
  hideAuthor: Boolean
  moderatorHat: Boolean
  hideModeratorHat: Boolean
  isPinnedOnProfile: Boolean
  title: String
  relevantTagIds: [String!]
  debateResponse: Boolean
  rejected: Boolean
  modGPTAnalysis: String
  modGPTRecommendation: String
  rejectedReason: String
  rejectedByUserId: String
  af: Boolean
  suggestForAlignmentUserIds: [String!]
  reviewForAlignmentUserId: String
  afDate: Date
  moveToAlignmentUserId: String
  agentFoundationsId: String
  originalDialogueId: String
}

input UpdateCommentInput {
  selector: SelectorInput!
  data: UpdateCommentDataInput!
}

type CommentOutput {
  data: Comment
}

extend type Mutation {
  createComment(data: CreateCommentDataInput!): CommentOutput
  updateComment(selector: SelectorInput!, data: UpdateCommentDataInput!): CommentOutput
}

input CreateConversationDataInput {
  legacyData: JSON
  title: String
  participantIds: [String!]
  af: Boolean
  moderator: Boolean
  archivedByIds: [String!]
}

input CreateConversationInput {
  data: CreateConversationDataInput!
}

input UpdateConversationDataInput {
  legacyData: JSON
  title: String
  participantIds: [String!]
  af: Boolean
  moderator: Boolean
  archivedByIds: [String!]
}

input UpdateConversationInput {
  selector: SelectorInput!
  data: UpdateConversationDataInput!
}

type ConversationOutput {
  data: Conversation
}

extend type Mutation {
  createConversation(data: CreateConversationDataInput!): ConversationOutput
  updateConversation(selector: SelectorInput!, data: UpdateConversationDataInput!): ConversationOutput
}

input CreateCurationNoticeDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  userId: String!
  commentId: String
  postId: String!
}

input CreateCurationNoticeInput {
  data: CreateCurationNoticeDataInput!
}

input UpdateCurationNoticeDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  commentId: String
  deleted: Boolean
}

input UpdateCurationNoticeInput {
  selector: SelectorInput!
  data: UpdateCurationNoticeDataInput!
}

type CurationNoticeOutput {
  data: CurationNotice
}

extend type Mutation {
  createCurationNotice(data: CreateCurationNoticeDataInput!): CurationNoticeOutput
  updateCurationNotice(selector: SelectorInput!, data: UpdateCurationNoticeDataInput!): CurationNoticeOutput
}

input CreateDigestPostDataInput {
  legacyData: JSON
  digestId: String!
  postId: String!
  emailDigestStatus: String
  onsiteDigestStatus: String
}

input CreateDigestPostInput {
  data: CreateDigestPostDataInput!
}

input UpdateDigestPostDataInput {
  legacyData: JSON
  digestId: String
  postId: String
  emailDigestStatus: String
  onsiteDigestStatus: String
}

input UpdateDigestPostInput {
  selector: SelectorInput!
  data: UpdateDigestPostDataInput!
}

type DigestPostOutput {
  data: DigestPost
}

extend type Mutation {
  createDigestPost(data: CreateDigestPostDataInput!): DigestPostOutput
  updateDigestPost(selector: SelectorInput!, data: UpdateDigestPostDataInput!): DigestPostOutput
}

input CreateDigestDataInput {
  legacyData: JSON
  num: Float!
  startDate: Date!
  endDate: Date
  publishedDate: Date
  onsiteImageId: String
  onsitePrimaryColor: String
}

input CreateDigestInput {
  data: CreateDigestDataInput!
}

input UpdateDigestDataInput {
  legacyData: JSON
  num: Float
  startDate: Date
  endDate: Date
  publishedDate: Date
  onsiteImageId: String
  onsitePrimaryColor: String
}

input UpdateDigestInput {
  selector: SelectorInput!
  data: UpdateDigestDataInput!
}

type DigestOutput {
  data: Digest
}

extend type Mutation {
  createDigest(data: CreateDigestDataInput!): DigestOutput
  updateDigest(selector: SelectorInput!, data: UpdateDigestDataInput!): DigestOutput
}

input CreateElectionCandidateDataInput {
  legacyData: JSON
  electionName: String!
  name: String!
  logoSrc: String!
  href: String!
  fundraiserLink: String
  gwwcLink: String
  gwwcId: String
  description: String!
  userId: String
  tagId: String!
  isElectionFundraiser: Boolean
  amountRaised: Float
  targetAmount: Float
}

input CreateElectionCandidateInput {
  data: CreateElectionCandidateDataInput!
}

input UpdateElectionCandidateDataInput {
  legacyData: JSON
  electionName: String
  name: String
  logoSrc: String
  href: String
  fundraiserLink: String
  gwwcLink: String
  gwwcId: String
  description: String
  userId: String
  tagId: String
  isElectionFundraiser: Boolean
  amountRaised: Float
  targetAmount: Float
}

input UpdateElectionCandidateInput {
  selector: SelectorInput!
  data: UpdateElectionCandidateDataInput!
}

type ElectionCandidateOutput {
  data: ElectionCandidate
}

extend type Mutation {
  createElectionCandidate(data: CreateElectionCandidateDataInput!): ElectionCandidateOutput
  updateElectionCandidate(selector: SelectorInput!, data: UpdateElectionCandidateDataInput!): ElectionCandidateOutput
}

input CreateElectionVoteDataInput {
  legacyData: JSON
  electionName: String!
  userId: String!
  compareState: JSON
  vote: JSON
  submittedAt: Date
  submissionComments: JSON
  userExplanation: String
  userOtherComments: String
}

input CreateElectionVoteInput {
  data: CreateElectionVoteDataInput!
}

input UpdateElectionVoteDataInput {
  legacyData: JSON
  electionName: String
  userId: String
  compareState: JSON
  vote: JSON
  submittedAt: Date
  submissionComments: JSON
  userExplanation: String
  userOtherComments: String
}

input UpdateElectionVoteInput {
  selector: SelectorInput!
  data: UpdateElectionVoteDataInput!
}

type ElectionVoteOutput {
  data: ElectionVote
}

extend type Mutation {
  createElectionVote(data: CreateElectionVoteDataInput!): ElectionVoteOutput
  updateElectionVote(selector: SelectorInput!, data: UpdateElectionVoteDataInput!): ElectionVoteOutput
}

input CreateElicitQuestionDataInput {
  legacyData: JSON
  title: String!
  notes: String
  resolution: String
  resolvesBy: Date
}

input CreateElicitQuestionInput {
  data: CreateElicitQuestionDataInput!
}

input UpdateElicitQuestionDataInput {
  legacyData: JSON
  title: String
  notes: String
  resolution: String
  resolvesBy: Date
}

input UpdateElicitQuestionInput {
  selector: SelectorInput!
  data: UpdateElicitQuestionDataInput!
}

type ElicitQuestionOutput {
  data: ElicitQuestion
}

extend type Mutation {
  createElicitQuestion(data: CreateElicitQuestionDataInput!): ElicitQuestionOutput
  updateElicitQuestion(selector: SelectorInput!, data: UpdateElicitQuestionDataInput!): ElicitQuestionOutput
}

input CreateForumEventDataInput {
  legacyData: JSON
  frontpageDescription: CreateRevisionDataInput
  frontpageDescriptionMobile: CreateRevisionDataInput
  postPageDescription: CreateRevisionDataInput
  title: String!
  startDate: Date!
  endDate: Date
  darkColor: String
  lightColor: String
  bannerTextColor: String
  contrastColor: String
  tagId: String
  postId: String
  commentId: String
  bannerImageId: String
  includesPoll: Boolean
  isGlobal: Boolean
  eventFormat: ForumEventFormat
  pollQuestion: CreateRevisionDataInput
  pollAgreeWording: String
  pollDisagreeWording: String
  maxStickersPerUser: Float
  customComponent: ForumEventCustomComponent
  commentPrompt: String
  publicData: JSON
}

input CreateForumEventInput {
  data: CreateForumEventDataInput!
}

input UpdateForumEventDataInput {
  legacyData: JSON
  frontpageDescription: CreateRevisionDataInput
  frontpageDescriptionMobile: CreateRevisionDataInput
  postPageDescription: CreateRevisionDataInput
  title: String
  startDate: Date
  endDate: Date
  darkColor: String
  lightColor: String
  bannerTextColor: String
  contrastColor: String
  tagId: String
  postId: String
  commentId: String
  bannerImageId: String
  includesPoll: Boolean
  isGlobal: Boolean
  eventFormat: ForumEventFormat
  pollQuestion: CreateRevisionDataInput
  pollAgreeWording: String
  pollDisagreeWording: String
  maxStickersPerUser: Float
  customComponent: ForumEventCustomComponent
  commentPrompt: String
  publicData: JSON
}

input UpdateForumEventInput {
  selector: SelectorInput!
  data: UpdateForumEventDataInput!
}

type ForumEventOutput {
  data: ForumEvent
}

extend type Mutation {
  createForumEvent(data: CreateForumEventDataInput!): ForumEventOutput
  updateForumEvent(selector: SelectorInput!, data: UpdateForumEventDataInput!): ForumEventOutput
}

input CreateJargonTermDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  postId: String!
  term: String!
  approved: Boolean
  deleted: Boolean
  altTerms: [String!]!
}

input CreateJargonTermInput {
  data: CreateJargonTermDataInput!
}

input UpdateJargonTermDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  term: String
  approved: Boolean
  deleted: Boolean
  altTerms: [String!]
}

input UpdateJargonTermInput {
  selector: SelectorInput!
  data: UpdateJargonTermDataInput!
}

type JargonTermOutput {
  data: JargonTerm
}

extend type Mutation {
  createJargonTerm(data: CreateJargonTermDataInput!): JargonTermOutput
  updateJargonTerm(selector: SelectorInput!, data: UpdateJargonTermDataInput!): JargonTermOutput
}

input CreateLWEventDataInput {
  legacyData: JSON
  userId: String
  name: String!
  documentId: String
  important: Boolean
  properties: JSON
  intercom: Boolean
}

input CreateLWEventInput {
  data: CreateLWEventDataInput!
}

type LWEventOutput {
  data: LWEvent
}

extend type Mutation {
  createLWEvent(data: CreateLWEventDataInput!): LWEventOutput
}

input UpdateLlmConversationDataInput {
  legacyData: JSON
  userId: String
  title: String
  model: String
  systemPrompt: String
  deleted: Boolean
}

input UpdateLlmConversationInput {
  selector: SelectorInput!
  data: UpdateLlmConversationDataInput!
}

type LlmConversationOutput {
  data: LlmConversation
}

extend type Mutation {
  updateLlmConversation(selector: SelectorInput!, data: UpdateLlmConversationDataInput!): LlmConversationOutput
}

input CreateLocalgroupDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  name: String!
  nameInAnotherLanguage: String
  organizerIds: [String!]!
  lastActivity: Date
  types: [String!]!
  categories: [String!]
  isOnline: Boolean
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  facebookPageLink: String
  meetupLink: String
  slackLink: String
  website: String
  bannerImageId: String
  inactive: Boolean
  deleted: Boolean
}

input CreateLocalgroupInput {
  data: CreateLocalgroupDataInput!
}

input UpdateLocalgroupDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  name: String
  nameInAnotherLanguage: String
  organizerIds: [String!]
  lastActivity: Date
  types: [String!]
  categories: [String!]
  isOnline: Boolean
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  facebookPageLink: String
  meetupLink: String
  slackLink: String
  website: String
  bannerImageId: String
  inactive: Boolean
  deleted: Boolean
}

input UpdateLocalgroupInput {
  selector: SelectorInput!
  data: UpdateLocalgroupDataInput!
}

type LocalgroupOutput {
  data: Localgroup
}

extend type Mutation {
  createLocalgroup(data: CreateLocalgroupDataInput!): LocalgroupOutput
  updateLocalgroup(selector: SelectorInput!, data: UpdateLocalgroupDataInput!): LocalgroupOutput
}

input CreateMessageDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  userId: String
  conversationId: String!
  noEmail: Boolean
}

input CreateMessageInput {
  data: CreateMessageDataInput!
}

input UpdateMessageDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
}

input UpdateMessageInput {
  selector: SelectorInput!
  data: UpdateMessageDataInput!
}

type MessageOutput {
  data: Message
}

extend type Mutation {
  createMessage(data: CreateMessageDataInput!): MessageOutput
  updateMessage(selector: SelectorInput!, data: UpdateMessageDataInput!): MessageOutput
}

input CreateModerationTemplateDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  name: String!
  collectionName: ModerationTemplateType!
  order: Float
}

input CreateModerationTemplateInput {
  data: CreateModerationTemplateDataInput!
}

input UpdateModerationTemplateDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  name: String
  collectionName: ModerationTemplateType
  order: Float
  deleted: Boolean
}

input UpdateModerationTemplateInput {
  selector: SelectorInput!
  data: UpdateModerationTemplateDataInput!
}

type ModerationTemplateOutput {
  data: ModerationTemplate
}

extend type Mutation {
  createModerationTemplate(data: CreateModerationTemplateDataInput!): ModerationTemplateOutput
  updateModerationTemplate(selector: SelectorInput!, data: UpdateModerationTemplateDataInput!): ModerationTemplateOutput
}

input CreateModeratorActionDataInput {
  legacyData: JSON
  userId: String
  type: ModeratorActionType!
  endedAt: Date
}

input CreateModeratorActionInput {
  data: CreateModeratorActionDataInput!
}

input UpdateModeratorActionDataInput {
  legacyData: JSON
  userId: String
  type: ModeratorActionType
  endedAt: Date
}

input UpdateModeratorActionInput {
  selector: SelectorInput!
  data: UpdateModeratorActionDataInput!
}

type ModeratorActionOutput {
  data: ModeratorAction
}

extend type Mutation {
  createModeratorAction(data: CreateModeratorActionDataInput!): ModeratorActionOutput
  updateModeratorAction(selector: SelectorInput!, data: UpdateModeratorActionDataInput!): ModeratorActionOutput
}

input CreateMultiDocumentDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  slug: String
  title: String
  tabTitle: String!
  tabSubtitle: String
  userId: String
  parentDocumentId: String!
  collectionName: MultiDocumentCollectionName!
  fieldName: MultiDocumentFieldName!
}

input CreateMultiDocumentInput {
  data: CreateMultiDocumentDataInput!
}

input UpdateMultiDocumentDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  slug: String
  title: String
  tabTitle: String
  tabSubtitle: String
  index: Float
  deleted: Boolean
}

input UpdateMultiDocumentInput {
  selector: SelectorInput!
  data: UpdateMultiDocumentDataInput!
}

type MultiDocumentOutput {
  data: MultiDocument
}

extend type Mutation {
  createMultiDocument(data: CreateMultiDocumentDataInput!): MultiDocumentOutput
  updateMultiDocument(selector: SelectorInput!, data: UpdateMultiDocumentDataInput!): MultiDocumentOutput
}

input UpdateNotificationDataInput {
  legacyData: JSON
  viewed: Boolean
}

input UpdateNotificationInput {
  selector: SelectorInput!
  data: UpdateNotificationDataInput!
}

type NotificationOutput {
  data: Notification
}

extend type Mutation {
  updateNotification(selector: SelectorInput!, data: UpdateNotificationDataInput!): NotificationOutput
}

input CreatePetrovDayActionDataInput {
  legacyData: JSON
  actionType: String!
  data: JSON
  userId: String!
}

input CreatePetrovDayActionInput {
  data: CreatePetrovDayActionDataInput!
}

type PetrovDayActionOutput {
  data: PetrovDayAction
}

extend type Mutation {
  createPetrovDayAction(data: CreatePetrovDayActionDataInput!): PetrovDayActionOutput
}

input CreatePodcastEpisodeDataInput {
  legacyData: JSON
  podcastId: String
  title: String!
  episodeLink: String!
  externalEpisodeId: String!
}

input CreatePodcastEpisodeInput {
  data: CreatePodcastEpisodeDataInput!
}

type PodcastEpisodeOutput {
  data: PodcastEpisode
}

extend type Mutation {
  createPodcastEpisode(data: CreatePodcastEpisodeDataInput!): PodcastEpisodeOutput
}

input CreatePostDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  moderationGuidelines: CreateRevisionDataInput
  customHighlight: CreateRevisionDataInput
  slug: String
  postedAt: Date
  url: String
  postCategory: PostCategory
  title: String!
  status: Float
  sticky: Boolean
  stickyPriority: Int
  userId: String
  question: Boolean
  authorIsUnreviewed: Boolean
  readTimeMinutesOverride: Float
  submitToFrontpage: Boolean
  hiddenRelatedQuestion: Boolean
  originalPostRelationSourceId: String
  shortform: Boolean
  canonicalSource: String
  manifoldReviewMarketId: String
  tagRelevance: JSON
  noIndex: Boolean
  activateRSVPs: Boolean
  nextDayReminderSent: Boolean
  onlyVisibleToLoggedIn: Boolean
  onlyVisibleToEstablishedAccounts: Boolean
  hideFromRecentDiscussions: Boolean
  podcastEpisodeId: String
  forceAllowType3Audio: Boolean
  legacy: Boolean
  legacyId: String
  legacySpam: Boolean
  feedId: String
  feedLink: String
  curatedDate: Date
  metaDate: Date
  suggestForCuratedUserIds: [String!]
  frontpageDate: Date
  autoFrontpage: String
  collectionTitle: String
  coauthorStatuses: [CoauthorStatusInput!]
  hasCoauthorPermission: Boolean
  socialPreviewImageId: String
  socialPreviewImageAutoUrl: String
  socialPreview: SocialPreviewInput
  fmCrosspost: CrosspostInput
  canonicalSequenceId: String
  canonicalCollectionSlug: String
  canonicalBookId: String
  canonicalNextPostSlug: String
  canonicalPrevPostSlug: String
  unlisted: Boolean
  disableRecommendation: Boolean
  defaultRecommendation: Boolean
  hideFromPopularComments: Boolean
  draft: Boolean
  wasEverUndrafted: Boolean
  meta: Boolean
  hideFrontpageComments: Boolean
  bannedUserIds: [String!]
  commentsLocked: Boolean
  commentsLockedToAccountsCreatedAfter: Date
  organizerIds: [String!]
  groupId: String
  eventType: String
  isEvent: Boolean
  reviewedByUserId: String
  reviewForCuratedUserId: String
  startTime: Date
  endTime: Date
  eventRegistrationLink: String
  joinEventLink: String
  onlineEvent: Boolean
  globalEvent: Boolean
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  meetupLink: String
  website: String
  eventImageId: String
  types: [String!]
  metaSticky: Boolean
  sharingSettings: JSON
  shareWithUsers: [String!]
  commentSortOrder: String
  hideAuthor: Boolean
  sideCommentVisibility: String
  disableSidenotes: Boolean
  moderationStyle: String
  ignoreRateLimits: Boolean
  hideCommentKarma: Boolean
  collabEditorDialogue: Boolean
  rejected: Boolean
  rejectedReason: String
  rejectedByUserId: String
  subforumTagId: String
  af: Boolean
  afDate: Date
  afSticky: Boolean
  suggestForAlignmentUserIds: [String!]
  reviewForAlignmentUserId: String
  agentFoundationsId: String
  swrCachingEnabled: Boolean
  generateDraftJargon: Boolean
}

input CreatePostInput {
  data: CreatePostDataInput!
}

input UpdatePostDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  moderationGuidelines: CreateRevisionDataInput
  customHighlight: CreateRevisionDataInput
  slug: String
  postedAt: Date
  url: String
  postCategory: PostCategory
  title: String
  deletedDraft: Boolean
  status: Float
  sticky: Boolean
  stickyPriority: Int
  userId: String
  question: Boolean
  authorIsUnreviewed: Boolean
  readTimeMinutesOverride: Float
  submitToFrontpage: Boolean
  hiddenRelatedQuestion: Boolean
  shortform: Boolean
  canonicalSource: String
  manifoldReviewMarketId: String
  tagRelevance: JSON
  noIndex: Boolean
  activateRSVPs: Boolean
  nextDayReminderSent: Boolean
  onlyVisibleToLoggedIn: Boolean
  onlyVisibleToEstablishedAccounts: Boolean
  hideFromRecentDiscussions: Boolean
  votingSystem: String
  podcastEpisodeId: String
  forceAllowType3Audio: Boolean
  legacy: Boolean
  legacyId: String
  legacySpam: Boolean
  feedId: String
  feedLink: String
  curatedDate: Date
  metaDate: Date
  suggestForCuratedUserIds: [String!]
  frontpageDate: Date
  autoFrontpage: String
  collectionTitle: String
  coauthorStatuses: [CoauthorStatusInput!]
  hasCoauthorPermission: Boolean
  socialPreviewImageId: String
  socialPreviewImageAutoUrl: String
  socialPreview: SocialPreviewInput
  fmCrosspost: CrosspostInput
  canonicalSequenceId: String
  canonicalCollectionSlug: String
  canonicalBookId: String
  canonicalNextPostSlug: String
  canonicalPrevPostSlug: String
  unlisted: Boolean
  disableRecommendation: Boolean
  defaultRecommendation: Boolean
  hideFromPopularComments: Boolean
  draft: Boolean
  wasEverUndrafted: Boolean
  meta: Boolean
  hideFrontpageComments: Boolean
  bannedUserIds: [String!]
  commentsLocked: Boolean
  commentsLockedToAccountsCreatedAfter: Date
  organizerIds: [String!]
  groupId: String
  eventType: String
  isEvent: Boolean
  reviewedByUserId: String
  reviewForCuratedUserId: String
  startTime: Date
  endTime: Date
  eventRegistrationLink: String
  joinEventLink: String
  onlineEvent: Boolean
  globalEvent: Boolean
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  meetupLink: String
  website: String
  eventImageId: String
  types: [String!]
  metaSticky: Boolean
  sharingSettings: JSON
  shareWithUsers: [String!]
  linkSharingKey: String
  commentSortOrder: String
  hideAuthor: Boolean
  sideCommentVisibility: String
  disableSidenotes: Boolean
  moderationStyle: String
  ignoreRateLimits: Boolean
  hideCommentKarma: Boolean
  collabEditorDialogue: Boolean
  rejected: Boolean
  rejectedReason: String
  rejectedByUserId: String
  subforumTagId: String
  af: Boolean
  afDate: Date
  afSticky: Boolean
  suggestForAlignmentUserIds: [String!]
  reviewForAlignmentUserId: String
  agentFoundationsId: String
  swrCachingEnabled: Boolean
  generateDraftJargon: Boolean
}

input UpdatePostInput {
  selector: SelectorInput!
  data: UpdatePostDataInput!
}

type PostOutput {
  data: Post
}

extend type Mutation {
  createPost(data: CreatePostDataInput!): PostOutput
  updatePost(selector: SelectorInput!, data: UpdatePostDataInput!): PostOutput
}

input CreateRSSFeedDataInput {
  legacyData: JSON
  userId: String
  ownedByUser: Boolean
  displayFullContent: Boolean
  nickname: String!
  url: String!
  rawFeed: JSON
  setCanonicalUrl: Boolean
  importAsDraft: Boolean
}

input CreateRSSFeedInput {
  data: CreateRSSFeedDataInput!
}

input UpdateRSSFeedDataInput {
  legacyData: JSON
  userId: String
  ownedByUser: Boolean
  displayFullContent: Boolean
  nickname: String
  url: String
  status: String
  rawFeed: JSON
  setCanonicalUrl: Boolean
  importAsDraft: Boolean
}

input UpdateRSSFeedInput {
  selector: SelectorInput!
  data: UpdateRSSFeedDataInput!
}

type RSSFeedOutput {
  data: RSSFeed
}

extend type Mutation {
  createRSSFeed(data: CreateRSSFeedDataInput!): RSSFeedOutput
  updateRSSFeed(selector: SelectorInput!, data: UpdateRSSFeedDataInput!): RSSFeedOutput
}

input CreateReportDataInput {
  legacyData: JSON
  userId: String
  reportedUserId: String
  commentId: String
  postId: String
  link: String!
  claimedUserId: String
  description: String
  reportedAsSpam: Boolean
}

input CreateReportInput {
  data: CreateReportDataInput!
}

input UpdateReportDataInput {
  createdAt: Date
  legacyData: JSON
  claimedUserId: String
  description: String
  closedAt: Date
  markedAsSpam: Boolean
  reportedAsSpam: Boolean
}

input UpdateReportInput {
  selector: SelectorInput!
  data: UpdateReportDataInput!
}

type ReportOutput {
  data: Report
}

extend type Mutation {
  createReport(data: CreateReportDataInput!): ReportOutput
  updateReport(selector: SelectorInput!, data: UpdateReportDataInput!): ReportOutput
}

input ContentTypeInput {
  type: String!
  data: ContentTypeData!
}

input CreateRevisionDataInput {
  originalContents: ContentTypeInput!
  commitMessage: String
  updateType: String
  dataWithDiscardedSuggestions: JSON
  googleDocMetadata: JSON
}

input UpdateRevisionDataInput {
  legacyData: JSON
  skipAttributions: Boolean
}

input UpdateRevisionInput {
  selector: SelectorInput!
  data: UpdateRevisionDataInput!
}

type RevisionOutput {
  data: Revision
}

extend type Mutation {
  updateRevision(selector: SelectorInput!, data: UpdateRevisionDataInput!): RevisionOutput
}

input CreateSequenceDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  lastUpdated: Date
  userId: String
  title: String!
  bannerImageId: String
  gridImageId: String
  hideFromAuthorPage: Boolean
  draft: Boolean
  isDeleted: Boolean
  curatedOrder: Float
  userProfileOrder: Float
  canonicalCollectionSlug: String
  hidden: Boolean
  noindex: Boolean
  af: Boolean
}

input CreateSequenceInput {
  data: CreateSequenceDataInput!
}

input UpdateSequenceDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  lastUpdated: Date
  userId: String
  title: String
  bannerImageId: String
  gridImageId: String
  hideFromAuthorPage: Boolean
  draft: Boolean
  isDeleted: Boolean
  curatedOrder: Float
  userProfileOrder: Float
  canonicalCollectionSlug: String
  hidden: Boolean
  noindex: Boolean
  af: Boolean
}

input UpdateSequenceInput {
  selector: SelectorInput!
  data: UpdateSequenceDataInput!
}

type SequenceOutput {
  data: Sequence
}

extend type Mutation {
  createSequence(data: CreateSequenceDataInput!): SequenceOutput
  updateSequence(selector: SelectorInput!, data: UpdateSequenceDataInput!): SequenceOutput
}

input CreateSplashArtCoordinateDataInput {
  legacyData: JSON
  reviewWinnerArtId: String!
  leftXPct: Float!
  leftYPct: Float!
  leftHeightPct: Float!
  leftWidthPct: Float!
  leftFlipped: Boolean
  middleXPct: Float!
  middleYPct: Float!
  middleHeightPct: Float!
  middleWidthPct: Float!
  middleFlipped: Boolean
  rightXPct: Float!
  rightYPct: Float!
  rightHeightPct: Float!
  rightWidthPct: Float!
  rightFlipped: Boolean!
}

input CreateSplashArtCoordinateInput {
  data: CreateSplashArtCoordinateDataInput!
}

type SplashArtCoordinateOutput {
  data: SplashArtCoordinate
}

extend type Mutation {
  createSplashArtCoordinate(data: CreateSplashArtCoordinateDataInput!): SplashArtCoordinateOutput
}

input CreateSpotlightDataInput {
  legacyData: JSON
  description: CreateRevisionDataInput
  documentId: String!
  documentType: SpotlightDocumentType!
  position: Float
  duration: Float!
  customTitle: String
  customSubtitle: String
  subtitleUrl: String
  headerTitle: String
  headerTitleLeftColor: String
  headerTitleRightColor: String
  lastPromotedAt: Date!
  spotlightSplashImageUrl: String
  draft: Boolean
  showAuthor: Boolean
  imageFade: Boolean
  imageFadeColor: String
  spotlightImageId: String
  spotlightDarkImageId: String
}

input CreateSpotlightInput {
  data: CreateSpotlightDataInput!
}

input UpdateSpotlightDataInput {
  legacyData: JSON
  description: CreateRevisionDataInput
  documentId: String
  documentType: SpotlightDocumentType
  position: Float
  duration: Float
  customTitle: String
  customSubtitle: String
  subtitleUrl: String
  headerTitle: String
  headerTitleLeftColor: String
  headerTitleRightColor: String
  lastPromotedAt: Date
  spotlightSplashImageUrl: String
  draft: Boolean
  deletedDraft: Boolean
  showAuthor: Boolean
  imageFade: Boolean
  imageFadeColor: String
  spotlightImageId: String
  spotlightDarkImageId: String
}

input UpdateSpotlightInput {
  selector: SelectorInput!
  data: UpdateSpotlightDataInput!
}

type SpotlightOutput {
  data: Spotlight
}

extend type Mutation {
  createSpotlight(data: CreateSpotlightDataInput!): SpotlightOutput
  updateSpotlight(selector: SelectorInput!, data: UpdateSpotlightDataInput!): SpotlightOutput
}

input CreateSubscriptionDataInput {
  legacyData: JSON
  state: String!
  documentId: String!
  collectionName: String!
  type: String!
}

input CreateSubscriptionInput {
  data: CreateSubscriptionDataInput!
}

type SubscriptionOutput {
  data: Subscription
}

extend type Mutation {
  createSubscription(data: CreateSubscriptionDataInput!): SubscriptionOutput
}

input CreateSurveyQuestionDataInput {
  legacyData: JSON
  surveyId: String!
  question: String!
  format: SurveyQuestionFormat!
  order: Float!
}

input CreateSurveyQuestionInput {
  data: CreateSurveyQuestionDataInput!
}

input UpdateSurveyQuestionDataInput {
  legacyData: JSON
  surveyId: String
  question: String
  format: SurveyQuestionFormat
  order: Float
}

input UpdateSurveyQuestionInput {
  selector: SelectorInput!
  data: UpdateSurveyQuestionDataInput!
}

type SurveyQuestionOutput {
  data: SurveyQuestion
}

extend type Mutation {
  createSurveyQuestion(data: CreateSurveyQuestionDataInput!): SurveyQuestionOutput
  updateSurveyQuestion(selector: SelectorInput!, data: UpdateSurveyQuestionDataInput!): SurveyQuestionOutput
}

input CreateSurveyResponseDataInput {
  legacyData: JSON
  surveyId: String!
  surveyScheduleId: String!
  userId: String!
  clientId: String!
  response: JSON!
}

input CreateSurveyResponseInput {
  data: CreateSurveyResponseDataInput!
}

input UpdateSurveyResponseDataInput {
  legacyData: JSON
  surveyId: String
  surveyScheduleId: String
  userId: String
  clientId: String
  response: JSON
}

input UpdateSurveyResponseInput {
  selector: SelectorInput!
  data: UpdateSurveyResponseDataInput!
}

type SurveyResponseOutput {
  data: SurveyResponse
}

extend type Mutation {
  createSurveyResponse(data: CreateSurveyResponseDataInput!): SurveyResponseOutput
  updateSurveyResponse(selector: SelectorInput!, data: UpdateSurveyResponseDataInput!): SurveyResponseOutput
}

input CreateSurveyScheduleDataInput {
  legacyData: JSON
  surveyId: String!
  name: String!
  impressionsLimit: Float
  maxVisitorPercentage: Float
  minKarma: Float
  maxKarma: Float
  target: SurveyScheduleTarget!
  startDate: Date
  endDate: Date
  deactivated: Boolean
  clientIds: [String!]
}

input CreateSurveyScheduleInput {
  data: CreateSurveyScheduleDataInput!
}

input UpdateSurveyScheduleDataInput {
  legacyData: JSON
  surveyId: String
  name: String
  impressionsLimit: Float
  maxVisitorPercentage: Float
  minKarma: Float
  maxKarma: Float
  target: SurveyScheduleTarget
  startDate: Date
  endDate: Date
  deactivated: Boolean
  clientIds: [String!]
}

input UpdateSurveyScheduleInput {
  selector: SelectorInput!
  data: UpdateSurveyScheduleDataInput!
}

type SurveyScheduleOutput {
  data: SurveySchedule
}

extend type Mutation {
  createSurveySchedule(data: CreateSurveyScheduleDataInput!): SurveyScheduleOutput
  updateSurveySchedule(selector: SelectorInput!, data: UpdateSurveyScheduleDataInput!): SurveyScheduleOutput
}

input CreateSurveyDataInput {
  legacyData: JSON
  name: String!
}

input CreateSurveyInput {
  data: CreateSurveyDataInput!
}

input UpdateSurveyDataInput {
  legacyData: JSON
  name: String
}

input UpdateSurveyInput {
  selector: SelectorInput!
  data: UpdateSurveyDataInput!
}

type SurveyOutput {
  data: Survey
}

extend type Mutation {
  createSurvey(data: CreateSurveyDataInput!): SurveyOutput
  updateSurvey(selector: SelectorInput!, data: UpdateSurveyDataInput!): SurveyOutput
}

input CreateTagFlagDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  slug: String
  name: String!
  deleted: Boolean
  order: Float
}

input CreateTagFlagInput {
  data: CreateTagFlagDataInput!
}

input UpdateTagFlagDataInput {
  legacyData: JSON
  contents: CreateRevisionDataInput
  slug: String
  name: String
  deleted: Boolean
  order: Float
}

input UpdateTagFlagInput {
  selector: SelectorInput!
  data: UpdateTagFlagDataInput!
}

type TagFlagOutput {
  data: TagFlag
}

extend type Mutation {
  createTagFlag(data: CreateTagFlagDataInput!): TagFlagOutput
  updateTagFlag(selector: SelectorInput!, data: UpdateTagFlagDataInput!): TagFlagOutput
}

input CreateTagDataInput {
  legacyData: JSON
  description: CreateRevisionDataInput
  subforumWelcomeText: CreateRevisionDataInput
  moderationGuidelines: CreateRevisionDataInput
  slug: String
  name: String!
  shortName: String
  subtitle: String
  core: Boolean
  isPostType: Boolean
  suggestedAsFilter: Boolean
  defaultOrder: Float
  descriptionTruncationCount: Float
  adminOnly: Boolean
  canEditUserIds: [String!]
  reviewedByUserId: String
  wikiGrade: Int
  wikiOnly: Boolean
  bannerImageId: String
  squareImageId: String
  tagFlagsIds: [String!]
  introSequenceId: String
  postsDefaultSortOrder: String
  canVoteOnRels: [TagRelVoteGroup!]
  isSubforum: Boolean
  subforumModeratorIds: [String!]
  subforumIntroPostId: String
  parentTagId: String
  subTagIds: [String!]
  autoTagModel: String
  autoTagPrompt: String
  coreTagId: String
  forceAllowType3Audio: Boolean
}

input CreateTagInput {
  data: CreateTagDataInput!
}

input UpdateTagDataInput {
  legacyData: JSON
  description: CreateRevisionDataInput
  subforumWelcomeText: CreateRevisionDataInput
  moderationGuidelines: CreateRevisionDataInput
  slug: String
  name: String
  shortName: String
  subtitle: String
  core: Boolean
  isPostType: Boolean
  suggestedAsFilter: Boolean
  defaultOrder: Float
  descriptionTruncationCount: Float
  adminOnly: Boolean
  canEditUserIds: [String!]
  deleted: Boolean
  needsReview: Boolean
  reviewedByUserId: String
  wikiGrade: Int
  wikiOnly: Boolean
  bannerImageId: String
  squareImageId: String
  tagFlagsIds: [String!]
  introSequenceId: String
  postsDefaultSortOrder: String
  canVoteOnRels: [TagRelVoteGroup!]
  isSubforum: Boolean
  subforumModeratorIds: [String!]
  subforumIntroPostId: String
  parentTagId: String
  subTagIds: [String!]
  autoTagModel: String
  autoTagPrompt: String
  noindex: Boolean
  isPlaceholderPage: Boolean
  coreTagId: String
  forceAllowType3Audio: Boolean
}

input UpdateTagInput {
  selector: SelectorInput!
  data: UpdateTagDataInput!
}

type TagOutput {
  data: Tag
}

extend type Mutation {
  createTag(data: CreateTagDataInput!): TagOutput
  updateTag(selector: SelectorInput!, data: UpdateTagDataInput!): TagOutput
}

input CreateUltraFeedEventDataInput {
  documentId: String!
  collectionName: String!
  eventType: String!
  userId: String
  event: JSON
  feedItemId: String
}

input CreateUltraFeedEventInput {
  data: CreateUltraFeedEventDataInput!
}

input UpdateUltraFeedEventDataInput {
  event: JSON
}

type UltraFeedEventOutput {
  data: UltraFeedEvent
}

extend type Mutation {
  createUltraFeedEvent(data: CreateUltraFeedEventDataInput!): UltraFeedEventOutput
  updateUltraFeedEvent(selector: String!, data: UpdateUltraFeedEventDataInput!): UltraFeedEventOutput
}

input CreateUserEAGDetailDataInput {
  legacyData: JSON
  lastUpdated: Date
}

input CreateUserEAGDetailInput {
  data: CreateUserEAGDetailDataInput!
}

input UpdateUserEAGDetailDataInput {
  legacyData: JSON
  careerStage: [String!]
  countryOrRegion: String
  nearestCity: String
  willingnessToRelocate: JSON
  experiencedIn: [String!]
  interestedIn: [String!]
  lastUpdated: Date
}

input UpdateUserEAGDetailInput {
  selector: SelectorInput!
  data: UpdateUserEAGDetailDataInput!
}

type UserEAGDetailOutput {
  data: UserEAGDetail
}

extend type Mutation {
  createUserEAGDetail(data: CreateUserEAGDetailDataInput!): UserEAGDetailOutput
  updateUserEAGDetail(selector: SelectorInput!, data: UpdateUserEAGDetailDataInput!): UserEAGDetailOutput
}

input CreateUserJobAdDataInput {
  legacyData: JSON
  userId: String!
  jobName: String!
  adState: String!
  reminderSetAt: Date
  lastUpdated: Date
}

input CreateUserJobAdInput {
  data: CreateUserJobAdDataInput!
}

input UpdateUserJobAdDataInput {
  legacyData: JSON
  adState: String
  reminderSetAt: Date
  lastUpdated: Date
}

input UpdateUserJobAdInput {
  selector: SelectorInput!
  data: UpdateUserJobAdDataInput!
}

type UserJobAdOutput {
  data: UserJobAd
}

extend type Mutation {
  createUserJobAd(data: CreateUserJobAdDataInput!): UserJobAdOutput
  updateUserJobAd(selector: SelectorInput!, data: UpdateUserJobAdDataInput!): UserJobAdOutput
}

input CreateUserMostValuablePostDataInput {
  legacyData: JSON
  userId: String!
  postId: String!
  deleted: Boolean
}

input CreateUserMostValuablePostInput {
  data: CreateUserMostValuablePostDataInput!
}

input UpdateUserMostValuablePostDataInput {
  legacyData: JSON
  userId: String
  postId: String
  deleted: Boolean
}

input UpdateUserMostValuablePostInput {
  selector: SelectorInput!
  data: UpdateUserMostValuablePostDataInput!
}

type UserMostValuablePostOutput {
  data: UserMostValuablePost
}

extend type Mutation {
  createUserMostValuablePost(data: CreateUserMostValuablePostDataInput!): UserMostValuablePostOutput
  updateUserMostValuablePost(selector: SelectorInput!, data: UpdateUserMostValuablePostDataInput!): UserMostValuablePostOutput
}

input CreateUserRateLimitDataInput {
  legacyData: JSON
  userId: String!
  type: UserRateLimitType!
  intervalUnit: UserRateLimitIntervalUnit!
  intervalLength: Float!
  actionsPerInterval: Float!
  endedAt: Date!
}

input CreateUserRateLimitInput {
  data: CreateUserRateLimitDataInput!
}

input UpdateUserRateLimitDataInput {
  legacyData: JSON
  userId: String
  type: UserRateLimitType
  intervalUnit: UserRateLimitIntervalUnit
  intervalLength: Float
  actionsPerInterval: Float
  endedAt: Date
}

input UpdateUserRateLimitInput {
  selector: SelectorInput!
  data: UpdateUserRateLimitDataInput!
}

type UserRateLimitOutput {
  data: UserRateLimit
}

extend type Mutation {
  createUserRateLimit(data: CreateUserRateLimitDataInput!): UserRateLimitOutput
  updateUserRateLimit(selector: SelectorInput!, data: UpdateUserRateLimitDataInput!): UserRateLimitOutput
}

input CreateUserTagRelDataInput {
  legacyData: JSON
  tagId: String!
  userId: String!
  subforumShowUnreadInSidebar: Boolean
  subforumEmailNotifications: Boolean
  subforumHideIntroPost: Boolean
}

input CreateUserTagRelInput {
  data: CreateUserTagRelDataInput!
}

input UpdateUserTagRelDataInput {
  legacyData: JSON
  subforumShowUnreadInSidebar: Boolean
  subforumEmailNotifications: Boolean
  subforumHideIntroPost: Boolean
}

input UpdateUserTagRelInput {
  selector: SelectorInput!
  data: UpdateUserTagRelDataInput!
}

type UserTagRelOutput {
  data: UserTagRel
}

extend type Mutation {
  createUserTagRel(data: CreateUserTagRelDataInput!): UserTagRelOutput
  updateUserTagRel(selector: SelectorInput!, data: UpdateUserTagRelDataInput!): UserTagRelOutput
}

input CreateUserDataInput {
  legacyData: JSON
  moderationGuidelines: CreateRevisionDataInput
  howOthersCanHelpMe: CreateRevisionDataInput
  howICanHelpOthers: CreateRevisionDataInput
  slug: String
  biography: CreateRevisionDataInput
  username: String
  isAdmin: Boolean
  displayName: String!
  previousDisplayName: String
  email: String
  groups: [String!]
  theme: JSON
  lastUsedTimezone: String
  whenConfirmationEmailSent: Date
  legacy: Boolean
  commentSorting: String
  noKibitz: Boolean
  showHideKarmaOption: Boolean
  showPostAuthorCard: Boolean
  hideIntercom: Boolean
  noSingleLineComments: Boolean
  noCollapseCommentsPosts: Boolean
  noCollapseCommentsFrontpage: Boolean
  hideCommunitySection: Boolean
  expandedFrontpageSections: ExpandedFrontpageSectionsSettingsInput
  showCommunityInRecentDiscussion: Boolean
  hidePostsRecommendations: Boolean
  petrovOptOut: Boolean
  optedOutOfSurveys: Boolean
  postGlossariesPinned: Boolean
  acceptedTos: Boolean
  hideNavigationSidebar: Boolean
  currentFrontpageFilter: String
  frontpageSelectedTab: String
  frontpageFilterSettings: JSON
  hideFrontpageFilterSettingsDesktop: Boolean
  allPostsTimeframe: String
  allPostsFilter: String
  allPostsSorting: String
  allPostsShowLowKarma: Boolean
  allPostsIncludeEvents: Boolean
  allPostsHideCommunity: Boolean
  allPostsOpenSettings: Boolean
  draftsListSorting: String
  draftsListShowArchived: Boolean
  draftsListShowShared: Boolean
  lastNotificationsCheck: Date
  moderationStyle: String
  moderatorAssistance: Boolean
  collapseModerationGuidelines: Boolean
  bannedUserIds: [String!]
  bannedPersonalUserIds: [String!]
  legacyId: String
  voteBanned: Boolean
  nullifyVotes: Boolean
  deleteContent: Boolean
  banned: Date
  auto_subscribe_to_my_posts: Boolean
  auto_subscribe_to_my_comments: Boolean
  autoSubscribeAsOrganizer: Boolean
  notificationCommentsOnSubscribedPost: JSON
  notificationShortformContent: JSON
  notificationRepliesToMyComments: JSON
  notificationRepliesToSubscribedComments: JSON
  notificationSubscribedUserPost: JSON
  notificationSubscribedUserComment: JSON
  notificationPostsInGroups: JSON
  notificationSubscribedTagPost: JSON
  notificationSubscribedSequencePost: JSON
  notificationPrivateMessage: JSON
  notificationSharedWithMe: JSON
  notificationAlignmentSubmissionApproved: JSON
  notificationEventInRadius: JSON
  notificationKarmaPowersGained: JSON
  notificationRSVPs: JSON
  notificationGroupAdministration: JSON
  notificationCommentsOnDraft: JSON
  notificationPostsNominatedReview: JSON
  notificationSubforumUnread: JSON
  notificationNewMention: JSON
  notificationDialogueMessages: JSON
  notificationPublishedDialogueMessages: JSON
  notificationAddedAsCoauthor: JSON
  notificationDebateCommentsOnSubscribedPost: JSON
  notificationDebateReplies: JSON
  notificationDialogueMatch: JSON
  notificationNewDialogueChecks: JSON
  notificationYourTurnMatchForm: JSON
  hideDialogueFacilitation: Boolean
  revealChecksToAdmins: Boolean
  optedInToDialogueFacilitation: Boolean
  showDialoguesList: Boolean
  showMyDialogues: Boolean
  showMatches: Boolean
  showRecommendedPartners: Boolean
  hideActiveDialogueUsers: Boolean
  karmaChangeNotifierSettings: JSON
  karmaChangeLastOpened: Date
  karmaChangeBatchStart: Date
  emailSubscribedToCurated: Boolean
  subscribedToDigest: Boolean
  subscribedToNewsletter: Boolean
  unsubscribeFromAll: Boolean
  hideSubscribePoke: Boolean
  hideMeetupsPoke: Boolean
  hideHomeRHS: Boolean
  googleLocation: JSON
  location: String
  mapLocation: JSON
  mapMarkerText: String
  nearbyEventsNotifications: Boolean
  nearbyEventsNotificationsLocation: JSON
  nearbyEventsNotificationsRadius: Float
  nearbyPeopleNotificationThreshold: Float
  hideFrontpageMap: Boolean
  hideTaggingProgressBar: Boolean
  hideFrontpageBookAd: Boolean
  hideFrontpageBook2019Ad: Boolean
  hideFrontpageBook2020Ad: Boolean
  reviewedByUserId: String
  shortformFeedId: String
  viewUnreviewedComments: Boolean
  noExpandUnreadCommentsReview: Boolean
  profileUpdatedAt: Date
  jobTitle: String
  organization: String
  careerStage: [String!]
  website: String
  fmCrosspostUserId: String
  linkedinProfileURL: String
  facebookProfileURL: String
  blueskyProfileURL: String
  twitterProfileURL: String
  twitterProfileURLAdmin: String
  githubProfileURL: String
  profileTagIds: [String!]
  organizerOfGroupIds: [String!]
  programParticipation: [String!]
  postingDisabled: Boolean
  allCommentingDisabled: Boolean
  commentingOnOtherUsersDisabled: Boolean
  conversationsDisabled: Boolean
  acknowledgedNewUserGuidelines: Boolean
  subforumPreferredLayout: SubforumPreferredLayout
  hideJobAdUntil: Date
  criticismTipsDismissed: Boolean
  hideFromPeopleDirectory: Boolean
  allowDatadogSessionReplay: Boolean
  reviewForAlignmentForumUserId: String
  afSubmittedApplication: Boolean
  hideSunshineSidebar: Boolean
  inactiveSurveyEmailSentAt: Date
  userSurveyEmailSentAt: Date
}

input CreateUserInput {
  data: CreateUserDataInput!
}

input UpdateUserDataInput {
  legacyData: JSON
  moderationGuidelines: CreateRevisionDataInput
  howOthersCanHelpMe: CreateRevisionDataInput
  howICanHelpOthers: CreateRevisionDataInput
  slug: String
  biography: CreateRevisionDataInput
  username: String
  isAdmin: Boolean
  displayName: String
  previousDisplayName: String
  email: String
  noindex: Boolean
  groups: [String!]
  theme: JSON
  lastUsedTimezone: String
  whenConfirmationEmailSent: Date
  legacy: Boolean
  commentSorting: String
  sortDraftsBy: String
  reactPaletteStyle: ReactPaletteStyle
  noKibitz: Boolean
  showHideKarmaOption: Boolean
  showPostAuthorCard: Boolean
  hideIntercom: Boolean
  markDownPostEditor: Boolean
  hideElicitPredictions: Boolean
  hideAFNonMemberInitialWarning: Boolean
  noSingleLineComments: Boolean
  noCollapseCommentsPosts: Boolean
  noCollapseCommentsFrontpage: Boolean
  hideCommunitySection: Boolean
  expandedFrontpageSections: ExpandedFrontpageSectionsSettingsInput
  showCommunityInRecentDiscussion: Boolean
  hidePostsRecommendations: Boolean
  petrovOptOut: Boolean
  optedOutOfSurveys: Boolean
  postGlossariesPinned: Boolean
  generateJargonForDrafts: Boolean
  generateJargonForPublishedPosts: Boolean
  acceptedTos: Boolean
  hideNavigationSidebar: Boolean
  currentFrontpageFilter: String
  frontpageSelectedTab: String
  frontpageFilterSettings: JSON
  hideFrontpageFilterSettingsDesktop: Boolean
  allPostsTimeframe: String
  allPostsFilter: String
  allPostsSorting: String
  allPostsShowLowKarma: Boolean
  allPostsIncludeEvents: Boolean
  allPostsHideCommunity: Boolean
  allPostsOpenSettings: Boolean
  draftsListSorting: String
  draftsListShowArchived: Boolean
  draftsListShowShared: Boolean
  lastNotificationsCheck: Date
  moderationStyle: String
  moderatorAssistance: Boolean
  collapseModerationGuidelines: Boolean
  bannedUserIds: [String!]
  bannedPersonalUserIds: [String!]
  hiddenPostsMetadata: [PostMetadataInput!]
  legacyId: String
  deleted: Boolean
  permanentDeletionRequestedAt: Date
  voteBanned: Boolean
  nullifyVotes: Boolean
  deleteContent: Boolean
  banned: Date
  auto_subscribe_to_my_posts: Boolean
  auto_subscribe_to_my_comments: Boolean
  autoSubscribeAsOrganizer: Boolean
  notificationCommentsOnSubscribedPost: JSON
  notificationShortformContent: JSON
  notificationRepliesToMyComments: JSON
  notificationRepliesToSubscribedComments: JSON
  notificationSubscribedUserPost: JSON
  notificationSubscribedUserComment: JSON
  notificationPostsInGroups: JSON
  notificationSubscribedTagPost: JSON
  notificationSubscribedSequencePost: JSON
  notificationPrivateMessage: JSON
  notificationSharedWithMe: JSON
  notificationAlignmentSubmissionApproved: JSON
  notificationEventInRadius: JSON
  notificationKarmaPowersGained: JSON
  notificationRSVPs: JSON
  notificationGroupAdministration: JSON
  notificationCommentsOnDraft: JSON
  notificationPostsNominatedReview: JSON
  notificationSubforumUnread: JSON
  notificationNewMention: JSON
  notificationDialogueMessages: JSON
  notificationPublishedDialogueMessages: JSON
  notificationAddedAsCoauthor: JSON
  notificationDebateCommentsOnSubscribedPost: JSON
  notificationDebateReplies: JSON
  notificationDialogueMatch: JSON
  notificationNewDialogueChecks: JSON
  notificationYourTurnMatchForm: JSON
  hideDialogueFacilitation: Boolean
  revealChecksToAdmins: Boolean
  optedInToDialogueFacilitation: Boolean
  showDialoguesList: Boolean
  showMyDialogues: Boolean
  showMatches: Boolean
  showRecommendedPartners: Boolean
  hideActiveDialogueUsers: Boolean
  karmaChangeNotifierSettings: JSON
  karmaChangeLastOpened: Date
  karmaChangeBatchStart: Date
  emailSubscribedToCurated: Boolean
  subscribedToDigest: Boolean
  subscribedToNewsletter: Boolean
  unsubscribeFromAll: Boolean
  hideSubscribePoke: Boolean
  hideMeetupsPoke: Boolean
  hideHomeRHS: Boolean
  googleLocation: JSON
  location: String
  mapLocation: JSON
  mapMarkerText: String
  nearbyEventsNotifications: Boolean
  nearbyEventsNotificationsLocation: JSON
  nearbyEventsNotificationsRadius: Float
  nearbyPeopleNotificationThreshold: Float
  hideFrontpageMap: Boolean
  hideTaggingProgressBar: Boolean
  hideFrontpageBookAd: Boolean
  hideFrontpageBook2019Ad: Boolean
  hideFrontpageBook2020Ad: Boolean
  sunshineNotes: String
  sunshineFlagged: Boolean
  needsReview: Boolean
  sunshineSnoozed: Boolean
  snoozedUntilContentCount: Float
  reviewedByUserId: String
  reviewedAt: Date
  fullName: String
  shortformFeedId: String
  viewUnreviewedComments: Boolean
  partiallyReadSequences: [PartiallyReadSequenceItemInput!]
  beta: Boolean
  reviewVotesQuadratic: Boolean
  reviewVotesQuadratic2019: Boolean
  reviewVotesQuadratic2020: Boolean
  petrovPressedButtonDate: Date
  petrovLaunchCodeDate: Date
  defaultToCKEditor: Boolean
  signUpReCaptchaRating: Float
  noExpandUnreadCommentsReview: Boolean
  abTestKey: String
  abTestOverrides: JSON
  walledGardenInvite: Boolean
  walledGardenPortalOnboarded: Boolean
  taggingDashboardCollapsed: Boolean
  usernameUnset: Boolean
  paymentEmail: String
  paymentInfo: String
  profileUpdatedAt: Date
  profileImageId: String
  jobTitle: String
  organization: String
  careerStage: [String!]
  website: String
  fmCrosspostUserId: String
  linkedinProfileURL: String
  facebookProfileURL: String
  blueskyProfileURL: String
  twitterProfileURL: String
  twitterProfileURLAdmin: String
  githubProfileURL: String
  profileTagIds: [String!]
  organizerOfGroupIds: [String!]
  programParticipation: [String!]
  postingDisabled: Boolean
  allCommentingDisabled: Boolean
  commentingOnOtherUsersDisabled: Boolean
  conversationsDisabled: Boolean
  acknowledgedNewUserGuidelines: Boolean
  subforumPreferredLayout: SubforumPreferredLayout
  hideJobAdUntil: Date
  criticismTipsDismissed: Boolean
  hideFromPeopleDirectory: Boolean
  allowDatadogSessionReplay: Boolean
  reviewForAlignmentForumUserId: String
  afApplicationText: String
  afSubmittedApplication: Boolean
  hideSunshineSidebar: Boolean
  inactiveSurveyEmailSentAt: Date
  userSurveyEmailSentAt: Date
  recommendationSettings: RecommendationSettingsInput
}

input UpdateUserInput {
  selector: SelectorInput!
  data: UpdateUserDataInput!
}

type UserOutput {
  data: User
}

extend type Mutation {
  createUser(data: CreateUserDataInput!): UserOutput
  updateUser(selector: SelectorInput!, data: UpdateUserDataInput!): UserOutput
}