# Generated file - run 'yarn generate' to update.

scalar JSON

scalar Date

type AdvisorRequest {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  interestedInMetaculus: Boolean
  jobAds: JSON
}

input DeleteAdvisorRequestInput {
  selector: AdvisorRequestSelectorUniqueInput!
}

input SingleAdvisorRequestInput {
  selector: AdvisorRequestSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiAdvisorRequestInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: AdvisorRequestSelectorInput
  orderBy: AdvisorRequestOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleAdvisorRequestOutput {
  result: AdvisorRequest
}

type MultiAdvisorRequestOutput {
  results: [AdvisorRequest]
  totalCount: Int
}

type AdvisorRequestOutput {
  data: AdvisorRequest
}

input CreateAdvisorRequestInput {
  data: CreateAdvisorRequestDataInput!
}

input CreateAdvisorRequestDataInput {
  legacyData: JSON
  userId: String!
  interestedInMetaculus: Boolean
  jobAds: JSON
}

input UpdateAdvisorRequestInput {
  selector: AdvisorRequestSelectorUniqueInput!
  data: UpdateAdvisorRequestDataInput!
}

input UpsertAdvisorRequestInput {
  selector: AdvisorRequestSelectorUniqueInput!
  data: UpdateAdvisorRequestDataInput!
}

input UpdateAdvisorRequestDataInput {
  legacyData: JSON
  userId: String
  interestedInMetaculus: Boolean
  jobAds: JSON
}

input AdvisorRequestSelectorInput {
  AND: [AdvisorRequestSelectorInput]
  OR: [AdvisorRequestSelectorInput]
}

input AdvisorRequestSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum AdvisorRequestOrderByInput {
  foobar
}

type ArbitalCaches {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteArbitalCachesInput {
  selector: ArbitalCachesSelectorUniqueInput!
}

input SingleArbitalCachesInput {
  selector: ArbitalCachesSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiArbitalCachesInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ArbitalCachesSelectorInput
  orderBy: ArbitalCachesOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleArbitalCachesOutput {
  result: ArbitalCaches
}

type MultiArbitalCachesOutput {
  results: [ArbitalCaches]
  totalCount: Int
}

type ArbitalCachesOutput {
  data: ArbitalCaches
}

input CreateArbitalCachesInput {
  data: CreateArbitalCachesDataInput!
}

input CreateArbitalCachesDataInput {
  legacyData: JSON
}

input UpdateArbitalCachesInput {
  selector: ArbitalCachesSelectorUniqueInput!
  data: UpdateArbitalCachesDataInput!
}

input UpsertArbitalCachesInput {
  selector: ArbitalCachesSelectorUniqueInput!
  data: UpdateArbitalCachesDataInput!
}

input UpdateArbitalCachesDataInput {
  legacyData: JSON
}

input ArbitalCachesSelectorInput {
  AND: [ArbitalCachesSelectorInput]
  OR: [ArbitalCachesSelectorInput]
}

input ArbitalCachesSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ArbitalCachesOrderByInput {
  foobar
}

type ArbitalTagContentRel {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  parentDocumentId: String
  childDocumentId: String
  parentCollectionName: String
  childCollectionName: String
  type: String
  level: Float
  isStrong: Boolean
}

input DeleteArbitalTagContentRelInput {
  selector: ArbitalTagContentRelSelectorUniqueInput!
}

input SingleArbitalTagContentRelInput {
  selector: ArbitalTagContentRelSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiArbitalTagContentRelInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ArbitalTagContentRelSelectorInput
  orderBy: ArbitalTagContentRelOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleArbitalTagContentRelOutput {
  result: ArbitalTagContentRel
}

type MultiArbitalTagContentRelOutput {
  results: [ArbitalTagContentRel]
  totalCount: Int
}

type ArbitalTagContentRelOutput {
  data: ArbitalTagContentRel
}

input CreateArbitalTagContentRelInput {
  data: CreateArbitalTagContentRelDataInput!
}

input CreateArbitalTagContentRelDataInput {
  legacyData: JSON
  parentDocumentId: String!
  childDocumentId: String!
  parentCollectionName: String!
  childCollectionName: String!
  type: String!
  level: Float!
  isStrong: Boolean!
}

input UpdateArbitalTagContentRelInput {
  selector: ArbitalTagContentRelSelectorUniqueInput!
  data: UpdateArbitalTagContentRelDataInput!
}

input UpsertArbitalTagContentRelInput {
  selector: ArbitalTagContentRelSelectorUniqueInput!
  data: UpdateArbitalTagContentRelDataInput!
}

input UpdateArbitalTagContentRelDataInput {
  legacyData: JSON
}

input ArbitalTagContentRelSelectorInput {
  AND: [ArbitalTagContentRelSelectorInput]
  OR: [ArbitalTagContentRelSelectorInput]
}

input ArbitalTagContentRelSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ArbitalTagContentRelOrderByInput {
  foobar
}

type Ban {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  expirationDate: Date
  userId: String
  user: User
  ip: String
  reason: String
  comment: String
  properties: JSON
}

input DeleteBanInput {
  selector: BanSelectorUniqueInput!
}

input SingleBanInput {
  selector: BanSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiBanInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: BanSelectorInput
  orderBy: BanOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleBanOutput {
  result: Ban
}

type MultiBanOutput {
  results: [Ban]
  totalCount: Int
}

type BanOutput {
  data: Ban
}

input CreateBanInput {
  data: CreateBanDataInput!
}

input CreateBanDataInput {
  legacyData: JSON
  expirationDate: Date!
  userId: String
  ip: String
  reason: String
  comment: String
  properties: JSON
}

input UpdateBanInput {
  selector: BanSelectorUniqueInput!
  data: UpdateBanDataInput!
}

input UpsertBanInput {
  selector: BanSelectorUniqueInput!
  data: UpdateBanDataInput!
}

input UpdateBanDataInput {
  legacyData: JSON
  expirationDate: Date
  userId: String
  ip: String
  reason: String
  comment: String
  properties: JSON
}

input BanSelectorInput {
  AND: [BanSelectorInput]
  OR: [BanSelectorInput]
}

input BanSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum BanOrderByInput {
  foobar
}

type Book {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  postedAt: Date
  title: String
  subtitle: String
  tocTitle: String
  collectionId: String
  number: Float
  postIds: [String]
  posts: [Post!]!
  sequenceIds: [String]
  sequences: [Sequence!]!
  displaySequencesAsGrid: Boolean
  hideProgressBar: Boolean
  showChapters: Boolean
}

input DeleteBookInput {
  selector: BookSelectorUniqueInput!
}

input SingleBookInput {
  selector: BookSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiBookInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: BookSelectorInput
  orderBy: BookOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleBookOutput {
  result: Book
}

type MultiBookOutput {
  results: [Book]
  totalCount: Int
}

type BookOutput {
  data: Book
}

input CreateBookInput {
  data: CreateBookDataInput!
}

input CreateBookDataInput {
  legacyData: JSON
  contents: JSON
  title: String
  subtitle: String
  tocTitle: String
  collectionId: String!
  number: Float
  postIds: [String]
  sequenceIds: [String]
  displaySequencesAsGrid: Boolean
  hideProgressBar: Boolean
  showChapters: Boolean
}

input UpdateBookInput {
  selector: BookSelectorUniqueInput!
  data: UpdateBookDataInput!
}

input UpsertBookInput {
  selector: BookSelectorUniqueInput!
  data: UpdateBookDataInput!
}

input UpdateBookDataInput {
  legacyData: JSON
  contents: JSON
  title: String
  subtitle: String
  tocTitle: String
  collectionId: String
  number: Float
  postIds: [String]
  sequenceIds: [String]
  displaySequencesAsGrid: Boolean
  hideProgressBar: Boolean
  showChapters: Boolean
}

input BookSelectorInput {
  AND: [BookSelectorInput]
  OR: [BookSelectorInput]
}

input BookSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum BookOrderByInput {
  foobar
}

type Chapter {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  title: String
  subtitle: String
  number: Float
  sequenceId: String
  sequence: Sequence!
  postIds: [String]
  posts: [Post!]!
}

input DeleteChapterInput {
  selector: ChapterSelectorUniqueInput!
}

input SingleChapterInput {
  selector: ChapterSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiChapterInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ChapterSelectorInput
  orderBy: ChapterOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleChapterOutput {
  result: Chapter
}

type MultiChapterOutput {
  results: [Chapter]
  totalCount: Int
}

type ChapterOutput {
  data: Chapter
}

input CreateChapterInput {
  data: CreateChapterDataInput!
}

input CreateChapterDataInput {
  legacyData: JSON
  contents: JSON
  title: String
  subtitle: String
  number: Float
  sequenceId: String
  postIds: [String]!
}

input UpdateChapterInput {
  selector: ChapterSelectorUniqueInput!
  data: UpdateChapterDataInput!
}

input UpsertChapterInput {
  selector: ChapterSelectorUniqueInput!
  data: UpdateChapterDataInput!
}

input UpdateChapterDataInput {
  legacyData: JSON
  contents: JSON
  title: String
  subtitle: String
  number: Float
  sequenceId: String
  postIds: [String]
}

input ChapterSelectorInput {
  AND: [ChapterSelectorInput]
  OR: [ChapterSelectorInput]
}

input ChapterSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ChapterOrderByInput {
  foobar
}

type CkEditorUserSession {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  documentId: String
  userId: String
  endedAt: Date
  endedBy: String
}

input DeleteCkEditorUserSessionInput {
  selector: CkEditorUserSessionSelectorUniqueInput!
}

input SingleCkEditorUserSessionInput {
  selector: CkEditorUserSessionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiCkEditorUserSessionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: CkEditorUserSessionSelectorInput
  orderBy: CkEditorUserSessionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCkEditorUserSessionOutput {
  result: CkEditorUserSession
}

type MultiCkEditorUserSessionOutput {
  results: [CkEditorUserSession]
  totalCount: Int
}

type CkEditorUserSessionOutput {
  data: CkEditorUserSession
}

input CreateCkEditorUserSessionInput {
  data: CreateCkEditorUserSessionDataInput!
}

input CreateCkEditorUserSessionDataInput {
  legacyData: JSON
  documentId: String!
  userId: String!
  endedAt: Date
  endedBy: String
}

input UpdateCkEditorUserSessionInput {
  selector: CkEditorUserSessionSelectorUniqueInput!
  data: UpdateCkEditorUserSessionDataInput!
}

input UpsertCkEditorUserSessionInput {
  selector: CkEditorUserSessionSelectorUniqueInput!
  data: UpdateCkEditorUserSessionDataInput!
}

input UpdateCkEditorUserSessionDataInput {
  legacyData: JSON
  documentId: String
  userId: String
  endedAt: Date
  endedBy: String
}

input CkEditorUserSessionSelectorInput {
  AND: [CkEditorUserSessionSelectorInput]
  OR: [CkEditorUserSessionSelectorInput]
}

input CkEditorUserSessionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum CkEditorUserSessionOrderByInput {
  foobar
}

type ClientId {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  clientId: String
  firstSeenReferrer: String
  firstSeenLandingPage: String
  userIds: [String]
  users: [User!]!
  invalidated: Boolean
  lastSeenAt: Date
  timesSeen: Float
}

input DeleteClientIdInput {
  selector: ClientIdSelectorUniqueInput!
}

input SingleClientIdInput {
  selector: ClientIdSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiClientIdInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ClientIdSelectorInput
  orderBy: ClientIdOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleClientIdOutput {
  result: ClientId
}

type MultiClientIdOutput {
  results: [ClientId]
  totalCount: Int
}

type ClientIdOutput {
  data: ClientId
}

input CreateClientIdInput {
  data: CreateClientIdDataInput!
}

input CreateClientIdDataInput {
  legacyData: JSON
}

input UpdateClientIdInput {
  selector: ClientIdSelectorUniqueInput!
  data: UpdateClientIdDataInput!
}

input UpsertClientIdInput {
  selector: ClientIdSelectorUniqueInput!
  data: UpdateClientIdDataInput!
}

input UpdateClientIdDataInput {
  legacyData: JSON
}

input ClientIdSelectorInput {
  AND: [ClientIdSelectorInput]
  OR: [ClientIdSelectorInput]
}

input ClientIdSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ClientIdOrderByInput {
  foobar
}

type Collection {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  userId: String
  user: User
  title: String
  slug: String
  books: [Book]
  postsCount: Int!
  readPostsCount: Int!
  gridImageId: String
  firstPageLink: String
  hideStartReadingButton: Boolean
  noindex: Boolean
}

input DeleteCollectionInput {
  selector: CollectionSelectorUniqueInput!
}

input SingleCollectionInput {
  selector: CollectionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiCollectionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: CollectionSelectorInput
  orderBy: CollectionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCollectionOutput {
  result: Collection
}

type MultiCollectionOutput {
  results: [Collection]
  totalCount: Int
}

type CollectionOutput {
  data: Collection
}

input CreateCollectionInput {
  data: CreateCollectionDataInput!
}

input CreateCollectionDataInput {
  createdAt: Date
  legacyData: JSON
  contents: JSON
  title: String!
  slug: String!
  gridImageId: String
  firstPageLink: String
  hideStartReadingButton: Boolean
  noindex: Boolean
}

input UpdateCollectionInput {
  selector: CollectionSelectorUniqueInput!
  data: UpdateCollectionDataInput!
}

input UpsertCollectionInput {
  selector: CollectionSelectorUniqueInput!
  data: UpdateCollectionDataInput!
}

input UpdateCollectionDataInput {
  createdAt: Date
  legacyData: JSON
  contents: JSON
  title: String
  slug: String
  gridImageId: String
  firstPageLink: String
  hideStartReadingButton: Boolean
  noindex: Boolean
}

input CollectionSelectorInput {
  AND: [CollectionSelectorInput]
  OR: [CollectionSelectorInput]
}

input CollectionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum CollectionOrderByInput {
  foobar
}

type CommentModeratorAction {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  commentId: String
  comment: Comment!
  type: String
  endedAt: Date
  active: Boolean!
}

input DeleteCommentModeratorActionInput {
  selector: CommentModeratorActionSelectorUniqueInput!
}

input SingleCommentModeratorActionInput {
  selector: CommentModeratorActionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiCommentModeratorActionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: CommentModeratorActionSelectorInput
  orderBy: CommentModeratorActionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCommentModeratorActionOutput {
  result: CommentModeratorAction
}

type MultiCommentModeratorActionOutput {
  results: [CommentModeratorAction]
  totalCount: Int
}

type CommentModeratorActionOutput {
  data: CommentModeratorAction
}

input CreateCommentModeratorActionInput {
  data: CreateCommentModeratorActionDataInput!
}

input CreateCommentModeratorActionDataInput {
  legacyData: JSON
  commentId: String
  type: String!
  endedAt: Date
}

input UpdateCommentModeratorActionInput {
  selector: CommentModeratorActionSelectorUniqueInput!
  data: UpdateCommentModeratorActionDataInput!
}

input UpsertCommentModeratorActionInput {
  selector: CommentModeratorActionSelectorUniqueInput!
  data: UpdateCommentModeratorActionDataInput!
}

input UpdateCommentModeratorActionDataInput {
  legacyData: JSON
  commentId: String
  type: String
  endedAt: Date
}

input CommentModeratorActionSelectorInput {
  AND: [CommentModeratorActionSelectorInput]
  OR: [CommentModeratorActionSelectorInput]
}

input CommentModeratorActionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum CommentModeratorActionOrderByInput {
  foobar
}

type Comment {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  pingbacks: JSON
  parentCommentId: String
  parentComment: Comment
  topLevelCommentId: String
  topLevelComment: Comment
  postedAt: Date
  lastEditedAt: Date
  author: String
  postId: String
  post: Post
  tagId: String
  tag: Tag
  forumEventId: String
  forumEvent: ForumEvent
  forumEventMetadata: JSON
  tagCommentType: String
  subforumStickyPriority: Float
  userId: String
  user: User
  userIP: String
  userAgent: String
  referrer: String
  authorIsUnreviewed: Boolean
  pageUrl: String
  pageUrlRelative: String
  answer: Boolean
  parentAnswerId: String
  parentAnswer: Comment
  directChildrenCount: Float
  descendentCount: Float
  latestChildren: [Comment]
  shortform: Boolean
  shortformFrontpage: Boolean
  nominatedForReview: String
  reviewingForReview: String
  lastSubthreadActivity: Date
  postVersion: String
  promoted: Boolean
  promotedByUserId: String
  promotedByUser: User
  promotedAt: Date
  hideKarma: Boolean
  wordCount: Int
  htmlBody: String
  votingSystem: String!
  legacy: Boolean
  legacyId: String
  legacyPoll: Boolean
  legacyParentId: String
  retracted: Boolean
  deleted: Boolean
  deletedPublic: Boolean
  deletedReason: String
  deletedDate: Date
  deletedByUserId: String
  deletedByUser: User
  spam: Boolean
  repliesBlockedUntil: Date
  needsReview: Boolean
  reviewedByUserId: String
  reviewedByUser: User
  hideAuthor: Boolean
  moderatorHat: Boolean
  hideModeratorHat: Boolean
  isPinnedOnProfile: Boolean
  title: String
  relevantTagIds: [String]
  relevantTags: [Tag!]!
  debateResponse: Boolean
  rejected: Boolean
  modGPTAnalysis: String
  modGPTRecommendation: String
  rejectedReason: String
  rejectedByUserId: String
  rejectedByUser: User
  emojiReactors: JSON
  af: Boolean
  suggestForAlignmentUserIds: [String]
  suggestForAlignmentUsers: [User!]!
  reviewForAlignmentUserId: String
  afDate: Date
  moveToAlignmentUserId: String
  moveToAlignmentUser: User
  agentFoundationsId: String
  originalDialogueId: String
  originalDialogue: Post
  currentUserVote: String
  currentUserExtendedVote: JSON
  allVotes: [Vote]
  voteCount: Float
  baseScore: Float
  extendedScore: JSON
  score: Float
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input DeleteCommentInput {
  selector: CommentSelectorUniqueInput!
}

input SingleCommentInput {
  selector: CommentSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiCommentInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: CommentSelectorInput
  orderBy: CommentOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCommentOutput {
  result: Comment
}

type MultiCommentOutput {
  results: [Comment]
  totalCount: Int
}

type CommentOutput {
  data: Comment
}

input CreateCommentInput {
  data: CreateCommentDataInput!
}

input CreateCommentDataInput {
  legacyData: JSON
  contents: JSON
  parentCommentId: String
  topLevelCommentId: String
  postId: String
  tagId: String
  forumEventId: String
  forumEventMetadata: JSON
  tagCommentType: String
  subforumStickyPriority: Float
  userId: String
  authorIsUnreviewed: Boolean
  answer: Boolean
  parentAnswerId: String
  shortform: Boolean
  shortformFrontpage: Boolean
  nominatedForReview: String
  reviewingForReview: String
  promotedByUserId: String
  hideKarma: Boolean
  legacy: Boolean
  legacyId: String
  legacyPoll: Boolean
  legacyParentId: String
  retracted: Boolean
  deleted: Boolean
  deletedPublic: Boolean
  deletedReason: String
  deletedDate: Date
  deletedByUserId: String
  spam: Boolean
  needsReview: Boolean
  reviewedByUserId: String
  moderatorHat: Boolean
  hideModeratorHat: Boolean
  isPinnedOnProfile: Boolean
  title: String
  relevantTagIds: [String]
  debateResponse: Boolean
  rejected: Boolean
  modGPTAnalysis: String
  modGPTRecommendation: String
  rejectedReason: String
  rejectedByUserId: String
  af: Boolean
  afDate: Date
  agentFoundationsId: String
  originalDialogueId: String
}

input UpdateCommentInput {
  selector: CommentSelectorUniqueInput!
  data: UpdateCommentDataInput!
}

input UpsertCommentInput {
  selector: CommentSelectorUniqueInput!
  data: UpdateCommentDataInput!
}

input UpdateCommentDataInput {
  legacyData: JSON
  contents: JSON
  subforumStickyPriority: Float
  authorIsUnreviewed: Boolean
  answer: Boolean
  shortform: Boolean
  shortformFrontpage: Boolean
  nominatedForReview: String
  reviewingForReview: String
  promoted: Boolean
  promotedByUserId: String
  hideKarma: Boolean
  legacy: Boolean
  legacyId: String
  legacyPoll: Boolean
  legacyParentId: String
  retracted: Boolean
  deleted: Boolean
  deletedPublic: Boolean
  deletedReason: String
  deletedDate: Date
  deletedByUserId: String
  spam: Boolean
  repliesBlockedUntil: Date
  needsReview: Boolean
  reviewedByUserId: String
  hideAuthor: Boolean
  moderatorHat: Boolean
  hideModeratorHat: Boolean
  isPinnedOnProfile: Boolean
  title: String
  relevantTagIds: [String]
  debateResponse: Boolean
  rejected: Boolean
  modGPTAnalysis: String
  modGPTRecommendation: String
  rejectedReason: String
  rejectedByUserId: String
  af: Boolean
  suggestForAlignmentUserIds: [String]
  reviewForAlignmentUserId: String
  afDate: Date
  moveToAlignmentUserId: String
  agentFoundationsId: String
  originalDialogueId: String
}

input CommentSelectorInput {
  AND: [CommentSelectorInput]
  OR: [CommentSelectorInput]
}

input CommentSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum CommentOrderByInput {
  foobar
}

type Conversation {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  title: String
  participantIds: [String]
  participants: [User!]!
  latestActivity: Date
  af: Boolean
  messageCount: Float
  moderator: Boolean
  archivedByIds: [String]
  archivedBy: [User!]!
  latestMessage: Message
  hasUnreadMessages: Boolean
}

input DeleteConversationInput {
  selector: ConversationSelectorUniqueInput!
}

input SingleConversationInput {
  selector: ConversationSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiConversationInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ConversationSelectorInput
  orderBy: ConversationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleConversationOutput {
  result: Conversation
}

type MultiConversationOutput {
  results: [Conversation]
  totalCount: Int
}

type ConversationOutput {
  data: Conversation
}

input CreateConversationInput {
  data: CreateConversationDataInput!
}

input CreateConversationDataInput {
  legacyData: JSON
  title: String
  participantIds: [String]
  af: Boolean
  moderator: Boolean
  archivedByIds: [String]
}

input UpdateConversationInput {
  selector: ConversationSelectorUniqueInput!
  data: UpdateConversationDataInput!
}

input UpsertConversationInput {
  selector: ConversationSelectorUniqueInput!
  data: UpdateConversationDataInput!
}

input UpdateConversationDataInput {
  legacyData: JSON
  title: String
  participantIds: [String]
  af: Boolean
  moderator: Boolean
  archivedByIds: [String]
}

input ConversationSelectorInput {
  AND: [ConversationSelectorInput]
  OR: [ConversationSelectorInput]
}

input ConversationSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ConversationOrderByInput {
  foobar
}

type CronHistory {
  _id: String
  intendedAt: Date
  name: String
  startedAt: Date
  finishedAt: Date
  result: JSON
}

input DeleteCronHistoryInput {
  selector: CronHistorySelectorUniqueInput!
}

input SingleCronHistoryInput {
  selector: CronHistorySelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiCronHistoryInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: CronHistorySelectorInput
  orderBy: CronHistoryOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCronHistoryOutput {
  result: CronHistory
}

type MultiCronHistoryOutput {
  results: [CronHistory]
  totalCount: Int
}

type CronHistoryOutput {
  data: CronHistory
}

input CreateCronHistoryInput {
  data: CreateCronHistoryDataInput!
}

input CreateCronHistoryDataInput {
  _id: String!
  intendedAt: Date!
  name: String!
  startedAt: Date!
  finishedAt: Date
  result: JSON
}

input UpdateCronHistoryInput {
  selector: CronHistorySelectorUniqueInput!
  data: UpdateCronHistoryDataInput!
}

input UpsertCronHistoryInput {
  selector: CronHistorySelectorUniqueInput!
  data: UpdateCronHistoryDataInput!
}

input UpdateCronHistoryDataInput {
  _id: String
  intendedAt: Date
  name: String
  startedAt: Date
  finishedAt: Date
  result: JSON
}

input CronHistorySelectorInput {
  AND: [CronHistorySelectorInput]
  OR: [CronHistorySelectorInput]
}

input CronHistorySelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum CronHistoryOrderByInput {
  foobar
}

type CurationEmail {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  postId: String
}

input DeleteCurationEmailInput {
  selector: CurationEmailSelectorUniqueInput!
}

input SingleCurationEmailInput {
  selector: CurationEmailSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiCurationEmailInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: CurationEmailSelectorInput
  orderBy: CurationEmailOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCurationEmailOutput {
  result: CurationEmail
}

type MultiCurationEmailOutput {
  results: [CurationEmail]
  totalCount: Int
}

type CurationEmailOutput {
  data: CurationEmail
}

input CreateCurationEmailInput {
  data: CreateCurationEmailDataInput!
}

input CreateCurationEmailDataInput {
  legacyData: JSON
  userId: String!
  postId: String!
}

input UpdateCurationEmailInput {
  selector: CurationEmailSelectorUniqueInput!
  data: UpdateCurationEmailDataInput!
}

input UpsertCurationEmailInput {
  selector: CurationEmailSelectorUniqueInput!
  data: UpdateCurationEmailDataInput!
}

input UpdateCurationEmailDataInput {
  legacyData: JSON
  userId: String
  postId: String
}

input CurationEmailSelectorInput {
  AND: [CurationEmailSelectorInput]
  OR: [CurationEmailSelectorInput]
}

input CurationEmailSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum CurationEmailOrderByInput {
  foobar
}

type CurationNotice {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  userId: String
  user: User
  commentId: String
  comment: Comment
  postId: String
  post: Post
  deleted: Boolean
}

input DeleteCurationNoticeInput {
  selector: CurationNoticeSelectorUniqueInput!
}

input SingleCurationNoticeInput {
  selector: CurationNoticeSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiCurationNoticeInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: CurationNoticeSelectorInput
  orderBy: CurationNoticeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCurationNoticeOutput {
  result: CurationNotice
}

type MultiCurationNoticeOutput {
  results: [CurationNotice]
  totalCount: Int
}

type CurationNoticeOutput {
  data: CurationNotice
}

input CreateCurationNoticeInput {
  data: CreateCurationNoticeDataInput!
}

input CreateCurationNoticeDataInput {
  legacyData: JSON
  contents: JSON
  userId: String!
  commentId: String
  postId: String!
}

input UpdateCurationNoticeInput {
  selector: CurationNoticeSelectorUniqueInput!
  data: UpdateCurationNoticeDataInput!
}

input UpsertCurationNoticeInput {
  selector: CurationNoticeSelectorUniqueInput!
  data: UpdateCurationNoticeDataInput!
}

input UpdateCurationNoticeDataInput {
  legacyData: JSON
  contents: JSON
  commentId: String
  deleted: Boolean
}

input CurationNoticeSelectorInput {
  AND: [CurationNoticeSelectorInput]
  OR: [CurationNoticeSelectorInput]
}

input CurationNoticeSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum CurationNoticeOrderByInput {
  foobar
}

type DatabaseMetadata {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteDatabaseMetadataInput {
  selector: DatabaseMetadataSelectorUniqueInput!
}

input SingleDatabaseMetadataInput {
  selector: DatabaseMetadataSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiDatabaseMetadataInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: DatabaseMetadataSelectorInput
  orderBy: DatabaseMetadataOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDatabaseMetadataOutput {
  result: DatabaseMetadata
}

type MultiDatabaseMetadataOutput {
  results: [DatabaseMetadata]
  totalCount: Int
}

type DatabaseMetadataOutput {
  data: DatabaseMetadata
}

input CreateDatabaseMetadataInput {
  data: CreateDatabaseMetadataDataInput!
}

input CreateDatabaseMetadataDataInput {
  legacyData: JSON
}

input UpdateDatabaseMetadataInput {
  selector: DatabaseMetadataSelectorUniqueInput!
  data: UpdateDatabaseMetadataDataInput!
}

input UpsertDatabaseMetadataInput {
  selector: DatabaseMetadataSelectorUniqueInput!
  data: UpdateDatabaseMetadataDataInput!
}

input UpdateDatabaseMetadataDataInput {
  legacyData: JSON
}

input DatabaseMetadataSelectorInput {
  AND: [DatabaseMetadataSelectorInput]
  OR: [DatabaseMetadataSelectorInput]
}

input DatabaseMetadataSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum DatabaseMetadataOrderByInput {
  foobar
}

type DebouncerEvents {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteDebouncerEventsInput {
  selector: DebouncerEventsSelectorUniqueInput!
}

input SingleDebouncerEventsInput {
  selector: DebouncerEventsSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiDebouncerEventsInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: DebouncerEventsSelectorInput
  orderBy: DebouncerEventsOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDebouncerEventsOutput {
  result: DebouncerEvents
}

type MultiDebouncerEventsOutput {
  results: [DebouncerEvents]
  totalCount: Int
}

type DebouncerEventsOutput {
  data: DebouncerEvents
}

input CreateDebouncerEventsInput {
  data: CreateDebouncerEventsDataInput!
}

input CreateDebouncerEventsDataInput {
  legacyData: JSON
}

input UpdateDebouncerEventsInput {
  selector: DebouncerEventsSelectorUniqueInput!
  data: UpdateDebouncerEventsDataInput!
}

input UpsertDebouncerEventsInput {
  selector: DebouncerEventsSelectorUniqueInput!
  data: UpdateDebouncerEventsDataInput!
}

input UpdateDebouncerEventsDataInput {
  legacyData: JSON
}

input DebouncerEventsSelectorInput {
  AND: [DebouncerEventsSelectorInput]
  OR: [DebouncerEventsSelectorInput]
}

input DebouncerEventsSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum DebouncerEventsOrderByInput {
  foobar
}

type DialogueCheck {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  targetUserId: String
  checked: Boolean
  checkedAt: Date
  hideInRecommendations: Boolean
  matchPreference: DialogueMatchPreference
  reciprocalMatchPreference: DialogueMatchPreference
}

input DeleteDialogueCheckInput {
  selector: DialogueCheckSelectorUniqueInput!
}

input SingleDialogueCheckInput {
  selector: DialogueCheckSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiDialogueCheckInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: DialogueCheckSelectorInput
  orderBy: DialogueCheckOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDialogueCheckOutput {
  result: DialogueCheck
}

type MultiDialogueCheckOutput {
  results: [DialogueCheck]
  totalCount: Int
}

type DialogueCheckOutput {
  data: DialogueCheck
}

input CreateDialogueCheckInput {
  data: CreateDialogueCheckDataInput!
}

input CreateDialogueCheckDataInput {
  legacyData: JSON
  userId: String!
  targetUserId: String!
  checked: Boolean!
  checkedAt: Date!
  hideInRecommendations: Boolean!
}

input UpdateDialogueCheckInput {
  selector: DialogueCheckSelectorUniqueInput!
  data: UpdateDialogueCheckDataInput!
}

input UpsertDialogueCheckInput {
  selector: DialogueCheckSelectorUniqueInput!
  data: UpdateDialogueCheckDataInput!
}

input UpdateDialogueCheckDataInput {
  legacyData: JSON
}

input DialogueCheckSelectorInput {
  AND: [DialogueCheckSelectorInput]
  OR: [DialogueCheckSelectorInput]
}

input DialogueCheckSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum DialogueCheckOrderByInput {
  foobar
}

type DialogueMatchPreference {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  dialogueCheckId: String
  dialogueCheck: DialogueCheck
  topicPreferences: [JSON]
  topicNotes: String
  syncPreference: String
  asyncPreference: String
  formatNotes: String
  calendlyLink: String
  generatedDialogueId: String
  deleted: Boolean
}

input DeleteDialogueMatchPreferenceInput {
  selector: DialogueMatchPreferenceSelectorUniqueInput!
}

input SingleDialogueMatchPreferenceInput {
  selector: DialogueMatchPreferenceSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiDialogueMatchPreferenceInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: DialogueMatchPreferenceSelectorInput
  orderBy: DialogueMatchPreferenceOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDialogueMatchPreferenceOutput {
  result: DialogueMatchPreference
}

type MultiDialogueMatchPreferenceOutput {
  results: [DialogueMatchPreference]
  totalCount: Int
}

type DialogueMatchPreferenceOutput {
  data: DialogueMatchPreference
}

input CreateDialogueMatchPreferenceInput {
  data: CreateDialogueMatchPreferenceDataInput!
}

input CreateDialogueMatchPreferenceDataInput {
  legacyData: JSON
  dialogueCheckId: String!
  topicPreferences: [JSON]!
  topicNotes: String!
  syncPreference: String!
  asyncPreference: String!
  formatNotes: String!
  calendlyLink: String
  generatedDialogueId: String
  deleted: Boolean
}

input UpdateDialogueMatchPreferenceInput {
  selector: DialogueMatchPreferenceSelectorUniqueInput!
  data: UpdateDialogueMatchPreferenceDataInput!
}

input UpsertDialogueMatchPreferenceInput {
  selector: DialogueMatchPreferenceSelectorUniqueInput!
  data: UpdateDialogueMatchPreferenceDataInput!
}

input UpdateDialogueMatchPreferenceDataInput {
  legacyData: JSON
  dialogueCheckId: String
  topicPreferences: [JSON]
  topicNotes: String
  syncPreference: String
  asyncPreference: String
  formatNotes: String
  calendlyLink: String
  generatedDialogueId: String
  deleted: Boolean
}

input DialogueMatchPreferenceSelectorInput {
  AND: [DialogueMatchPreferenceSelectorInput]
  OR: [DialogueMatchPreferenceSelectorInput]
}

input DialogueMatchPreferenceSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum DialogueMatchPreferenceOrderByInput {
  foobar
}

type DigestPost {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  digestId: String
  digest: Digest!
  postId: String
  post: Post!
  emailDigestStatus: String
  onsiteDigestStatus: String
}

input DeleteDigestPostInput {
  selector: DigestPostSelectorUniqueInput!
}

input SingleDigestPostInput {
  selector: DigestPostSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiDigestPostInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: DigestPostSelectorInput
  orderBy: DigestPostOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDigestPostOutput {
  result: DigestPost
}

type MultiDigestPostOutput {
  results: [DigestPost]
  totalCount: Int
}

type DigestPostOutput {
  data: DigestPost
}

input CreateDigestPostInput {
  data: CreateDigestPostDataInput!
}

input CreateDigestPostDataInput {
  legacyData: JSON
  digestId: String!
  postId: String!
  emailDigestStatus: String
  onsiteDigestStatus: String
}

input UpdateDigestPostInput {
  selector: DigestPostSelectorUniqueInput!
  data: UpdateDigestPostDataInput!
}

input UpsertDigestPostInput {
  selector: DigestPostSelectorUniqueInput!
  data: UpdateDigestPostDataInput!
}

input UpdateDigestPostDataInput {
  legacyData: JSON
  digestId: String
  postId: String
  emailDigestStatus: String
  onsiteDigestStatus: String
}

input DigestPostSelectorInput {
  AND: [DigestPostSelectorInput]
  OR: [DigestPostSelectorInput]
}

input DigestPostSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum DigestPostOrderByInput {
  foobar
}

type Digest {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  num: Float
  startDate: Date
  endDate: Date
  publishedDate: Date
  onsiteImageId: String
  onsitePrimaryColor: String
}

input DeleteDigestInput {
  selector: DigestSelectorUniqueInput!
}

input SingleDigestInput {
  selector: DigestSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiDigestInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: DigestSelectorInput
  orderBy: DigestOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDigestOutput {
  result: Digest
}

type MultiDigestOutput {
  results: [Digest]
  totalCount: Int
}

type DigestOutput {
  data: Digest
}

input CreateDigestInput {
  data: CreateDigestDataInput!
}

input CreateDigestDataInput {
  legacyData: JSON
  num: Float!
  startDate: Date!
  endDate: Date
  publishedDate: Date
  onsiteImageId: String
  onsitePrimaryColor: String
}

input UpdateDigestInput {
  selector: DigestSelectorUniqueInput!
  data: UpdateDigestDataInput!
}

input UpsertDigestInput {
  selector: DigestSelectorUniqueInput!
  data: UpdateDigestDataInput!
}

input UpdateDigestDataInput {
  legacyData: JSON
  num: Float
  startDate: Date
  endDate: Date
  publishedDate: Date
  onsiteImageId: String
  onsitePrimaryColor: String
}

input DigestSelectorInput {
  AND: [DigestSelectorInput]
  OR: [DigestSelectorInput]
}

input DigestSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum DigestOrderByInput {
  foobar
}

type ElectionCandidate {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  electionName: String
  name: String
  logoSrc: String
  href: String
  fundraiserLink: String
  gwwcLink: String
  gwwcId: String
  description: String
  userId: String
  user: User
  postCount: Float
  tagId: String
  tag: Tag
  isElectionFundraiser: Boolean
  amountRaised: Float
  targetAmount: Float
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float
  baseScore: Float
  extendedScore: JSON
  score: Float
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input DeleteElectionCandidateInput {
  selector: ElectionCandidateSelectorUniqueInput!
}

input SingleElectionCandidateInput {
  selector: ElectionCandidateSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiElectionCandidateInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ElectionCandidateSelectorInput
  orderBy: ElectionCandidateOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleElectionCandidateOutput {
  result: ElectionCandidate
}

type MultiElectionCandidateOutput {
  results: [ElectionCandidate]
  totalCount: Int
}

type ElectionCandidateOutput {
  data: ElectionCandidate
}

input CreateElectionCandidateInput {
  data: CreateElectionCandidateDataInput!
}

input CreateElectionCandidateDataInput {
  legacyData: JSON
  electionName: String!
  name: String!
  logoSrc: String!
  href: String!
  fundraiserLink: String
  gwwcLink: String
  gwwcId: String
  description: String!
  userId: String
  tagId: String!
  isElectionFundraiser: Boolean
  amountRaised: Float
  targetAmount: Float
}

input UpdateElectionCandidateInput {
  selector: ElectionCandidateSelectorUniqueInput!
  data: UpdateElectionCandidateDataInput!
}

input UpsertElectionCandidateInput {
  selector: ElectionCandidateSelectorUniqueInput!
  data: UpdateElectionCandidateDataInput!
}

input UpdateElectionCandidateDataInput {
  legacyData: JSON
  electionName: String
  name: String
  logoSrc: String
  href: String
  fundraiserLink: String
  gwwcLink: String
  gwwcId: String
  description: String
  userId: String
  tagId: String
  isElectionFundraiser: Boolean
  amountRaised: Float
  targetAmount: Float
}

input ElectionCandidateSelectorInput {
  AND: [ElectionCandidateSelectorInput]
  OR: [ElectionCandidateSelectorInput]
}

input ElectionCandidateSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ElectionCandidateOrderByInput {
  foobar
}

type ElectionVote {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  electionName: String
  userId: String
  user: User!
  compareState: JSON
  vote: JSON
  submittedAt: Date
  submissionComments: JSON
  userExplanation: String
  userOtherComments: String
}

input DeleteElectionVoteInput {
  selector: ElectionVoteSelectorUniqueInput!
}

input SingleElectionVoteInput {
  selector: ElectionVoteSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiElectionVoteInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ElectionVoteSelectorInput
  orderBy: ElectionVoteOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleElectionVoteOutput {
  result: ElectionVote
}

type MultiElectionVoteOutput {
  results: [ElectionVote]
  totalCount: Int
}

type ElectionVoteOutput {
  data: ElectionVote
}

input CreateElectionVoteInput {
  data: CreateElectionVoteDataInput!
}

input CreateElectionVoteDataInput {
  legacyData: JSON
  electionName: String!
  userId: String!
  compareState: JSON
  vote: JSON
  submittedAt: Date
  submissionComments: JSON
  userExplanation: String
  userOtherComments: String
}

input UpdateElectionVoteInput {
  selector: ElectionVoteSelectorUniqueInput!
  data: UpdateElectionVoteDataInput!
}

input UpsertElectionVoteInput {
  selector: ElectionVoteSelectorUniqueInput!
  data: UpdateElectionVoteDataInput!
}

input UpdateElectionVoteDataInput {
  legacyData: JSON
  electionName: String
  userId: String
  compareState: JSON
  vote: JSON
  submittedAt: Date
  submissionComments: JSON
  userExplanation: String
  userOtherComments: String
}

input ElectionVoteSelectorInput {
  AND: [ElectionVoteSelectorInput]
  OR: [ElectionVoteSelectorInput]
}

input ElectionVoteSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ElectionVoteOrderByInput {
  foobar
}

type ElicitQuestionPrediction {
  _id: String
  predictionId: String
  prediction: Float
  createdAt: Date
  notes: String
  creator: JSON
  userId: String
  user: User
  sourceUrl: String
  sourceId: String
  binaryQuestionId: String
  question: ElicitQuestion!
  isDeleted: Boolean
}

input DeleteElicitQuestionPredictionInput {
  selector: ElicitQuestionPredictionSelectorUniqueInput!
}

input SingleElicitQuestionPredictionInput {
  selector: ElicitQuestionPredictionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiElicitQuestionPredictionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ElicitQuestionPredictionSelectorInput
  orderBy: ElicitQuestionPredictionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleElicitQuestionPredictionOutput {
  result: ElicitQuestionPrediction
}

type MultiElicitQuestionPredictionOutput {
  results: [ElicitQuestionPrediction]
  totalCount: Int
}

type ElicitQuestionPredictionOutput {
  data: ElicitQuestionPrediction
}

input CreateElicitQuestionPredictionInput {
  data: CreateElicitQuestionPredictionDataInput!
}

input CreateElicitQuestionPredictionDataInput {
  _id: String!
  prediction: Float
  createdAt: Date!
  notes: String
  creator: JSON!
  userId: String
  sourceUrl: String
  sourceId: String
  binaryQuestionId: String!
  isDeleted: Boolean!
}

input UpdateElicitQuestionPredictionInput {
  selector: ElicitQuestionPredictionSelectorUniqueInput!
  data: UpdateElicitQuestionPredictionDataInput!
}

input UpsertElicitQuestionPredictionInput {
  selector: ElicitQuestionPredictionSelectorUniqueInput!
  data: UpdateElicitQuestionPredictionDataInput!
}

input UpdateElicitQuestionPredictionDataInput {
  _id: String
  prediction: Float
  createdAt: Date
  notes: String
  creator: JSON
  userId: String
  sourceUrl: String
  sourceId: String
  binaryQuestionId: String
  isDeleted: Boolean
}

input ElicitQuestionPredictionSelectorInput {
  AND: [ElicitQuestionPredictionSelectorInput]
  OR: [ElicitQuestionPredictionSelectorInput]
}

input ElicitQuestionPredictionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ElicitQuestionPredictionOrderByInput {
  foobar
}

type ElicitQuestion {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  title: String
  notes: String
  resolution: String
  resolvesBy: Date
}

input DeleteElicitQuestionInput {
  selector: ElicitQuestionSelectorUniqueInput!
}

input SingleElicitQuestionInput {
  selector: ElicitQuestionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiElicitQuestionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ElicitQuestionSelectorInput
  orderBy: ElicitQuestionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleElicitQuestionOutput {
  result: ElicitQuestion
}

type MultiElicitQuestionOutput {
  results: [ElicitQuestion]
  totalCount: Int
}

type ElicitQuestionOutput {
  data: ElicitQuestion
}

input CreateElicitQuestionInput {
  data: CreateElicitQuestionDataInput!
}

input CreateElicitQuestionDataInput {
  legacyData: JSON
  title: String!
  notes: String
  resolution: String
  resolvesBy: Date
}

input UpdateElicitQuestionInput {
  selector: ElicitQuestionSelectorUniqueInput!
  data: UpdateElicitQuestionDataInput!
}

input UpsertElicitQuestionInput {
  selector: ElicitQuestionSelectorUniqueInput!
  data: UpdateElicitQuestionDataInput!
}

input UpdateElicitQuestionDataInput {
  legacyData: JSON
  title: String
  notes: String
  resolution: String
  resolvesBy: Date
}

input ElicitQuestionSelectorInput {
  AND: [ElicitQuestionSelectorInput]
  OR: [ElicitQuestionSelectorInput]
}

input ElicitQuestionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ElicitQuestionOrderByInput {
  foobar
}

type EmailTokens {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteEmailTokensInput {
  selector: EmailTokensSelectorUniqueInput!
}

input SingleEmailTokensInput {
  selector: EmailTokensSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiEmailTokensInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: EmailTokensSelectorInput
  orderBy: EmailTokensOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleEmailTokensOutput {
  result: EmailTokens
}

type MultiEmailTokensOutput {
  results: [EmailTokens]
  totalCount: Int
}

type EmailTokensOutput {
  data: EmailTokens
}

input CreateEmailTokensInput {
  data: CreateEmailTokensDataInput!
}

input CreateEmailTokensDataInput {
  legacyData: JSON
}

input UpdateEmailTokensInput {
  selector: EmailTokensSelectorUniqueInput!
  data: UpdateEmailTokensDataInput!
}

input UpsertEmailTokensInput {
  selector: EmailTokensSelectorUniqueInput!
  data: UpdateEmailTokensDataInput!
}

input UpdateEmailTokensDataInput {
  legacyData: JSON
}

input EmailTokensSelectorInput {
  AND: [EmailTokensSelectorInput]
  OR: [EmailTokensSelectorInput]
}

input EmailTokensSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum EmailTokensOrderByInput {
  foobar
}

type FeaturedResource {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  title: String
  body: String
  ctaText: String
  ctaUrl: String
  expiresAt: Date
}

input DeleteFeaturedResourceInput {
  selector: FeaturedResourceSelectorUniqueInput!
}

input SingleFeaturedResourceInput {
  selector: FeaturedResourceSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiFeaturedResourceInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: FeaturedResourceSelectorInput
  orderBy: FeaturedResourceOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleFeaturedResourceOutput {
  result: FeaturedResource
}

type MultiFeaturedResourceOutput {
  results: [FeaturedResource]
  totalCount: Int
}

type FeaturedResourceOutput {
  data: FeaturedResource
}

input CreateFeaturedResourceInput {
  data: CreateFeaturedResourceDataInput!
}

input CreateFeaturedResourceDataInput {
  legacyData: JSON
  title: String!
  body: String!
  ctaText: String!
  ctaUrl: String!
  expiresAt: Date
}

input UpdateFeaturedResourceInput {
  selector: FeaturedResourceSelectorUniqueInput!
  data: UpdateFeaturedResourceDataInput!
}

input UpsertFeaturedResourceInput {
  selector: FeaturedResourceSelectorUniqueInput!
  data: UpdateFeaturedResourceDataInput!
}

input UpdateFeaturedResourceDataInput {
  legacyData: JSON
  title: String
  body: String
  ctaText: String
  ctaUrl: String
  expiresAt: Date
}

input FeaturedResourceSelectorInput {
  AND: [FeaturedResourceSelectorInput]
  OR: [FeaturedResourceSelectorInput]
}

input FeaturedResourceSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum FeaturedResourceOrderByInput {
  foobar
}

type FieldChange {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  changeGroup: String
  documentId: String
  fieldName: String
  oldValue: JSON
  newValue: JSON
}

input DeleteFieldChangeInput {
  selector: FieldChangeSelectorUniqueInput!
}

input SingleFieldChangeInput {
  selector: FieldChangeSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiFieldChangeInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: FieldChangeSelectorInput
  orderBy: FieldChangeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleFieldChangeOutput {
  result: FieldChange
}

type MultiFieldChangeOutput {
  results: [FieldChange]
  totalCount: Int
}

type FieldChangeOutput {
  data: FieldChange
}

input CreateFieldChangeInput {
  data: CreateFieldChangeDataInput!
}

input CreateFieldChangeDataInput {
  legacyData: JSON
}

input UpdateFieldChangeInput {
  selector: FieldChangeSelectorUniqueInput!
  data: UpdateFieldChangeDataInput!
}

input UpsertFieldChangeInput {
  selector: FieldChangeSelectorUniqueInput!
  data: UpdateFieldChangeDataInput!
}

input UpdateFieldChangeDataInput {
  legacyData: JSON
}

input FieldChangeSelectorInput {
  AND: [FieldChangeSelectorInput]
  OR: [FieldChangeSelectorInput]
}

input FieldChangeSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum FieldChangeOrderByInput {
  foobar
}

type ForumEvent {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  frontpageDescription(version: String): Revision
  frontpageDescription_latest: String
  frontpageDescriptionMobile(version: String): Revision
  frontpageDescriptionMobile_latest: String
  postPageDescription(version: String): Revision
  postPageDescription_latest: String
  title: String
  startDate: Date
  endDate: Date
  darkColor: String
  lightColor: String
  bannerTextColor: String
  contrastColor: String
  tagId: String
  tag: Tag
  postId: String
  post: Post
  bannerImageId: String
  includesPoll: Boolean
  eventFormat: String
  pollQuestion(version: String): Revision
  pollQuestion_latest: String
  pollAgreeWording: String
  pollDisagreeWording: String
  maxStickersPerUser: Float
  customComponent: String
  commentPrompt: String
  publicData: JSON
  voteCount: Int!
}

input DeleteForumEventInput {
  selector: ForumEventSelectorUniqueInput!
}

input SingleForumEventInput {
  selector: ForumEventSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiForumEventInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ForumEventSelectorInput
  orderBy: ForumEventOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleForumEventOutput {
  result: ForumEvent
}

type MultiForumEventOutput {
  results: [ForumEvent]
  totalCount: Int
}

type ForumEventOutput {
  data: ForumEvent
}

input CreateForumEventInput {
  data: CreateForumEventDataInput!
}

input CreateForumEventDataInput {
  legacyData: JSON
  frontpageDescription: JSON
  frontpageDescriptionMobile: JSON
  postPageDescription: JSON
  title: String!
  startDate: Date!
  endDate: Date!
  darkColor: String!
  lightColor: String!
  bannerTextColor: String!
  contrastColor: String
  tagId: String
  postId: String
  bannerImageId: String
  includesPoll: Boolean
  eventFormat: String
  pollQuestion: JSON
  pollAgreeWording: String
  pollDisagreeWording: String
  maxStickersPerUser: Float
  customComponent: String
  commentPrompt: String
  publicData: JSON
}

input UpdateForumEventInput {
  selector: ForumEventSelectorUniqueInput!
  data: UpdateForumEventDataInput!
}

input UpsertForumEventInput {
  selector: ForumEventSelectorUniqueInput!
  data: UpdateForumEventDataInput!
}

input UpdateForumEventDataInput {
  legacyData: JSON
  frontpageDescription: JSON
  frontpageDescriptionMobile: JSON
  postPageDescription: JSON
  title: String
  startDate: Date
  endDate: Date
  darkColor: String
  lightColor: String
  bannerTextColor: String
  contrastColor: String
  tagId: String
  postId: String
  bannerImageId: String
  includesPoll: Boolean
  eventFormat: String
  pollQuestion: JSON
  pollAgreeWording: String
  pollDisagreeWording: String
  maxStickersPerUser: Float
  customComponent: String
  commentPrompt: String
}

input ForumEventSelectorInput {
  AND: [ForumEventSelectorInput]
  OR: [ForumEventSelectorInput]
}

input ForumEventSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ForumEventOrderByInput {
  foobar
}

type GardenCode {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  pingbacks: JSON
  slug: String
  code: String
  title: String
  userId: String
  user: User
  startTime: Date
  endTime: Date
  fbLink: String
  type: String
  hidden: Boolean
  deleted: Boolean
  afOnly: Boolean
}

input DeleteGardenCodeInput {
  selector: GardenCodeSelectorUniqueInput!
}

input SingleGardenCodeInput {
  selector: GardenCodeSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiGardenCodeInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: GardenCodeSelectorInput
  orderBy: GardenCodeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleGardenCodeOutput {
  result: GardenCode
}

type MultiGardenCodeOutput {
  results: [GardenCode]
  totalCount: Int
}

type GardenCodeOutput {
  data: GardenCode
}

input CreateGardenCodeInput {
  data: CreateGardenCodeDataInput!
}

input CreateGardenCodeDataInput {
  legacyData: JSON
  contents: JSON
  title: String!
  startTime: Date
  fbLink: String
  type: String
  afOnly: Boolean
}

input UpdateGardenCodeInput {
  selector: GardenCodeSelectorUniqueInput!
  data: UpdateGardenCodeDataInput!
}

input UpsertGardenCodeInput {
  selector: GardenCodeSelectorUniqueInput!
  data: UpdateGardenCodeDataInput!
}

input UpdateGardenCodeDataInput {
  legacyData: JSON
  contents: JSON
  title: String
  startTime: Date
  endTime: Date
  fbLink: String
  type: String
  hidden: Boolean
  deleted: Boolean
  afOnly: Boolean
}

input GardenCodeSelectorInput {
  AND: [GardenCodeSelectorInput]
  OR: [GardenCodeSelectorInput]
}

input GardenCodeSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum GardenCodeOrderByInput {
  foobar
}

type GoogleServiceAccountSession {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  email: String
  refreshToken: String
  estimatedExpiry: Date
  active: Boolean
  revoked: Boolean
}

input DeleteGoogleServiceAccountSessionInput {
  selector: GoogleServiceAccountSessionSelectorUniqueInput!
}

input SingleGoogleServiceAccountSessionInput {
  selector: GoogleServiceAccountSessionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiGoogleServiceAccountSessionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: GoogleServiceAccountSessionSelectorInput
  orderBy: GoogleServiceAccountSessionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleGoogleServiceAccountSessionOutput {
  result: GoogleServiceAccountSession
}

type MultiGoogleServiceAccountSessionOutput {
  results: [GoogleServiceAccountSession]
  totalCount: Int
}

type GoogleServiceAccountSessionOutput {
  data: GoogleServiceAccountSession
}

input CreateGoogleServiceAccountSessionInput {
  data: CreateGoogleServiceAccountSessionDataInput!
}

input CreateGoogleServiceAccountSessionDataInput {
  legacyData: JSON
  email: String!
  refreshToken: String!
  estimatedExpiry: Date!
  active: Boolean!
  revoked: Boolean!
}

input UpdateGoogleServiceAccountSessionInput {
  selector: GoogleServiceAccountSessionSelectorUniqueInput!
  data: UpdateGoogleServiceAccountSessionDataInput!
}

input UpsertGoogleServiceAccountSessionInput {
  selector: GoogleServiceAccountSessionSelectorUniqueInput!
  data: UpdateGoogleServiceAccountSessionDataInput!
}

input UpdateGoogleServiceAccountSessionDataInput {
  legacyData: JSON
  email: String
  refreshToken: String
  estimatedExpiry: Date
  active: Boolean
  revoked: Boolean
}

input GoogleServiceAccountSessionSelectorInput {
  AND: [GoogleServiceAccountSessionSelectorInput]
  OR: [GoogleServiceAccountSessionSelectorInput]
}

input GoogleServiceAccountSessionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum GoogleServiceAccountSessionOrderByInput {
  foobar
}

type Images {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteImagesInput {
  selector: ImagesSelectorUniqueInput!
}

input SingleImagesInput {
  selector: ImagesSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiImagesInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ImagesSelectorInput
  orderBy: ImagesOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleImagesOutput {
  result: Images
}

type MultiImagesOutput {
  results: [Images]
  totalCount: Int
}

type ImagesOutput {
  data: Images
}

input CreateImagesInput {
  data: CreateImagesDataInput!
}

input CreateImagesDataInput {
  legacyData: JSON
}

input UpdateImagesInput {
  selector: ImagesSelectorUniqueInput!
  data: UpdateImagesDataInput!
}

input UpsertImagesInput {
  selector: ImagesSelectorUniqueInput!
  data: UpdateImagesDataInput!
}

input UpdateImagesDataInput {
  legacyData: JSON
}

input ImagesSelectorInput {
  AND: [ImagesSelectorInput]
  OR: [ImagesSelectorInput]
}

input ImagesSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ImagesOrderByInput {
  foobar
}

type JargonTerm {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  postId: String
  post: Post
  term: String
  humansAndOrAIEdited: String
  approved: Boolean
  deleted: Boolean
  altTerms: [String]
}

input DeleteJargonTermInput {
  selector: JargonTermSelectorUniqueInput!
}

input SingleJargonTermInput {
  selector: JargonTermSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiJargonTermInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: JargonTermSelectorInput
  orderBy: JargonTermOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleJargonTermOutput {
  result: JargonTerm
}

type MultiJargonTermOutput {
  results: [JargonTerm]
  totalCount: Int
}

type JargonTermOutput {
  data: JargonTerm
}

input CreateJargonTermInput {
  data: CreateJargonTermDataInput!
}

input CreateJargonTermDataInput {
  legacyData: JSON
  contents: JSON
  postId: String!
  term: String!
  approved: Boolean
  deleted: Boolean
  altTerms: [String]!
}

input UpdateJargonTermInput {
  selector: JargonTermSelectorUniqueInput!
  data: UpdateJargonTermDataInput!
}

input UpsertJargonTermInput {
  selector: JargonTermSelectorUniqueInput!
  data: UpdateJargonTermDataInput!
}

input UpdateJargonTermDataInput {
  legacyData: JSON
  contents: JSON
  term: String
  approved: Boolean
  deleted: Boolean
  altTerms: [String]
}

input JargonTermSelectorInput {
  AND: [JargonTermSelectorInput]
  OR: [JargonTermSelectorInput]
}

input JargonTermSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum JargonTermOrderByInput {
  foobar
}

type LWEvent {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  name: String
  documentId: String
  important: Boolean
  properties: JSON
  intercom: Boolean
}

input DeleteLWEventInput {
  selector: LWEventSelectorUniqueInput!
}

input SingleLWEventInput {
  selector: LWEventSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiLWEventInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: LWEventSelectorInput
  orderBy: LWEventOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLWEventOutput {
  result: LWEvent
}

type MultiLWEventOutput {
  results: [LWEvent]
  totalCount: Int
}

type LWEventOutput {
  data: LWEvent
}

input CreateLWEventInput {
  data: CreateLWEventDataInput!
}

input CreateLWEventDataInput {
  legacyData: JSON
  userId: String
  name: String!
  documentId: String
  important: Boolean
  properties: JSON
  intercom: Boolean
}

input UpdateLWEventInput {
  selector: LWEventSelectorUniqueInput!
  data: UpdateLWEventDataInput!
}

input UpsertLWEventInput {
  selector: LWEventSelectorUniqueInput!
  data: UpdateLWEventDataInput!
}

input UpdateLWEventDataInput {
  legacyData: JSON
  important: Boolean
}

input LWEventSelectorInput {
  AND: [LWEventSelectorInput]
  OR: [LWEventSelectorInput]
}

input LWEventSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum LWEventOrderByInput {
  foobar
}

type LegacyData {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteLegacyDataInput {
  selector: LegacyDataSelectorUniqueInput!
}

input SingleLegacyDataInput {
  selector: LegacyDataSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiLegacyDataInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: LegacyDataSelectorInput
  orderBy: LegacyDataOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLegacyDataOutput {
  result: LegacyData
}

type MultiLegacyDataOutput {
  results: [LegacyData]
  totalCount: Int
}

type LegacyDataOutput {
  data: LegacyData
}

input CreateLegacyDataInput {
  data: CreateLegacyDataDataInput!
}

input CreateLegacyDataDataInput {
  legacyData: JSON
}

input UpdateLegacyDataInput {
  selector: LegacyDataSelectorUniqueInput!
  data: UpdateLegacyDataDataInput!
}

input UpsertLegacyDataInput {
  selector: LegacyDataSelectorUniqueInput!
  data: UpdateLegacyDataDataInput!
}

input UpdateLegacyDataDataInput {
  legacyData: JSON
}

input LegacyDataSelectorInput {
  AND: [LegacyDataSelectorInput]
  OR: [LegacyDataSelectorInput]
}

input LegacyDataSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum LegacyDataOrderByInput {
  foobar
}

type LlmConversation {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  title: String
  model: String
  systemPrompt: String
  lastUpdatedAt: Date
  messages: [LlmMessage]
  deleted: Boolean
  totalCharacterCount: Int
}

input DeleteLlmConversationInput {
  selector: LlmConversationSelectorUniqueInput!
}

input SingleLlmConversationInput {
  selector: LlmConversationSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiLlmConversationInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: LlmConversationSelectorInput
  orderBy: LlmConversationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLlmConversationOutput {
  result: LlmConversation
}

type MultiLlmConversationOutput {
  results: [LlmConversation]
  totalCount: Int
}

type LlmConversationOutput {
  data: LlmConversation
}

input CreateLlmConversationInput {
  data: CreateLlmConversationDataInput!
}

input CreateLlmConversationDataInput {
  legacyData: JSON
  userId: String!
  title: String!
  model: String!
  systemPrompt: String
  deleted: Boolean
}

input UpdateLlmConversationInput {
  selector: LlmConversationSelectorUniqueInput!
  data: UpdateLlmConversationDataInput!
}

input UpsertLlmConversationInput {
  selector: LlmConversationSelectorUniqueInput!
  data: UpdateLlmConversationDataInput!
}

input UpdateLlmConversationDataInput {
  legacyData: JSON
  userId: String
  title: String
  model: String
  systemPrompt: String
  deleted: Boolean
}

input LlmConversationSelectorInput {
  AND: [LlmConversationSelectorInput]
  OR: [LlmConversationSelectorInput]
}

input LlmConversationSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum LlmConversationOrderByInput {
  foobar
}

type LlmMessage {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  conversationId: String
  role: String
  content: String
}

input DeleteLlmMessageInput {
  selector: LlmMessageSelectorUniqueInput!
}

input SingleLlmMessageInput {
  selector: LlmMessageSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiLlmMessageInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: LlmMessageSelectorInput
  orderBy: LlmMessageOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLlmMessageOutput {
  result: LlmMessage
}

type MultiLlmMessageOutput {
  results: [LlmMessage]
  totalCount: Int
}

type LlmMessageOutput {
  data: LlmMessage
}

input CreateLlmMessageInput {
  data: CreateLlmMessageDataInput!
}

input CreateLlmMessageDataInput {
  legacyData: JSON
  userId: String!
  conversationId: String
  role: String!
  content: String!
}

input UpdateLlmMessageInput {
  selector: LlmMessageSelectorUniqueInput!
  data: UpdateLlmMessageDataInput!
}

input UpsertLlmMessageInput {
  selector: LlmMessageSelectorUniqueInput!
  data: UpdateLlmMessageDataInput!
}

input UpdateLlmMessageDataInput {
  legacyData: JSON
  userId: String
  conversationId: String
  role: String
  content: String
}

input LlmMessageSelectorInput {
  AND: [LlmMessageSelectorInput]
  OR: [LlmMessageSelectorInput]
}

input LlmMessageSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum LlmMessageOrderByInput {
  foobar
}

type Localgroup {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  name: String
  nameInAnotherLanguage: String
  organizerIds: [String]
  organizers: [User!]!
  lastActivity: Date
  types: [String]
  categories: [String]
  isOnline: Boolean
  mongoLocation: JSON
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  facebookPageLink: String
  meetupLink: String
  slackLink: String
  website: String
  bannerImageId: String
  inactive: Boolean
  deleted: Boolean
}

input DeleteLocalgroupInput {
  selector: LocalgroupSelectorUniqueInput!
}

input SingleLocalgroupInput {
  selector: LocalgroupSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiLocalgroupInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: LocalgroupSelectorInput
  orderBy: LocalgroupOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLocalgroupOutput {
  result: Localgroup
}

type MultiLocalgroupOutput {
  results: [Localgroup]
  totalCount: Int
}

type LocalgroupOutput {
  data: Localgroup
}

input CreateLocalgroupInput {
  data: CreateLocalgroupDataInput!
}

input CreateLocalgroupDataInput {
  legacyData: JSON
  contents: JSON
  name: String!
  nameInAnotherLanguage: String
  organizerIds: [String]!
  lastActivity: Date
  types: [String]!
  categories: [String]
  isOnline: Boolean
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  facebookPageLink: String
  meetupLink: String
  slackLink: String
  website: String
  bannerImageId: String
  inactive: Boolean
  deleted: Boolean
}

input UpdateLocalgroupInput {
  selector: LocalgroupSelectorUniqueInput!
  data: UpdateLocalgroupDataInput!
}

input UpsertLocalgroupInput {
  selector: LocalgroupSelectorUniqueInput!
  data: UpdateLocalgroupDataInput!
}

input UpdateLocalgroupDataInput {
  legacyData: JSON
  contents: JSON
  name: String
  nameInAnotherLanguage: String
  organizerIds: [String]
  lastActivity: Date
  types: [String]
  categories: [String]
  isOnline: Boolean
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  facebookPageLink: String
  meetupLink: String
  slackLink: String
  website: String
  bannerImageId: String
  inactive: Boolean
  deleted: Boolean
}

input LocalgroupSelectorInput {
  AND: [LocalgroupSelectorInput]
  OR: [LocalgroupSelectorInput]
}

input LocalgroupSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum LocalgroupOrderByInput {
  foobar
}

type ManifoldProbabilitiesCache {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  marketId: String
  probability: Float
  isResolved: Boolean
  year: Float
  lastUpdated: Date
  url: String
}

input DeleteManifoldProbabilitiesCacheInput {
  selector: ManifoldProbabilitiesCacheSelectorUniqueInput!
}

input SingleManifoldProbabilitiesCacheInput {
  selector: ManifoldProbabilitiesCacheSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiManifoldProbabilitiesCacheInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ManifoldProbabilitiesCacheSelectorInput
  orderBy: ManifoldProbabilitiesCacheOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleManifoldProbabilitiesCacheOutput {
  result: ManifoldProbabilitiesCache
}

type MultiManifoldProbabilitiesCacheOutput {
  results: [ManifoldProbabilitiesCache]
  totalCount: Int
}

type ManifoldProbabilitiesCacheOutput {
  data: ManifoldProbabilitiesCache
}

input CreateManifoldProbabilitiesCacheInput {
  data: CreateManifoldProbabilitiesCacheDataInput!
}

input CreateManifoldProbabilitiesCacheDataInput {
  legacyData: JSON
  marketId: String!
  probability: Float!
  isResolved: Boolean!
  year: Float!
  lastUpdated: Date!
  url: String
}

input UpdateManifoldProbabilitiesCacheInput {
  selector: ManifoldProbabilitiesCacheSelectorUniqueInput!
  data: UpdateManifoldProbabilitiesCacheDataInput!
}

input UpsertManifoldProbabilitiesCacheInput {
  selector: ManifoldProbabilitiesCacheSelectorUniqueInput!
  data: UpdateManifoldProbabilitiesCacheDataInput!
}

input UpdateManifoldProbabilitiesCacheDataInput {
  legacyData: JSON
}

input ManifoldProbabilitiesCacheSelectorInput {
  AND: [ManifoldProbabilitiesCacheSelectorInput]
  OR: [ManifoldProbabilitiesCacheSelectorInput]
}

input ManifoldProbabilitiesCacheSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ManifoldProbabilitiesCacheOrderByInput {
  foobar
}

type Message {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  userId: String
  user: User
  conversationId: String
  conversation: Conversation!
  noEmail: Boolean
}

input DeleteMessageInput {
  selector: MessageSelectorUniqueInput!
}

input SingleMessageInput {
  selector: MessageSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiMessageInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: MessageSelectorInput
  orderBy: MessageOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleMessageOutput {
  result: Message
}

type MultiMessageOutput {
  results: [Message]
  totalCount: Int
}

type MessageOutput {
  data: Message
}

input CreateMessageInput {
  data: CreateMessageDataInput!
}

input CreateMessageDataInput {
  legacyData: JSON
  contents: JSON
  userId: String
  conversationId: String!
  noEmail: Boolean
}

input UpdateMessageInput {
  selector: MessageSelectorUniqueInput!
  data: UpdateMessageDataInput!
}

input UpsertMessageInput {
  selector: MessageSelectorUniqueInput!
  data: UpdateMessageDataInput!
}

input UpdateMessageDataInput {
  legacyData: JSON
  contents: JSON
}

input MessageSelectorInput {
  AND: [MessageSelectorInput]
  OR: [MessageSelectorInput]
}

input MessageSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum MessageOrderByInput {
  foobar
}

type Migration {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteMigrationInput {
  selector: MigrationSelectorUniqueInput!
}

input SingleMigrationInput {
  selector: MigrationSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiMigrationInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: MigrationSelectorInput
  orderBy: MigrationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleMigrationOutput {
  result: Migration
}

type MultiMigrationOutput {
  results: [Migration]
  totalCount: Int
}

type MigrationOutput {
  data: Migration
}

input CreateMigrationInput {
  data: CreateMigrationDataInput!
}

input CreateMigrationDataInput {
  legacyData: JSON
}

input UpdateMigrationInput {
  selector: MigrationSelectorUniqueInput!
  data: UpdateMigrationDataInput!
}

input UpsertMigrationInput {
  selector: MigrationSelectorUniqueInput!
  data: UpdateMigrationDataInput!
}

input UpdateMigrationDataInput {
  legacyData: JSON
}

input MigrationSelectorInput {
  AND: [MigrationSelectorInput]
  OR: [MigrationSelectorInput]
}

input MigrationSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum MigrationOrderByInput {
  foobar
}

type ModerationTemplate {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  name: String
  collectionName: String
  order: Float
  deleted: Boolean
}

input DeleteModerationTemplateInput {
  selector: ModerationTemplateSelectorUniqueInput!
}

input SingleModerationTemplateInput {
  selector: ModerationTemplateSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiModerationTemplateInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ModerationTemplateSelectorInput
  orderBy: ModerationTemplateOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleModerationTemplateOutput {
  result: ModerationTemplate
}

type MultiModerationTemplateOutput {
  results: [ModerationTemplate]
  totalCount: Int
}

type ModerationTemplateOutput {
  data: ModerationTemplate
}

input CreateModerationTemplateInput {
  data: CreateModerationTemplateDataInput!
}

input CreateModerationTemplateDataInput {
  legacyData: JSON
  contents: JSON
  name: String!
  collectionName: String!
  order: Float
}

input UpdateModerationTemplateInput {
  selector: ModerationTemplateSelectorUniqueInput!
  data: UpdateModerationTemplateDataInput!
}

input UpsertModerationTemplateInput {
  selector: ModerationTemplateSelectorUniqueInput!
  data: UpdateModerationTemplateDataInput!
}

input UpdateModerationTemplateDataInput {
  legacyData: JSON
  contents: JSON
  name: String
  collectionName: String
  order: Float
  deleted: Boolean
}

input ModerationTemplateSelectorInput {
  AND: [ModerationTemplateSelectorInput]
  OR: [ModerationTemplateSelectorInput]
}

input ModerationTemplateSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ModerationTemplateOrderByInput {
  foobar
}

type ModeratorAction {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  type: String
  endedAt: Date
  active: Boolean!
}

input DeleteModeratorActionInput {
  selector: ModeratorActionSelectorUniqueInput!
}

input SingleModeratorActionInput {
  selector: ModeratorActionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiModeratorActionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ModeratorActionSelectorInput
  orderBy: ModeratorActionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleModeratorActionOutput {
  result: ModeratorAction
}

type MultiModeratorActionOutput {
  results: [ModeratorAction]
  totalCount: Int
}

type ModeratorActionOutput {
  data: ModeratorAction
}

input CreateModeratorActionInput {
  data: CreateModeratorActionDataInput!
}

input CreateModeratorActionDataInput {
  legacyData: JSON
  userId: String
  type: String!
  endedAt: Date
}

input UpdateModeratorActionInput {
  selector: ModeratorActionSelectorUniqueInput!
  data: UpdateModeratorActionDataInput!
}

input UpsertModeratorActionInput {
  selector: ModeratorActionSelectorUniqueInput!
  data: UpdateModeratorActionDataInput!
}

input UpdateModeratorActionDataInput {
  legacyData: JSON
  userId: String
  type: String
  endedAt: Date
}

input ModeratorActionSelectorInput {
  AND: [ModeratorActionSelectorInput]
  OR: [ModeratorActionSelectorInput]
}

input ModeratorActionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ModeratorActionOrderByInput {
  foobar
}

type MultiDocument {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  pingbacks: JSON
  slug: String
  oldSlugs: [String]
  title: String
  preview: String
  tabTitle: String
  tabSubtitle: String
  userId: String
  user: User
  parentDocumentId: String
  parentTag: Tag
  parentLens: MultiDocument
  collectionName: String
  fieldName: String
  index: Float
  tableOfContents(version: String): JSON
  contributors(limit: Int, version: String): TagContributorsList
  contributionStats: JSON
  arbitalLinkedPages: ArbitalLinkedPages
  htmlWithContributorAnnotations: String
  summaries: [MultiDocument!]!
  textLastUpdatedAt: Date
  deleted: Boolean
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float
  baseScore: Float
  extendedScore: JSON
  score: Float
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input DeleteMultiDocumentInput {
  selector: MultiDocumentSelectorUniqueInput!
}

input SingleMultiDocumentInput {
  selector: MultiDocumentSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiMultiDocumentInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: MultiDocumentSelectorInput
  orderBy: MultiDocumentOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleMultiDocumentOutput {
  result: MultiDocument
}

type MultiMultiDocumentOutput {
  results: [MultiDocument]
  totalCount: Int
}

type MultiDocumentOutput {
  data: MultiDocument
}

input CreateMultiDocumentInput {
  data: CreateMultiDocumentDataInput!
}

input CreateMultiDocumentDataInput {
  legacyData: JSON
  contents: JSON
  title: String
  tabTitle: String!
  tabSubtitle: String
  userId: String
  parentDocumentId: String!
  collectionName: String!
  fieldName: String!
}

input UpdateMultiDocumentInput {
  selector: MultiDocumentSelectorUniqueInput!
  data: UpdateMultiDocumentDataInput!
}

input UpsertMultiDocumentInput {
  selector: MultiDocumentSelectorUniqueInput!
  data: UpdateMultiDocumentDataInput!
}

input UpdateMultiDocumentDataInput {
  legacyData: JSON
  contents: JSON
  title: String
  tabTitle: String
  tabSubtitle: String
  index: Float
  deleted: Boolean
}

input MultiDocumentSelectorInput {
  AND: [MultiDocumentSelectorInput]
  OR: [MultiDocumentSelectorInput]
}

input MultiDocumentSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum MultiDocumentOrderByInput {
  foobar
}

type Notification {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  documentId: String
  documentType: String
  extraData: JSON
  link: String
  title: String
  message: String
  type: String
  deleted: Boolean
  viewed: Boolean
  emailed: Boolean
  waitingForBatch: Boolean
}

input DeleteNotificationInput {
  selector: NotificationSelectorUniqueInput!
}

input SingleNotificationInput {
  selector: NotificationSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiNotificationInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: NotificationSelectorInput
  orderBy: NotificationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleNotificationOutput {
  result: Notification
}

type MultiNotificationOutput {
  results: [Notification]
  totalCount: Int
}

type NotificationOutput {
  data: Notification
}

input CreateNotificationInput {
  data: CreateNotificationDataInput!
}

input CreateNotificationDataInput {
  legacyData: JSON
  viewed: Boolean
}

input UpdateNotificationInput {
  selector: NotificationSelectorUniqueInput!
  data: UpdateNotificationDataInput!
}

input UpsertNotificationInput {
  selector: NotificationSelectorUniqueInput!
  data: UpdateNotificationDataInput!
}

input UpdateNotificationDataInput {
  legacyData: JSON
  viewed: Boolean
}

input NotificationSelectorInput {
  AND: [NotificationSelectorInput]
  OR: [NotificationSelectorInput]
}

input NotificationSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum NotificationOrderByInput {
  foobar
}

type PageCacheEntry {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeletePageCacheEntryInput {
  selector: PageCacheEntrySelectorUniqueInput!
}

input SinglePageCacheEntryInput {
  selector: PageCacheEntrySelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPageCacheEntryInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PageCacheEntrySelectorInput
  orderBy: PageCacheEntryOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePageCacheEntryOutput {
  result: PageCacheEntry
}

type MultiPageCacheEntryOutput {
  results: [PageCacheEntry]
  totalCount: Int
}

type PageCacheEntryOutput {
  data: PageCacheEntry
}

input CreatePageCacheEntryInput {
  data: CreatePageCacheEntryDataInput!
}

input CreatePageCacheEntryDataInput {
  legacyData: JSON
}

input UpdatePageCacheEntryInput {
  selector: PageCacheEntrySelectorUniqueInput!
  data: UpdatePageCacheEntryDataInput!
}

input UpsertPageCacheEntryInput {
  selector: PageCacheEntrySelectorUniqueInput!
  data: UpdatePageCacheEntryDataInput!
}

input UpdatePageCacheEntryDataInput {
  legacyData: JSON
}

input PageCacheEntrySelectorInput {
  AND: [PageCacheEntrySelectorInput]
  OR: [PageCacheEntrySelectorInput]
}

input PageCacheEntrySelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PageCacheEntryOrderByInput {
  foobar
}

type PetrovDayAction {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  actionType: String
  data: JSON
  userId: String
}

input DeletePetrovDayActionInput {
  selector: PetrovDayActionSelectorUniqueInput!
}

input SinglePetrovDayActionInput {
  selector: PetrovDayActionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPetrovDayActionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PetrovDayActionSelectorInput
  orderBy: PetrovDayActionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePetrovDayActionOutput {
  result: PetrovDayAction
}

type MultiPetrovDayActionOutput {
  results: [PetrovDayAction]
  totalCount: Int
}

type PetrovDayActionOutput {
  data: PetrovDayAction
}

input CreatePetrovDayActionInput {
  data: CreatePetrovDayActionDataInput!
}

input CreatePetrovDayActionDataInput {
  legacyData: JSON
  actionType: String!
  data: JSON
  userId: String!
}

input UpdatePetrovDayActionInput {
  selector: PetrovDayActionSelectorUniqueInput!
  data: UpdatePetrovDayActionDataInput!
}

input UpsertPetrovDayActionInput {
  selector: PetrovDayActionSelectorUniqueInput!
  data: UpdatePetrovDayActionDataInput!
}

input UpdatePetrovDayActionDataInput {
  legacyData: JSON
}

input PetrovDayActionSelectorInput {
  AND: [PetrovDayActionSelectorInput]
  OR: [PetrovDayActionSelectorInput]
}

input PetrovDayActionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PetrovDayActionOrderByInput {
  foobar
}

type PetrovDayLaunch {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  launchCode: String
  hashedLaunchCode: String
  userId: String
}

input DeletePetrovDayLaunchInput {
  selector: PetrovDayLaunchSelectorUniqueInput!
}

input SinglePetrovDayLaunchInput {
  selector: PetrovDayLaunchSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPetrovDayLaunchInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PetrovDayLaunchSelectorInput
  orderBy: PetrovDayLaunchOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePetrovDayLaunchOutput {
  result: PetrovDayLaunch
}

type MultiPetrovDayLaunchOutput {
  results: [PetrovDayLaunch]
  totalCount: Int
}

type PetrovDayLaunchOutput {
  data: PetrovDayLaunch
}

input CreatePetrovDayLaunchInput {
  data: CreatePetrovDayLaunchDataInput!
}

input CreatePetrovDayLaunchDataInput {
  legacyData: JSON
  launchCode: String
  hashedLaunchCode: String
  userId: String
}

input UpdatePetrovDayLaunchInput {
  selector: PetrovDayLaunchSelectorUniqueInput!
  data: UpdatePetrovDayLaunchDataInput!
}

input UpsertPetrovDayLaunchInput {
  selector: PetrovDayLaunchSelectorUniqueInput!
  data: UpdatePetrovDayLaunchDataInput!
}

input UpdatePetrovDayLaunchDataInput {
  legacyData: JSON
  launchCode: String
  hashedLaunchCode: String
  userId: String
}

input PetrovDayLaunchSelectorInput {
  AND: [PetrovDayLaunchSelectorInput]
  OR: [PetrovDayLaunchSelectorInput]
}

input PetrovDayLaunchSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PetrovDayLaunchOrderByInput {
  foobar
}

type PodcastEpisode {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  podcastId: String
  podcast: Podcast!
  title: String
  episodeLink: String
  externalEpisodeId: String
}

input DeletePodcastEpisodeInput {
  selector: PodcastEpisodeSelectorUniqueInput!
}

input SinglePodcastEpisodeInput {
  selector: PodcastEpisodeSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPodcastEpisodeInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PodcastEpisodeSelectorInput
  orderBy: PodcastEpisodeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePodcastEpisodeOutput {
  result: PodcastEpisode
}

type MultiPodcastEpisodeOutput {
  results: [PodcastEpisode]
  totalCount: Int
}

type PodcastEpisodeOutput {
  data: PodcastEpisode
}

input CreatePodcastEpisodeInput {
  data: CreatePodcastEpisodeDataInput!
}

input CreatePodcastEpisodeDataInput {
  legacyData: JSON
  podcastId: String
  title: String!
  episodeLink: String!
  externalEpisodeId: String!
}

input UpdatePodcastEpisodeInput {
  selector: PodcastEpisodeSelectorUniqueInput!
  data: UpdatePodcastEpisodeDataInput!
}

input UpsertPodcastEpisodeInput {
  selector: PodcastEpisodeSelectorUniqueInput!
  data: UpdatePodcastEpisodeDataInput!
}

input UpdatePodcastEpisodeDataInput {
  legacyData: JSON
}

input PodcastEpisodeSelectorInput {
  AND: [PodcastEpisodeSelectorInput]
  OR: [PodcastEpisodeSelectorInput]
}

input PodcastEpisodeSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PodcastEpisodeOrderByInput {
  foobar
}

type Podcast {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  title: String
  applePodcastLink: String
  spotifyPodcastLink: String
}

input DeletePodcastInput {
  selector: PodcastSelectorUniqueInput!
}

input SinglePodcastInput {
  selector: PodcastSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPodcastInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PodcastSelectorInput
  orderBy: PodcastOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePodcastOutput {
  result: Podcast
}

type MultiPodcastOutput {
  results: [Podcast]
  totalCount: Int
}

type PodcastOutput {
  data: Podcast
}

input CreatePodcastInput {
  data: CreatePodcastDataInput!
}

input CreatePodcastDataInput {
  legacyData: JSON
}

input UpdatePodcastInput {
  selector: PodcastSelectorUniqueInput!
  data: UpdatePodcastDataInput!
}

input UpsertPodcastInput {
  selector: PodcastSelectorUniqueInput!
  data: UpdatePodcastDataInput!
}

input UpdatePodcastDataInput {
  legacyData: JSON
}

input PodcastSelectorInput {
  AND: [PodcastSelectorInput]
  OR: [PodcastSelectorInput]
}

input PodcastSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PodcastOrderByInput {
  foobar
}

type PostEmbedding {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  postId: String
  post: Post!
  postHash: String
  lastGeneratedAt: Date
  model: String
  embeddings: [Float]
}

input DeletePostEmbeddingInput {
  selector: PostEmbeddingSelectorUniqueInput!
}

input SinglePostEmbeddingInput {
  selector: PostEmbeddingSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPostEmbeddingInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PostEmbeddingSelectorInput
  orderBy: PostEmbeddingOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostEmbeddingOutput {
  result: PostEmbedding
}

type MultiPostEmbeddingOutput {
  results: [PostEmbedding]
  totalCount: Int
}

type PostEmbeddingOutput {
  data: PostEmbedding
}

input CreatePostEmbeddingInput {
  data: CreatePostEmbeddingDataInput!
}

input CreatePostEmbeddingDataInput {
  legacyData: JSON
  postId: String!
  postHash: String!
  lastGeneratedAt: Date!
  model: String!
  embeddings: [Float]!
}

input UpdatePostEmbeddingInput {
  selector: PostEmbeddingSelectorUniqueInput!
  data: UpdatePostEmbeddingDataInput!
}

input UpsertPostEmbeddingInput {
  selector: PostEmbeddingSelectorUniqueInput!
  data: UpdatePostEmbeddingDataInput!
}

input UpdatePostEmbeddingDataInput {
  legacyData: JSON
  postId: String
  postHash: String
  lastGeneratedAt: Date
  model: String
  embeddings: [Float]
}

input PostEmbeddingSelectorInput {
  AND: [PostEmbeddingSelectorInput]
  OR: [PostEmbeddingSelectorInput]
}

input PostEmbeddingSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PostEmbeddingOrderByInput {
  foobar
}

type PostRecommendation {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User!
  clientId: String
  postId: String
  post: Post!
  strategyName: String
  strategySettings: JSON
  recommendationCount: Int
  lastRecommendedAt: Date
  clickedAt: Date
}

input DeletePostRecommendationInput {
  selector: PostRecommendationSelectorUniqueInput!
}

input SinglePostRecommendationInput {
  selector: PostRecommendationSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPostRecommendationInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PostRecommendationSelectorInput
  orderBy: PostRecommendationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostRecommendationOutput {
  result: PostRecommendation
}

type MultiPostRecommendationOutput {
  results: [PostRecommendation]
  totalCount: Int
}

type PostRecommendationOutput {
  data: PostRecommendation
}

input CreatePostRecommendationInput {
  data: CreatePostRecommendationDataInput!
}

input CreatePostRecommendationDataInput {
  legacyData: JSON
  userId: String
  clientId: String
  postId: String!
  strategyName: String!
  strategySettings: JSON
  recommendationCount: Int!
  lastRecommendedAt: Date!
  clickedAt: Date
}

input UpdatePostRecommendationInput {
  selector: PostRecommendationSelectorUniqueInput!
  data: UpdatePostRecommendationDataInput!
}

input UpsertPostRecommendationInput {
  selector: PostRecommendationSelectorUniqueInput!
  data: UpdatePostRecommendationDataInput!
}

input UpdatePostRecommendationDataInput {
  legacyData: JSON
  userId: String
  clientId: String
  postId: String
  strategyName: String
  strategySettings: JSON
  recommendationCount: Int
  lastRecommendedAt: Date
  clickedAt: Date
}

input PostRecommendationSelectorInput {
  AND: [PostRecommendationSelectorInput]
  OR: [PostRecommendationSelectorInput]
}

input PostRecommendationSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PostRecommendationOrderByInput {
  foobar
}

type PostRelation {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  type: String
  sourcePostId: String
  sourcePost: Post
  targetPostId: String
  targetPost: Post
  order: Float
}

input DeletePostRelationInput {
  selector: PostRelationSelectorUniqueInput!
}

input SinglePostRelationInput {
  selector: PostRelationSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPostRelationInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PostRelationSelectorInput
  orderBy: PostRelationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostRelationOutput {
  result: PostRelation
}

type MultiPostRelationOutput {
  results: [PostRelation]
  totalCount: Int
}

type PostRelationOutput {
  data: PostRelation
}

input CreatePostRelationInput {
  data: CreatePostRelationDataInput!
}

input CreatePostRelationDataInput {
  legacyData: JSON
  type: String
  sourcePostId: String!
  targetPostId: String!
  order: Float
}

input UpdatePostRelationInput {
  selector: PostRelationSelectorUniqueInput!
  data: UpdatePostRelationDataInput!
}

input UpsertPostRelationInput {
  selector: PostRelationSelectorUniqueInput!
  data: UpdatePostRelationDataInput!
}

input UpdatePostRelationDataInput {
  legacyData: JSON
  type: String
  order: Float
}

input PostRelationSelectorInput {
  AND: [PostRelationSelectorInput]
  OR: [PostRelationSelectorInput]
}

input PostRelationSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PostRelationOrderByInput {
  foobar
}

type PostViewTime {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeletePostViewTimeInput {
  selector: PostViewTimeSelectorUniqueInput!
}

input SinglePostViewTimeInput {
  selector: PostViewTimeSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPostViewTimeInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PostViewTimeSelectorInput
  orderBy: PostViewTimeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostViewTimeOutput {
  result: PostViewTime
}

type MultiPostViewTimeOutput {
  results: [PostViewTime]
  totalCount: Int
}

type PostViewTimeOutput {
  data: PostViewTime
}

input CreatePostViewTimeInput {
  data: CreatePostViewTimeDataInput!
}

input CreatePostViewTimeDataInput {
  legacyData: JSON
}

input UpdatePostViewTimeInput {
  selector: PostViewTimeSelectorUniqueInput!
  data: UpdatePostViewTimeDataInput!
}

input UpsertPostViewTimeInput {
  selector: PostViewTimeSelectorUniqueInput!
  data: UpdatePostViewTimeDataInput!
}

input UpdatePostViewTimeDataInput {
  legacyData: JSON
}

input PostViewTimeSelectorInput {
  AND: [PostViewTimeSelectorInput]
  OR: [PostViewTimeSelectorInput]
}

input PostViewTimeSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PostViewTimeOrderByInput {
  foobar
}

type PostViews {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeletePostViewsInput {
  selector: PostViewsSelectorUniqueInput!
}

input SinglePostViewsInput {
  selector: PostViewsSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPostViewsInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PostViewsSelectorInput
  orderBy: PostViewsOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostViewsOutput {
  result: PostViews
}

type MultiPostViewsOutput {
  results: [PostViews]
  totalCount: Int
}

type PostViewsOutput {
  data: PostViews
}

input CreatePostViewsInput {
  data: CreatePostViewsDataInput!
}

input CreatePostViewsDataInput {
  legacyData: JSON
}

input UpdatePostViewsInput {
  selector: PostViewsSelectorUniqueInput!
  data: UpdatePostViewsDataInput!
}

input UpsertPostViewsInput {
  selector: PostViewsSelectorUniqueInput!
  data: UpdatePostViewsDataInput!
}

input UpdatePostViewsDataInput {
  legacyData: JSON
}

input PostViewsSelectorInput {
  AND: [PostViewsSelectorInput]
  OR: [PostViewsSelectorInput]
}

input PostViewsSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PostViewsOrderByInput {
  foobar
}

type Post {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  revisions(limit: Int = 5): [Revision]
  version: String
  pingbacks: JSON
  moderationGuidelines(version: String): Revision
  moderationGuidelines_latest: String
  customHighlight(version: String): Revision
  customHighlight_latest: String
  slug: String
  postedAt: Date
  modifiedAt: Date
  url: String
  postCategory: String
  title: String
  viewCount: Float
  lastCommentedAt: Date
  clickCount: Float
  deletedDraft: Boolean
  status: Float
  isFuture: Boolean
  sticky: Boolean
  stickyPriority: Int
  userIP: String
  userAgent: String
  referrer: String
  author: String
  userId: String
  user: User
  domain: String
  pageUrl: String!
  pageUrlRelative: String
  linkUrl: String
  postedAtFormatted: String
  emailShareUrl: String
  twitterShareUrl: String
  facebookShareUrl: String
  socialPreviewImageUrl: String
  question: Boolean
  authorIsUnreviewed: Boolean
  readTimeMinutesOverride: Float
  readTimeMinutes: Int!
  wordCount: Int
  htmlBody: String
  submitToFrontpage: Boolean
  hiddenRelatedQuestion: Boolean
  originalPostRelationSourceId: String
  sourcePostRelations: [PostRelation!]!
  targetPostRelations: [PostRelation!]!
  shortform: Boolean
  canonicalSource: String
  nominationCount2018: Float
  nominationCount2019: Float
  reviewCount2018: Float
  reviewCount2019: Float
  reviewCount: Float
  reviewVoteCount: Float
  positiveReviewVoteCount: Float
  manifoldReviewMarketId: String
  annualReviewMarketProbability: Float
  annualReviewMarketIsResolved: Boolean
  annualReviewMarketYear: Int
  annualReviewMarketUrl: String
  glossary: [JargonTerm!]!
  reviewVoteScoreAF: Float
  reviewVotesAF: [Float]
  reviewVoteScoreHighKarma: Float
  reviewVotesHighKarma: [Float]
  reviewVoteScoreAllKarma: Float
  reviewVotesAllKarma: [Float]
  finalReviewVoteScoreHighKarma: Float
  finalReviewVotesHighKarma: [Float]
  finalReviewVoteScoreAllKarma: Float
  finalReviewVotesAllKarma: [Float]
  finalReviewVoteScoreAF: Float
  finalReviewVotesAF: [Float]
  lastCommentPromotedAt: Date
  tagRel(tagId: String): TagRel
  tags: [Tag]
  tagRelevance: JSON
  lastPromotedComment: Comment
  bestAnswer: Comment
  noIndex: Boolean
  rsvps: [JSON]
  rsvpCounts: JSON!
  activateRSVPs: Boolean
  nextDayReminderSent: Boolean
  onlyVisibleToLoggedIn: Boolean
  onlyVisibleToEstablishedAccounts: Boolean
  hideFromRecentDiscussions: Boolean
  currentUserReviewVote: ReviewVote
  reviewWinner: ReviewWinner
  spotlight: Spotlight
  votingSystem: String
  myEditorAccess: String!
  podcastEpisodeId: String
  podcastEpisode: PodcastEpisode
  forceAllowType3Audio: Boolean
  legacy: Boolean
  legacyId: String
  legacySpam: Boolean
  feedId: String
  feed: RSSFeed
  feedLink: String
  lastVisitedAt: Date
  isRead: Boolean
  curatedDate: Date
  metaDate: Date
  suggestForCuratedUserIds: [String]
  suggestForCuratedUsernames: String
  frontpageDate: Date
  autoFrontpage: String
  collectionTitle: String
  coauthorStatuses: [JSON]
  coauthors: [User!]
  hasCoauthorPermission: Boolean
  socialPreviewImageId: String
  socialPreviewImageAutoUrl: String
  socialPreview: JSON
  socialPreviewData: SocialPreviewType
  fmCrosspost: JSON
  canonicalSequenceId: String
  canonicalSequence: Sequence
  canonicalCollectionSlug: String
  canonicalCollection: Collection
  canonicalBookId: String
  canonicalBook: Book
  canonicalNextPostSlug: String
  canonicalPrevPostSlug: String
  nextPost(sequenceId: String): Post
  prevPost(sequenceId: String): Post
  sequence(sequenceId: String, prevOrNext: String): Sequence
  unlisted: Boolean
  disableRecommendation: Boolean
  defaultRecommendation: Boolean
  hideFromPopularComments: Boolean
  draft: Boolean
  wasEverUndrafted: Boolean
  meta: Boolean
  hideFrontpageComments: Boolean
  maxBaseScore: Float
  scoreExceeded2Date: Date
  scoreExceeded30Date: Date
  scoreExceeded45Date: Date
  scoreExceeded75Date: Date
  scoreExceeded125Date: Date
  scoreExceeded200Date: Date
  bannedUserIds: [String]
  commentsLocked: Boolean
  commentsLockedToAccountsCreatedAfter: Date
  organizerIds: [String]
  organizers: [User!]!
  groupId: String
  group: Localgroup
  eventType: String
  isEvent: Boolean
  reviewedByUserId: String
  reviewedByUser: User
  reviewForCuratedUserId: String
  startTime: Date
  localStartTime: Date
  endTime: Date
  localEndTime: Date
  eventRegistrationLink: String
  joinEventLink: String
  onlineEvent: Boolean
  globalEvent: Boolean
  mongoLocation: JSON
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  meetupLink: String
  website: String
  eventImageId: String
  types: [String]
  metaSticky: Boolean
  sharingSettings: JSON
  shareWithUsers: [String]
  usersSharedWith: [User!]!
  linkSharingKey: String
  linkSharingKeyUsedBy: [String]
  commentSortOrder: String
  hideAuthor: Boolean
  tableOfContents: JSON
  tableOfContentsRevision(version: String): JSON
  sideComments: JSON
  sideCommentsCache: SideCommentCache
  sideCommentVisibility: String
  disableSidenotes: Boolean
  moderationStyle: String
  ignoreRateLimits: Boolean
  hideCommentKarma: Boolean
  commentCount: Float
  topLevelCommentCount: Float
  recentComments(commentsLimit: Int, maxAgeHours: Int, af: Boolean): [Comment]
  languageModelSummary: String!
  debate: Boolean
  collabEditorDialogue: Boolean
  totalDialogueResponseCount: Int!
  mostRecentPublishedDialogueResponseDate: Date
  unreadDebateResponseCount: Int!
  emojiReactors: JSON
  commentEmojiReactors: JSON
  rejected: Boolean
  rejectedReason: String
  rejectedByUserId: String
  rejectedByUser: User
  dialogTooltipPreview: String
  dialogueMessageContents(dialogueMessageId: String): String
  firstVideoAttribsForPreview: JSON
  subforumTagId: String
  subforumTag: Tag
  af: Boolean
  afDate: Date
  afCommentCount: Float
  afLastCommentedAt: Date
  afSticky: Boolean
  suggestForAlignmentUserIds: [String]
  suggestForAlignmentUsers: [User!]!
  reviewForAlignmentUserId: String
  agentFoundationsId: String
  swrCachingEnabled: Boolean
  generateDraftJargon: Boolean
  curationNotices: [CurationNotice]
  reviews: [Comment]
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float
  baseScore: Float
  extendedScore: JSON
  score: Float
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input DeletePostInput {
  selector: PostSelectorUniqueInput!
}

input SinglePostInput {
  selector: PostSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPostInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PostSelectorInput
  orderBy: PostOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostOutput {
  result: Post
}

type MultiPostOutput {
  results: [Post]
  totalCount: Int
}

type PostOutput {
  data: Post
}

input CreatePostInput {
  data: CreatePostDataInput!
}

input CreatePostDataInput {
  legacyData: JSON
  contents: JSON
  moderationGuidelines: JSON
  customHighlight: JSON
  postedAt: Date
  url: String
  postCategory: String
  title: String!
  status: Float
  sticky: Boolean
  stickyPriority: Int
  userId: String
  question: Boolean
  authorIsUnreviewed: Boolean
  readTimeMinutesOverride: Float
  submitToFrontpage: Boolean
  hiddenRelatedQuestion: Boolean
  originalPostRelationSourceId: String
  shortform: Boolean
  canonicalSource: String
  manifoldReviewMarketId: String
  tagRelevance: JSON
  noIndex: Boolean
  activateRSVPs: Boolean
  nextDayReminderSent: Boolean
  onlyVisibleToLoggedIn: Boolean
  onlyVisibleToEstablishedAccounts: Boolean
  hideFromRecentDiscussions: Boolean
  podcastEpisodeId: String
  forceAllowType3Audio: Boolean
  legacy: Boolean
  legacyId: String
  legacySpam: Boolean
  feedId: String
  feedLink: String
  curatedDate: Date
  metaDate: Date
  suggestForCuratedUserIds: [String]
  frontpageDate: Date
  autoFrontpage: String
  collectionTitle: String
  coauthorStatuses: [JSON]
  hasCoauthorPermission: Boolean
  socialPreviewImageId: String
  socialPreviewImageAutoUrl: String
  socialPreview: JSON
  fmCrosspost: JSON
  canonicalSequenceId: String
  canonicalCollectionSlug: String
  canonicalBookId: String
  canonicalNextPostSlug: String
  canonicalPrevPostSlug: String
  unlisted: Boolean
  disableRecommendation: Boolean
  defaultRecommendation: Boolean
  hideFromPopularComments: Boolean
  draft: Boolean
  wasEverUndrafted: Boolean
  meta: Boolean
  hideFrontpageComments: Boolean
  bannedUserIds: [String]
  commentsLocked: Boolean
  commentsLockedToAccountsCreatedAfter: Date
  organizerIds: [String]
  groupId: String
  eventType: String
  isEvent: Boolean
  reviewedByUserId: String
  reviewForCuratedUserId: String
  startTime: Date
  endTime: Date
  eventRegistrationLink: String
  joinEventLink: String
  onlineEvent: Boolean
  globalEvent: Boolean
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  meetupLink: String
  website: String
  eventImageId: String
  types: [String]
  metaSticky: Boolean
  sharingSettings: JSON
  shareWithUsers: [String]
  commentSortOrder: String
  hideAuthor: Boolean
  sideCommentVisibility: String
  disableSidenotes: Boolean
  moderationStyle: String
  ignoreRateLimits: Boolean
  hideCommentKarma: Boolean
  debate: Boolean
  collabEditorDialogue: Boolean
  rejected: Boolean
  rejectedReason: String
  rejectedByUserId: String
  subforumTagId: String
  af: Boolean
  afDate: Date
  afSticky: Boolean
  suggestForAlignmentUserIds: [String]
  reviewForAlignmentUserId: String
  agentFoundationsId: String
  swrCachingEnabled: Boolean
  generateDraftJargon: Boolean
}

input UpdatePostInput {
  selector: PostSelectorUniqueInput!
  data: UpdatePostDataInput!
}

input UpsertPostInput {
  selector: PostSelectorUniqueInput!
  data: UpdatePostDataInput!
}

input UpdatePostDataInput {
  legacyData: JSON
  contents: JSON
  moderationGuidelines: JSON
  customHighlight: JSON
  postedAt: Date
  url: String
  postCategory: String
  title: String
  deletedDraft: Boolean
  status: Float
  sticky: Boolean
  stickyPriority: Int
  userId: String
  question: Boolean
  authorIsUnreviewed: Boolean
  readTimeMinutesOverride: Float
  submitToFrontpage: Boolean
  hiddenRelatedQuestion: Boolean
  shortform: Boolean
  canonicalSource: String
  manifoldReviewMarketId: String
  tagRelevance: JSON
  noIndex: Boolean
  activateRSVPs: Boolean
  nextDayReminderSent: Boolean
  onlyVisibleToLoggedIn: Boolean
  onlyVisibleToEstablishedAccounts: Boolean
  hideFromRecentDiscussions: Boolean
  votingSystem: String
  podcastEpisodeId: String
  forceAllowType3Audio: Boolean
  legacy: Boolean
  legacyId: String
  legacySpam: Boolean
  feedId: String
  feedLink: String
  curatedDate: Date
  metaDate: Date
  suggestForCuratedUserIds: [String]
  frontpageDate: Date
  autoFrontpage: String
  collectionTitle: String
  coauthorStatuses: [JSON]
  hasCoauthorPermission: Boolean
  socialPreviewImageId: String
  socialPreviewImageAutoUrl: String
  socialPreview: JSON
  fmCrosspost: JSON
  canonicalSequenceId: String
  canonicalCollectionSlug: String
  canonicalBookId: String
  canonicalNextPostSlug: String
  canonicalPrevPostSlug: String
  unlisted: Boolean
  disableRecommendation: Boolean
  defaultRecommendation: Boolean
  hideFromPopularComments: Boolean
  draft: Boolean
  wasEverUndrafted: Boolean
  meta: Boolean
  hideFrontpageComments: Boolean
  bannedUserIds: [String]
  commentsLocked: Boolean
  commentsLockedToAccountsCreatedAfter: Date
  organizerIds: [String]
  groupId: String
  eventType: String
  isEvent: Boolean
  reviewedByUserId: String
  reviewForCuratedUserId: String
  startTime: Date
  endTime: Date
  eventRegistrationLink: String
  joinEventLink: String
  onlineEvent: Boolean
  globalEvent: Boolean
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  meetupLink: String
  website: String
  eventImageId: String
  types: [String]
  metaSticky: Boolean
  sharingSettings: JSON
  shareWithUsers: [String]
  linkSharingKey: String
  commentSortOrder: String
  hideAuthor: Boolean
  sideCommentVisibility: String
  disableSidenotes: Boolean
  moderationStyle: String
  ignoreRateLimits: Boolean
  hideCommentKarma: Boolean
  debate: Boolean
  collabEditorDialogue: Boolean
  rejected: Boolean
  rejectedReason: String
  rejectedByUserId: String
  subforumTagId: String
  af: Boolean
  afDate: Date
  afSticky: Boolean
  suggestForAlignmentUserIds: [String]
  reviewForAlignmentUserId: String
  agentFoundationsId: String
  swrCachingEnabled: Boolean
  generateDraftJargon: Boolean
}

input PostSelectorInput {
  AND: [PostSelectorInput]
  OR: [PostSelectorInput]
}

input PostSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PostOrderByInput {
  foobar
}

type RSSFeed {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  ownedByUser: Boolean
  displayFullContent: Boolean
  nickname: String
  url: String
  status: String
  rawFeed: JSON
  setCanonicalUrl: Boolean
  importAsDraft: Boolean
}

input DeleteRSSFeedInput {
  selector: RSSFeedSelectorUniqueInput!
}

input SingleRSSFeedInput {
  selector: RSSFeedSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiRSSFeedInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: RSSFeedSelectorInput
  orderBy: RSSFeedOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleRSSFeedOutput {
  result: RSSFeed
}

type MultiRSSFeedOutput {
  results: [RSSFeed]
  totalCount: Int
}

type RSSFeedOutput {
  data: RSSFeed
}

input CreateRSSFeedInput {
  data: CreateRSSFeedDataInput!
}

input CreateRSSFeedDataInput {
  legacyData: JSON
  userId: String
  ownedByUser: Boolean
  displayFullContent: Boolean
  nickname: String
  url: String
  rawFeed: JSON
  setCanonicalUrl: Boolean
  importAsDraft: Boolean
}

input UpdateRSSFeedInput {
  selector: RSSFeedSelectorUniqueInput!
  data: UpdateRSSFeedDataInput!
}

input UpsertRSSFeedInput {
  selector: RSSFeedSelectorUniqueInput!
  data: UpdateRSSFeedDataInput!
}

input UpdateRSSFeedDataInput {
  legacyData: JSON
  userId: String
  ownedByUser: Boolean
  displayFullContent: Boolean
  nickname: String
  url: String
  status: String
  rawFeed: JSON
  setCanonicalUrl: Boolean
  importAsDraft: Boolean
}

input RSSFeedSelectorInput {
  AND: [RSSFeedSelectorInput]
  OR: [RSSFeedSelectorInput]
}

input RSSFeedSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum RSSFeedOrderByInput {
  foobar
}

type ReadStatus {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteReadStatusInput {
  selector: ReadStatusSelectorUniqueInput!
}

input SingleReadStatusInput {
  selector: ReadStatusSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiReadStatusInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ReadStatusSelectorInput
  orderBy: ReadStatusOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReadStatusOutput {
  result: ReadStatus
}

type MultiReadStatusOutput {
  results: [ReadStatus]
  totalCount: Int
}

type ReadStatusOutput {
  data: ReadStatus
}

input CreateReadStatusInput {
  data: CreateReadStatusDataInput!
}

input CreateReadStatusDataInput {
  legacyData: JSON
}

input UpdateReadStatusInput {
  selector: ReadStatusSelectorUniqueInput!
  data: UpdateReadStatusDataInput!
}

input UpsertReadStatusInput {
  selector: ReadStatusSelectorUniqueInput!
  data: UpdateReadStatusDataInput!
}

input UpdateReadStatusDataInput {
  legacyData: JSON
}

input ReadStatusSelectorInput {
  AND: [ReadStatusSelectorInput]
  OR: [ReadStatusSelectorInput]
}

input ReadStatusSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ReadStatusOrderByInput {
  foobar
}

type RecommendationsCache {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  postId: String
  source: String
  scenario: String
  attributionId: String
  ttlMs: Float
}

input DeleteRecommendationsCacheInput {
  selector: RecommendationsCacheSelectorUniqueInput!
}

input SingleRecommendationsCacheInput {
  selector: RecommendationsCacheSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiRecommendationsCacheInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: RecommendationsCacheSelectorInput
  orderBy: RecommendationsCacheOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleRecommendationsCacheOutput {
  result: RecommendationsCache
}

type MultiRecommendationsCacheOutput {
  results: [RecommendationsCache]
  totalCount: Int
}

type RecommendationsCacheOutput {
  data: RecommendationsCache
}

input CreateRecommendationsCacheInput {
  data: CreateRecommendationsCacheDataInput!
}

input CreateRecommendationsCacheDataInput {
  legacyData: JSON
  userId: String!
  postId: String!
  source: String!
  scenario: String!
  attributionId: String!
  ttlMs: Float!
}

input UpdateRecommendationsCacheInput {
  selector: RecommendationsCacheSelectorUniqueInput!
  data: UpdateRecommendationsCacheDataInput!
}

input UpsertRecommendationsCacheInput {
  selector: RecommendationsCacheSelectorUniqueInput!
  data: UpdateRecommendationsCacheDataInput!
}

input UpdateRecommendationsCacheDataInput {
  legacyData: JSON
  userId: String
  postId: String
  source: String
  scenario: String
  attributionId: String
  ttlMs: Float
}

input RecommendationsCacheSelectorInput {
  AND: [RecommendationsCacheSelectorInput]
  OR: [RecommendationsCacheSelectorInput]
}

input RecommendationsCacheSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum RecommendationsCacheOrderByInput {
  foobar
}

type Report {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User!
  reportedUserId: String
  reportedUser: User
  commentId: String
  comment: Comment
  postId: String
  post: Post
  link: String
  claimedUserId: String
  claimedUser: User
  description: String
  closedAt: Date
  markedAsSpam: Boolean
  reportedAsSpam: Boolean
}

input DeleteReportInput {
  selector: ReportSelectorUniqueInput!
}

input SingleReportInput {
  selector: ReportSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiReportInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ReportSelectorInput
  orderBy: ReportOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReportOutput {
  result: Report
}

type MultiReportOutput {
  results: [Report]
  totalCount: Int
}

type ReportOutput {
  data: Report
}

input CreateReportInput {
  data: CreateReportDataInput!
}

input CreateReportDataInput {
  legacyData: JSON
  userId: String
  reportedUserId: String
  commentId: String
  postId: String
  link: String!
  claimedUserId: String
  description: String
  reportedAsSpam: Boolean
}

input UpdateReportInput {
  selector: ReportSelectorUniqueInput!
  data: UpdateReportDataInput!
}

input UpsertReportInput {
  selector: ReportSelectorUniqueInput!
  data: UpdateReportDataInput!
}

input UpdateReportDataInput {
  createdAt: Date
  legacyData: JSON
  claimedUserId: String
  description: String
  closedAt: Date
  markedAsSpam: Boolean
  reportedAsSpam: Boolean
}

input ReportSelectorInput {
  AND: [ReportSelectorInput]
  OR: [ReportSelectorInput]
}

input ReportSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ReportOrderByInput {
  foobar
}

type ReviewVote {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  postId: String
  post: Post
  qualitativeScore: Int
  quadraticScore: Int
  comment: String
  year: String
  dummy: Boolean
  reactions: [String]
}

input DeleteReviewVoteInput {
  selector: ReviewVoteSelectorUniqueInput!
}

input SingleReviewVoteInput {
  selector: ReviewVoteSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiReviewVoteInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ReviewVoteSelectorInput
  orderBy: ReviewVoteOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReviewVoteOutput {
  result: ReviewVote
}

type MultiReviewVoteOutput {
  results: [ReviewVote]
  totalCount: Int
}

type ReviewVoteOutput {
  data: ReviewVote
}

input CreateReviewVoteInput {
  data: CreateReviewVoteDataInput!
}

input CreateReviewVoteDataInput {
  legacyData: JSON
}

input UpdateReviewVoteInput {
  selector: ReviewVoteSelectorUniqueInput!
  data: UpdateReviewVoteDataInput!
}

input UpsertReviewVoteInput {
  selector: ReviewVoteSelectorUniqueInput!
  data: UpdateReviewVoteDataInput!
}

input UpdateReviewVoteDataInput {
  legacyData: JSON
}

input ReviewVoteSelectorInput {
  AND: [ReviewVoteSelectorInput]
  OR: [ReviewVoteSelectorInput]
}

input ReviewVoteSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ReviewVoteOrderByInput {
  foobar
}

type ReviewWinnerArt {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  postId: String
  splashArtImagePrompt: String
  splashArtImageUrl: String
  activeSplashArtCoordinates: SplashArtCoordinate
}

input DeleteReviewWinnerArtInput {
  selector: ReviewWinnerArtSelectorUniqueInput!
}

input SingleReviewWinnerArtInput {
  selector: ReviewWinnerArtSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiReviewWinnerArtInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ReviewWinnerArtSelectorInput
  orderBy: ReviewWinnerArtOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReviewWinnerArtOutput {
  result: ReviewWinnerArt
}

type MultiReviewWinnerArtOutput {
  results: [ReviewWinnerArt]
  totalCount: Int
}

type ReviewWinnerArtOutput {
  data: ReviewWinnerArt
}

input CreateReviewWinnerArtInput {
  data: CreateReviewWinnerArtDataInput!
}

input CreateReviewWinnerArtDataInput {
  legacyData: JSON
  postId: String!
  splashArtImagePrompt: String!
  splashArtImageUrl: String!
}

input UpdateReviewWinnerArtInput {
  selector: ReviewWinnerArtSelectorUniqueInput!
  data: UpdateReviewWinnerArtDataInput!
}

input UpsertReviewWinnerArtInput {
  selector: ReviewWinnerArtSelectorUniqueInput!
  data: UpdateReviewWinnerArtDataInput!
}

input UpdateReviewWinnerArtDataInput {
  legacyData: JSON
  postId: String
  splashArtImagePrompt: String
  splashArtImageUrl: String
}

input ReviewWinnerArtSelectorInput {
  AND: [ReviewWinnerArtSelectorInput]
  OR: [ReviewWinnerArtSelectorInput]
}

input ReviewWinnerArtSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ReviewWinnerArtOrderByInput {
  foobar
}

type ReviewWinner {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  postId: String
  post: Post!
  reviewWinnerArt: ReviewWinnerArt
  competitorCount: Int
  reviewYear: Float
  category: String
  curatedOrder: Float
  reviewRanking: Float
  isAI: Boolean
}

input DeleteReviewWinnerInput {
  selector: ReviewWinnerSelectorUniqueInput!
}

input SingleReviewWinnerInput {
  selector: ReviewWinnerSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiReviewWinnerInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ReviewWinnerSelectorInput
  orderBy: ReviewWinnerOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReviewWinnerOutput {
  result: ReviewWinner
}

type MultiReviewWinnerOutput {
  results: [ReviewWinner]
  totalCount: Int
}

type ReviewWinnerOutput {
  data: ReviewWinner
}

input CreateReviewWinnerInput {
  data: CreateReviewWinnerDataInput!
}

input CreateReviewWinnerDataInput {
  legacyData: JSON
  postId: String!
  reviewYear: Float!
  category: String!
  curatedOrder: Float
  reviewRanking: Float!
  isAI: Boolean
}

input UpdateReviewWinnerInput {
  selector: ReviewWinnerSelectorUniqueInput!
  data: UpdateReviewWinnerDataInput!
}

input UpsertReviewWinnerInput {
  selector: ReviewWinnerSelectorUniqueInput!
  data: UpdateReviewWinnerDataInput!
}

input UpdateReviewWinnerDataInput {
  legacyData: JSON
  postId: String
  reviewYear: Float
  category: String
  curatedOrder: Float
  reviewRanking: Float
  isAI: Boolean
}

input ReviewWinnerSelectorInput {
  AND: [ReviewWinnerSelectorInput]
  OR: [ReviewWinnerSelectorInput]
}

input ReviewWinnerSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ReviewWinnerOrderByInput {
  foobar
}

type Revision {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  documentId: String
  collectionName: String
  fieldName: String
  editedAt: Date
  updateType: String
  version: String
  commitMessage: String
  userId: String
  user: User
  draft: Boolean
  originalContents: ContentType
  html: String
  markdown: String
  draftJS: JSON
  ckEditorMarkup: String
  wordCount: Float
  htmlHighlight: String!
  htmlHighlightStartingAtHash(hash: String): String!
  plaintextDescription: String!
  plaintextMainText: String!
  hasFootnotes: Boolean
  changeMetrics: JSON
  googleDocMetadata: JSON
  skipAttributions: Boolean
  tag: Tag
  post: Post
  lens: MultiDocument
  summary: MultiDocument
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float
  baseScore: Float
  extendedScore: JSON
  score: Float
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input DeleteRevisionInput {
  selector: RevisionSelectorUniqueInput!
}

input SingleRevisionInput {
  selector: RevisionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiRevisionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: RevisionSelectorInput
  orderBy: RevisionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleRevisionOutput {
  result: Revision
}

type MultiRevisionOutput {
  results: [Revision]
  totalCount: Int
}

type RevisionOutput {
  data: Revision
}

input CreateRevisionInput {
  data: CreateRevisionDataInput!
}

input CreateRevisionDataInput {
  legacyData: JSON
  updateType: String
  commitMessage: String
}

input UpdateRevisionInput {
  selector: RevisionSelectorUniqueInput!
  data: UpdateRevisionDataInput!
}

input UpsertRevisionInput {
  selector: RevisionSelectorUniqueInput!
  data: UpdateRevisionDataInput!
}

input UpdateRevisionDataInput {
  legacyData: JSON
  skipAttributions: Boolean
}

input RevisionSelectorInput {
  AND: [RevisionSelectorInput]
  OR: [RevisionSelectorInput]
}

input RevisionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum RevisionOrderByInput {
  foobar
}

type Sequence {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  lastUpdated: Date
  userId: String
  user: User
  title: String
  bannerImageId: String
  gridImageId: String
  hideFromAuthorPage: Boolean
  draft: Boolean
  isDeleted: Boolean
  curatedOrder: Float
  userProfileOrder: Float
  canonicalCollectionSlug: String
  canonicalCollection: Collection
  hidden: Boolean
  noindex: Boolean
  postsCount: Int!
  readPostsCount: Int!
  chapters: [Chapter]
  af: Boolean
}

input DeleteSequenceInput {
  selector: SequenceSelectorUniqueInput!
}

input SingleSequenceInput {
  selector: SequenceSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSequenceInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SequenceSelectorInput
  orderBy: SequenceOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSequenceOutput {
  result: Sequence
}

type MultiSequenceOutput {
  results: [Sequence]
  totalCount: Int
}

type SequenceOutput {
  data: Sequence
}

input CreateSequenceInput {
  data: CreateSequenceDataInput!
}

input CreateSequenceDataInput {
  legacyData: JSON
  contents: JSON
  lastUpdated: Date
  userId: String
  title: String!
  bannerImageId: String
  gridImageId: String
  hideFromAuthorPage: Boolean
  draft: Boolean
  isDeleted: Boolean
  curatedOrder: Float
  userProfileOrder: Float
  canonicalCollectionSlug: String
  hidden: Boolean
  noindex: Boolean
  af: Boolean
}

input UpdateSequenceInput {
  selector: SequenceSelectorUniqueInput!
  data: UpdateSequenceDataInput!
}

input UpsertSequenceInput {
  selector: SequenceSelectorUniqueInput!
  data: UpdateSequenceDataInput!
}

input UpdateSequenceDataInput {
  legacyData: JSON
  contents: JSON
  lastUpdated: Date
  userId: String
  title: String
  bannerImageId: String
  gridImageId: String
  hideFromAuthorPage: Boolean
  draft: Boolean
  isDeleted: Boolean
  curatedOrder: Float
  userProfileOrder: Float
  canonicalCollectionSlug: String
  hidden: Boolean
  noindex: Boolean
  af: Boolean
}

input SequenceSelectorInput {
  AND: [SequenceSelectorInput]
  OR: [SequenceSelectorInput]
}

input SequenceSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SequenceOrderByInput {
  foobar
}

type Session {
  _id: String
  session: JSON
  expires: Date
  lastModified: Date
}

input DeleteSessionInput {
  selector: SessionSelectorUniqueInput!
}

input SingleSessionInput {
  selector: SessionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSessionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SessionSelectorInput
  orderBy: SessionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSessionOutput {
  result: Session
}

type MultiSessionOutput {
  results: [Session]
  totalCount: Int
}

type SessionOutput {
  data: Session
}

input CreateSessionInput {
  data: CreateSessionDataInput!
}

input CreateSessionDataInput {
  _id: String!
  session: JSON
  expires: Date
  lastModified: Date
}

input UpdateSessionInput {
  selector: SessionSelectorUniqueInput!
  data: UpdateSessionDataInput!
}

input UpsertSessionInput {
  selector: SessionSelectorUniqueInput!
  data: UpdateSessionDataInput!
}

input UpdateSessionDataInput {
  _id: String
  session: JSON
  expires: Date
  lastModified: Date
}

input SessionSelectorInput {
  AND: [SessionSelectorInput]
  OR: [SessionSelectorInput]
}

input SessionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SessionOrderByInput {
  foobar
}

type SideCommentCache {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  postId: String
  annotatedHtml: String
  commentsByBlock: JSON
  version: Float
}

input DeleteSideCommentCacheInput {
  selector: SideCommentCacheSelectorUniqueInput!
}

input SingleSideCommentCacheInput {
  selector: SideCommentCacheSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSideCommentCacheInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SideCommentCacheSelectorInput
  orderBy: SideCommentCacheOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSideCommentCacheOutput {
  result: SideCommentCache
}

type MultiSideCommentCacheOutput {
  results: [SideCommentCache]
  totalCount: Int
}

type SideCommentCacheOutput {
  data: SideCommentCache
}

input CreateSideCommentCacheInput {
  data: CreateSideCommentCacheDataInput!
}

input CreateSideCommentCacheDataInput {
  legacyData: JSON
}

input UpdateSideCommentCacheInput {
  selector: SideCommentCacheSelectorUniqueInput!
  data: UpdateSideCommentCacheDataInput!
}

input UpsertSideCommentCacheInput {
  selector: SideCommentCacheSelectorUniqueInput!
  data: UpdateSideCommentCacheDataInput!
}

input UpdateSideCommentCacheDataInput {
  legacyData: JSON
}

input SideCommentCacheSelectorInput {
  AND: [SideCommentCacheSelectorInput]
  OR: [SideCommentCacheSelectorInput]
}

input SideCommentCacheSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SideCommentCacheOrderByInput {
  foobar
}

type SplashArtCoordinate {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  reviewWinnerArtId: String
  reviewWinnerArt: ReviewWinnerArt!
  leftXPct: Float
  leftYPct: Float
  leftHeightPct: Float
  leftWidthPct: Float
  leftFlipped: Boolean
  middleXPct: Float
  middleYPct: Float
  middleHeightPct: Float
  middleWidthPct: Float
  middleFlipped: Boolean
  rightXPct: Float
  rightYPct: Float
  rightHeightPct: Float
  rightWidthPct: Float
  rightFlipped: Boolean
}

input DeleteSplashArtCoordinateInput {
  selector: SplashArtCoordinateSelectorUniqueInput!
}

input SingleSplashArtCoordinateInput {
  selector: SplashArtCoordinateSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSplashArtCoordinateInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SplashArtCoordinateSelectorInput
  orderBy: SplashArtCoordinateOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSplashArtCoordinateOutput {
  result: SplashArtCoordinate
}

type MultiSplashArtCoordinateOutput {
  results: [SplashArtCoordinate]
  totalCount: Int
}

type SplashArtCoordinateOutput {
  data: SplashArtCoordinate
}

input CreateSplashArtCoordinateInput {
  data: CreateSplashArtCoordinateDataInput!
}

input CreateSplashArtCoordinateDataInput {
  legacyData: JSON
  reviewWinnerArtId: String!
  leftXPct: Float!
  leftYPct: Float!
  leftHeightPct: Float!
  leftWidthPct: Float!
  leftFlipped: Boolean
  middleXPct: Float!
  middleYPct: Float!
  middleHeightPct: Float!
  middleWidthPct: Float!
  middleFlipped: Boolean
  rightXPct: Float!
  rightYPct: Float!
  rightHeightPct: Float!
  rightWidthPct: Float!
  rightFlipped: Boolean!
}

input UpdateSplashArtCoordinateInput {
  selector: SplashArtCoordinateSelectorUniqueInput!
  data: UpdateSplashArtCoordinateDataInput!
}

input UpsertSplashArtCoordinateInput {
  selector: SplashArtCoordinateSelectorUniqueInput!
  data: UpdateSplashArtCoordinateDataInput!
}

input UpdateSplashArtCoordinateDataInput {
  legacyData: JSON
  reviewWinnerArtId: String
  leftXPct: Float
  leftYPct: Float
  leftHeightPct: Float
  leftWidthPct: Float
  leftFlipped: Boolean
  middleXPct: Float
  middleYPct: Float
  middleHeightPct: Float
  middleWidthPct: Float
  middleFlipped: Boolean
  rightXPct: Float
  rightYPct: Float
  rightHeightPct: Float
  rightWidthPct: Float
  rightFlipped: Boolean
}

input SplashArtCoordinateSelectorInput {
  AND: [SplashArtCoordinateSelectorInput]
  OR: [SplashArtCoordinateSelectorInput]
}

input SplashArtCoordinateSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SplashArtCoordinateOrderByInput {
  foobar
}

type Spotlight {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  description(version: String): Revision
  description_latest: String
  documentId: String
  document: Post!
  post: Post
  sequence: Sequence
  tag: Tag
  documentType: String
  position: Float
  duration: Float
  customTitle: String
  customSubtitle: String
  subtitleUrl: String
  headerTitle: String
  headerTitleLeftColor: String
  headerTitleRightColor: String
  lastPromotedAt: Date
  spotlightSplashImageUrl: String
  draft: Boolean
  deletedDraft: Boolean
  showAuthor: Boolean
  imageFade: Boolean
  imageFadeColor: String
  spotlightImageId: String
  spotlightDarkImageId: String
  sequenceChapters: [Chapter]
}

input DeleteSpotlightInput {
  selector: SpotlightSelectorUniqueInput!
}

input SingleSpotlightInput {
  selector: SpotlightSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSpotlightInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SpotlightSelectorInput
  orderBy: SpotlightOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSpotlightOutput {
  result: Spotlight
}

type MultiSpotlightOutput {
  results: [Spotlight]
  totalCount: Int
}

type SpotlightOutput {
  data: Spotlight
}

input CreateSpotlightInput {
  data: CreateSpotlightDataInput!
}

input CreateSpotlightDataInput {
  legacyData: JSON
  description: JSON
  documentId: String!
  documentType: String!
  position: Float
  duration: Float!
  customTitle: String
  customSubtitle: String
  subtitleUrl: String
  headerTitle: String
  headerTitleLeftColor: String
  headerTitleRightColor: String
  lastPromotedAt: Date!
  spotlightSplashImageUrl: String
  draft: Boolean!
  showAuthor: Boolean
  imageFade: Boolean
  imageFadeColor: String
  spotlightImageId: String
  spotlightDarkImageId: String
}

input UpdateSpotlightInput {
  selector: SpotlightSelectorUniqueInput!
  data: UpdateSpotlightDataInput!
}

input UpsertSpotlightInput {
  selector: SpotlightSelectorUniqueInput!
  data: UpdateSpotlightDataInput!
}

input UpdateSpotlightDataInput {
  legacyData: JSON
  description: JSON
  documentId: String
  documentType: String
  position: Float
  duration: Float
  customTitle: String
  customSubtitle: String
  subtitleUrl: String
  headerTitle: String
  headerTitleLeftColor: String
  headerTitleRightColor: String
  lastPromotedAt: Date
  spotlightSplashImageUrl: String
  draft: Boolean
  deletedDraft: Boolean
  showAuthor: Boolean
  imageFade: Boolean
  imageFadeColor: String
  spotlightImageId: String
  spotlightDarkImageId: String
}

input SpotlightSelectorInput {
  AND: [SpotlightSelectorInput]
  OR: [SpotlightSelectorInput]
}

input SpotlightSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SpotlightOrderByInput {
  foobar
}

type Subscription {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User!
  state: String
  documentId: String
  collectionName: String
  deleted: Boolean
  type: String
}

input DeleteSubscriptionInput {
  selector: SubscriptionSelectorUniqueInput!
}

input SingleSubscriptionInput {
  selector: SubscriptionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSubscriptionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SubscriptionSelectorInput
  orderBy: SubscriptionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSubscriptionOutput {
  result: Subscription
}

type MultiSubscriptionOutput {
  results: [Subscription]
  totalCount: Int
}

type SubscriptionOutput {
  data: Subscription
}

input CreateSubscriptionInput {
  data: CreateSubscriptionDataInput!
}

input CreateSubscriptionDataInput {
  legacyData: JSON
  state: String!
  documentId: String!
  collectionName: String!
  type: String!
}

input UpdateSubscriptionInput {
  selector: SubscriptionSelectorUniqueInput!
  data: UpdateSubscriptionDataInput!
}

input UpsertSubscriptionInput {
  selector: SubscriptionSelectorUniqueInput!
  data: UpdateSubscriptionDataInput!
}

input UpdateSubscriptionDataInput {
  legacyData: JSON
}

input SubscriptionSelectorInput {
  AND: [SubscriptionSelectorInput]
  OR: [SubscriptionSelectorInput]
}

input SubscriptionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SubscriptionOrderByInput {
  foobar
}

type SurveyQuestion {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  surveyId: String
  survey: Survey!
  question: String
  format: String
  order: Float
}

input DeleteSurveyQuestionInput {
  selector: SurveyQuestionSelectorUniqueInput!
}

input SingleSurveyQuestionInput {
  selector: SurveyQuestionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSurveyQuestionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SurveyQuestionSelectorInput
  orderBy: SurveyQuestionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSurveyQuestionOutput {
  result: SurveyQuestion
}

type MultiSurveyQuestionOutput {
  results: [SurveyQuestion]
  totalCount: Int
}

type SurveyQuestionOutput {
  data: SurveyQuestion
}

input CreateSurveyQuestionInput {
  data: CreateSurveyQuestionDataInput!
}

input CreateSurveyQuestionDataInput {
  legacyData: JSON
  surveyId: String!
  question: String!
  format: String!
  order: Float!
}

input UpdateSurveyQuestionInput {
  selector: SurveyQuestionSelectorUniqueInput!
  data: UpdateSurveyQuestionDataInput!
}

input UpsertSurveyQuestionInput {
  selector: SurveyQuestionSelectorUniqueInput!
  data: UpdateSurveyQuestionDataInput!
}

input UpdateSurveyQuestionDataInput {
  legacyData: JSON
  surveyId: String
  question: String
  format: String
  order: Float
}

input SurveyQuestionSelectorInput {
  AND: [SurveyQuestionSelectorInput]
  OR: [SurveyQuestionSelectorInput]
}

input SurveyQuestionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SurveyQuestionOrderByInput {
  foobar
}

type SurveyResponse {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  surveyId: String
  survey: Survey!
  surveyScheduleId: String
  surveySchedule: SurveySchedule
  userId: String
  user: User
  clientId: String
  client: ClientId
  response: JSON
}

input DeleteSurveyResponseInput {
  selector: SurveyResponseSelectorUniqueInput!
}

input SingleSurveyResponseInput {
  selector: SurveyResponseSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSurveyResponseInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SurveyResponseSelectorInput
  orderBy: SurveyResponseOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSurveyResponseOutput {
  result: SurveyResponse
}

type MultiSurveyResponseOutput {
  results: [SurveyResponse]
  totalCount: Int
}

type SurveyResponseOutput {
  data: SurveyResponse
}

input CreateSurveyResponseInput {
  data: CreateSurveyResponseDataInput!
}

input CreateSurveyResponseDataInput {
  legacyData: JSON
  surveyId: String!
  surveyScheduleId: String!
  userId: String!
  clientId: String!
  response: JSON!
}

input UpdateSurveyResponseInput {
  selector: SurveyResponseSelectorUniqueInput!
  data: UpdateSurveyResponseDataInput!
}

input UpsertSurveyResponseInput {
  selector: SurveyResponseSelectorUniqueInput!
  data: UpdateSurveyResponseDataInput!
}

input UpdateSurveyResponseDataInput {
  legacyData: JSON
  surveyId: String
  surveyScheduleId: String
  userId: String
  clientId: String
  response: JSON
}

input SurveyResponseSelectorInput {
  AND: [SurveyResponseSelectorInput]
  OR: [SurveyResponseSelectorInput]
}

input SurveyResponseSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SurveyResponseOrderByInput {
  foobar
}

type SurveySchedule {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  surveyId: String
  survey: Survey!
  name: String
  impressionsLimit: Float
  maxVisitorPercentage: Float
  minKarma: Float
  maxKarma: Float
  target: String
  startDate: Date
  endDate: Date
  deactivated: Boolean
  clientIds: [String]
  clients: [ClientId!]!
}

input DeleteSurveyScheduleInput {
  selector: SurveyScheduleSelectorUniqueInput!
}

input SingleSurveyScheduleInput {
  selector: SurveyScheduleSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSurveyScheduleInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SurveyScheduleSelectorInput
  orderBy: SurveyScheduleOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSurveyScheduleOutput {
  result: SurveySchedule
}

type MultiSurveyScheduleOutput {
  results: [SurveySchedule]
  totalCount: Int
}

type SurveyScheduleOutput {
  data: SurveySchedule
}

input CreateSurveyScheduleInput {
  data: CreateSurveyScheduleDataInput!
}

input CreateSurveyScheduleDataInput {
  legacyData: JSON
  surveyId: String!
  name: String!
  impressionsLimit: Float
  maxVisitorPercentage: Float
  minKarma: Float
  maxKarma: Float
  target: String!
  startDate: Date
  endDate: Date
  deactivated: Boolean
  clientIds: [String]!
}

input UpdateSurveyScheduleInput {
  selector: SurveyScheduleSelectorUniqueInput!
  data: UpdateSurveyScheduleDataInput!
}

input UpsertSurveyScheduleInput {
  selector: SurveyScheduleSelectorUniqueInput!
  data: UpdateSurveyScheduleDataInput!
}

input UpdateSurveyScheduleDataInput {
  legacyData: JSON
  surveyId: String
  name: String
  impressionsLimit: Float
  maxVisitorPercentage: Float
  minKarma: Float
  maxKarma: Float
  target: String
  startDate: Date
  endDate: Date
  deactivated: Boolean
  clientIds: [String]
}

input SurveyScheduleSelectorInput {
  AND: [SurveyScheduleSelectorInput]
  OR: [SurveyScheduleSelectorInput]
}

input SurveyScheduleSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SurveyScheduleOrderByInput {
  foobar
}

type Survey {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  name: String
  questions: [SurveyQuestion!]!
}

input DeleteSurveyInput {
  selector: SurveySelectorUniqueInput!
}

input SingleSurveyInput {
  selector: SurveySelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSurveyInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SurveySelectorInput
  orderBy: SurveyOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSurveyOutput {
  result: Survey
}

type MultiSurveyOutput {
  results: [Survey]
  totalCount: Int
}

type SurveyOutput {
  data: Survey
}

input CreateSurveyInput {
  data: CreateSurveyDataInput!
}

input CreateSurveyDataInput {
  legacyData: JSON
  name: String!
}

input UpdateSurveyInput {
  selector: SurveySelectorUniqueInput!
  data: UpdateSurveyDataInput!
}

input UpsertSurveyInput {
  selector: SurveySelectorUniqueInput!
  data: UpdateSurveyDataInput!
}

input UpdateSurveyDataInput {
  legacyData: JSON
  name: String
}

input SurveySelectorInput {
  AND: [SurveySelectorInput]
  OR: [SurveySelectorInput]
}

input SurveySelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SurveyOrderByInput {
  foobar
}

type TagFlag {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  slug: String
  name: String
  deleted: Boolean
  order: Float
}

input DeleteTagFlagInput {
  selector: TagFlagSelectorUniqueInput!
}

input SingleTagFlagInput {
  selector: TagFlagSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiTagFlagInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: TagFlagSelectorInput
  orderBy: TagFlagOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTagFlagOutput {
  result: TagFlag
}

type MultiTagFlagOutput {
  results: [TagFlag]
  totalCount: Int
}

type TagFlagOutput {
  data: TagFlag
}

input CreateTagFlagInput {
  data: CreateTagFlagDataInput!
}

input CreateTagFlagDataInput {
  legacyData: JSON
  contents: JSON
  name: String!
  deleted: Boolean
  order: Float
}

input UpdateTagFlagInput {
  selector: TagFlagSelectorUniqueInput!
  data: UpdateTagFlagDataInput!
}

input UpsertTagFlagInput {
  selector: TagFlagSelectorUniqueInput!
  data: UpdateTagFlagDataInput!
}

input UpdateTagFlagDataInput {
  legacyData: JSON
  contents: JSON
  name: String
  deleted: Boolean
  order: Float
}

input TagFlagSelectorInput {
  AND: [TagFlagSelectorInput]
  OR: [TagFlagSelectorInput]
}

input TagFlagSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum TagFlagOrderByInput {
  foobar
}

type TagRel {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  tagId: String
  tag: Tag
  postId: String
  post: Post
  deleted: Boolean
  userId: String
  user: User
  currentUserCanVote: Boolean!
  autoApplied: Boolean!
  backfilled: Boolean
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float
  baseScore: Float
  extendedScore: JSON
  score: Float
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input DeleteTagRelInput {
  selector: TagRelSelectorUniqueInput!
}

input SingleTagRelInput {
  selector: TagRelSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiTagRelInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: TagRelSelectorInput
  orderBy: TagRelOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTagRelOutput {
  result: TagRel
}

type MultiTagRelOutput {
  results: [TagRel]
  totalCount: Int
}

type TagRelOutput {
  data: TagRel
}

input CreateTagRelInput {
  data: CreateTagRelDataInput!
}

input CreateTagRelDataInput {
  legacyData: JSON
  tagId: String!
  postId: String!
  userId: String!
}

input UpdateTagRelInput {
  selector: TagRelSelectorUniqueInput!
  data: UpdateTagRelDataInput!
}

input UpsertTagRelInput {
  selector: TagRelSelectorUniqueInput!
  data: UpdateTagRelDataInput!
}

input UpdateTagRelDataInput {
  legacyData: JSON
  deleted: Boolean
}

input TagRelSelectorInput {
  AND: [TagRelSelectorInput]
  OR: [TagRelSelectorInput]
}

input TagRelSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum TagRelOrderByInput {
  foobar
}

type Tag {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  description(version: String): Revision
  description_latest: String
  pingbacks: JSON
  subforumWelcomeText(version: String): Revision
  subforumWelcomeText_latest: String
  moderationGuidelines(version: String): Revision
  moderationGuidelines_latest: String
  slug: String
  oldSlugs: [String]
  name: String
  shortName: String
  subtitle: String
  core: Boolean
  isPostType: Boolean
  suggestedAsFilter: Boolean
  defaultOrder: Float
  descriptionTruncationCount: Float
  postCount: Float
  userId: String
  user: User
  adminOnly: Boolean
  canEditUserIds: [String]
  charsAdded: Float
  charsRemoved: Float
  deleted: Boolean
  lastCommentedAt: Date
  lastSubforumCommentAt: Date
  needsReview: Boolean
  reviewedByUserId: String
  reviewedByUser: User
  wikiGrade: Int
  recentComments(tagCommentsLimit: Int, maxAgeHours: Int, af: Boolean, tagCommentType: String): [Comment]
  wikiOnly: Boolean
  bannerImageId: String
  squareImageId: String
  tagFlagsIds: [String]
  tagFlags: [TagFlag!]!
  lesswrongWikiImportRevision: String
  lesswrongWikiImportSlug: String
  lesswrongWikiImportCompleted: Boolean
  lastVisitedAt: Date
  isRead: Boolean
  tableOfContents(version: String): JSON
  htmlWithContributorAnnotations: String
  contributors(limit: Int, version: String): TagContributorsList
  contributionStats: JSON
  introSequenceId: String
  sequence: Sequence
  postsDefaultSortOrder: String
  canVoteOnRels: [String]
  isSubforum: Boolean
  subforumUnreadMessagesCount: Int
  subforumModeratorIds: [String]
  subforumModerators: [User!]!
  subforumIntroPostId: String
  subforumIntroPost: Post
  parentTagId: String
  parentTag: Tag
  subTagIds: [String]
  subTags: [Tag!]!
  autoTagModel: String
  autoTagPrompt: String
  noindex: Boolean
  lenses(lensSlug: String, version: String): [MultiDocument!]!
  lensesIncludingDeleted(lensSlug: String, version: String): [MultiDocument!]!
  isPlaceholderPage: Boolean
  summaries: [MultiDocument!]!
  textLastUpdatedAt: Date
  isArbitalImport: Boolean
  arbitalLinkedPages: ArbitalLinkedPages
  coreTagId: String
  maxScore: Int
  usersWhoLiked: [UserLikingTag!]!
  forceAllowType3Audio: Boolean
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float
  baseScore: Float
  extendedScore: JSON
  score: Float
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input DeleteTagInput {
  selector: TagSelectorUniqueInput!
}

input SingleTagInput {
  selector: TagSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiTagInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: TagSelectorInput
  orderBy: TagOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTagOutput {
  result: Tag
}

type MultiTagOutput {
  results: [Tag]
  totalCount: Int
}

type TagOutput {
  data: Tag
}

input CreateTagInput {
  data: CreateTagDataInput!
}

input CreateTagDataInput {
  legacyData: JSON
  description: JSON
  subforumWelcomeText: JSON
  moderationGuidelines: JSON
  slug: String
  name: String!
  shortName: String
  subtitle: String
  core: Boolean
  isPostType: Boolean
  suggestedAsFilter: Boolean
  defaultOrder: Float
  descriptionTruncationCount: Float
  adminOnly: Boolean
  canEditUserIds: [String]
  reviewedByUserId: String
  wikiGrade: Int
  wikiOnly: Boolean
  bannerImageId: String
  squareImageId: String
  tagFlagsIds: [String]
  introSequenceId: String
  postsDefaultSortOrder: String
  canVoteOnRels: [String]
  isSubforum: Boolean
  subforumModeratorIds: [String]
  subforumIntroPostId: String
  parentTagId: String
  subTagIds: [String]
  autoTagModel: String
  autoTagPrompt: String
  coreTagId: String
  forceAllowType3Audio: Boolean
}

input UpdateTagInput {
  selector: TagSelectorUniqueInput!
  data: UpdateTagDataInput!
}

input UpsertTagInput {
  selector: TagSelectorUniqueInput!
  data: UpdateTagDataInput!
}

input UpdateTagDataInput {
  legacyData: JSON
  description: JSON
  subforumWelcomeText: JSON
  moderationGuidelines: JSON
  slug: String
  name: String
  shortName: String
  subtitle: String
  core: Boolean
  isPostType: Boolean
  suggestedAsFilter: Boolean
  defaultOrder: Float
  descriptionTruncationCount: Float
  adminOnly: Boolean
  canEditUserIds: [String]
  deleted: Boolean
  needsReview: Boolean
  reviewedByUserId: String
  wikiGrade: Int
  wikiOnly: Boolean
  bannerImageId: String
  squareImageId: String
  tagFlagsIds: [String]
  introSequenceId: String
  postsDefaultSortOrder: String
  canVoteOnRels: [String]
  isSubforum: Boolean
  subforumModeratorIds: [String]
  subforumIntroPostId: String
  parentTagId: String
  subTagIds: [String]
  autoTagModel: String
  autoTagPrompt: String
  noindex: Boolean
  isPlaceholderPage: Boolean
  coreTagId: String
  forceAllowType3Audio: Boolean
}

input TagSelectorInput {
  AND: [TagSelectorInput]
  OR: [TagSelectorInput]
}

input TagSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum TagOrderByInput {
  foobar
}

type Tweet {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteTweetInput {
  selector: TweetSelectorUniqueInput!
}

input SingleTweetInput {
  selector: TweetSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiTweetInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: TweetSelectorInput
  orderBy: TweetOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTweetOutput {
  result: Tweet
}

type MultiTweetOutput {
  results: [Tweet]
  totalCount: Int
}

type TweetOutput {
  data: Tweet
}

input CreateTweetInput {
  data: CreateTweetDataInput!
}

input CreateTweetDataInput {
  legacyData: JSON
}

input UpdateTweetInput {
  selector: TweetSelectorUniqueInput!
  data: UpdateTweetDataInput!
}

input UpsertTweetInput {
  selector: TweetSelectorUniqueInput!
  data: UpdateTweetDataInput!
}

input UpdateTweetDataInput {
  legacyData: JSON
}

input TweetSelectorInput {
  AND: [TweetSelectorInput]
  OR: [TweetSelectorInput]
}

input TweetSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum TweetOrderByInput {
  foobar
}

type TypingIndicator {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  documentId: String
  lastUpdated: Date
}

input DeleteTypingIndicatorInput {
  selector: TypingIndicatorSelectorUniqueInput!
}

input SingleTypingIndicatorInput {
  selector: TypingIndicatorSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiTypingIndicatorInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: TypingIndicatorSelectorInput
  orderBy: TypingIndicatorOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTypingIndicatorOutput {
  result: TypingIndicator
}

type MultiTypingIndicatorOutput {
  results: [TypingIndicator]
  totalCount: Int
}

type TypingIndicatorOutput {
  data: TypingIndicator
}

input CreateTypingIndicatorInput {
  data: CreateTypingIndicatorDataInput!
}

input CreateTypingIndicatorDataInput {
  legacyData: JSON
  userId: String!
  documentId: String!
  lastUpdated: Date!
}

input UpdateTypingIndicatorInput {
  selector: TypingIndicatorSelectorUniqueInput!
  data: UpdateTypingIndicatorDataInput!
}

input UpsertTypingIndicatorInput {
  selector: TypingIndicatorSelectorUniqueInput!
  data: UpdateTypingIndicatorDataInput!
}

input UpdateTypingIndicatorDataInput {
  legacyData: JSON
  lastUpdated: Date
}

input TypingIndicatorSelectorInput {
  AND: [TypingIndicatorSelectorInput]
  OR: [TypingIndicatorSelectorInput]
}

input TypingIndicatorSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum TypingIndicatorOrderByInput {
  foobar
}

type UserActivity {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteUserActivityInput {
  selector: UserActivitySelectorUniqueInput!
}

input SingleUserActivityInput {
  selector: UserActivitySelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiUserActivityInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: UserActivitySelectorInput
  orderBy: UserActivityOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserActivityOutput {
  result: UserActivity
}

type MultiUserActivityOutput {
  results: [UserActivity]
  totalCount: Int
}

type UserActivityOutput {
  data: UserActivity
}

input CreateUserActivityInput {
  data: CreateUserActivityDataInput!
}

input CreateUserActivityDataInput {
  legacyData: JSON
}

input UpdateUserActivityInput {
  selector: UserActivitySelectorUniqueInput!
  data: UpdateUserActivityDataInput!
}

input UpsertUserActivityInput {
  selector: UserActivitySelectorUniqueInput!
  data: UpdateUserActivityDataInput!
}

input UpdateUserActivityDataInput {
  legacyData: JSON
}

input UserActivitySelectorInput {
  AND: [UserActivitySelectorInput]
  OR: [UserActivitySelectorInput]
}

input UserActivitySelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum UserActivityOrderByInput {
  foobar
}

type UserEAGDetail {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  careerStage: [String]
  countryOrRegion: String
  nearestCity: String
  willingnessToRelocate: JSON
  experiencedIn: [String]
  interestedIn: [String]
  lastUpdated: Date
}

input DeleteUserEAGDetailInput {
  selector: UserEAGDetailSelectorUniqueInput!
}

input SingleUserEAGDetailInput {
  selector: UserEAGDetailSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiUserEAGDetailInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: UserEAGDetailSelectorInput
  orderBy: UserEAGDetailOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserEAGDetailOutput {
  result: UserEAGDetail
}

type MultiUserEAGDetailOutput {
  results: [UserEAGDetail]
  totalCount: Int
}

type UserEAGDetailOutput {
  data: UserEAGDetail
}

input CreateUserEAGDetailInput {
  data: CreateUserEAGDetailDataInput!
}

input CreateUserEAGDetailDataInput {
  legacyData: JSON
  lastUpdated: Date
}

input UpdateUserEAGDetailInput {
  selector: UserEAGDetailSelectorUniqueInput!
  data: UpdateUserEAGDetailDataInput!
}

input UpsertUserEAGDetailInput {
  selector: UserEAGDetailSelectorUniqueInput!
  data: UpdateUserEAGDetailDataInput!
}

input UpdateUserEAGDetailDataInput {
  legacyData: JSON
  careerStage: [String]
  countryOrRegion: String
  nearestCity: String
  willingnessToRelocate: JSON
  experiencedIn: [String]
  interestedIn: [String]
  lastUpdated: Date
}

input UserEAGDetailSelectorInput {
  AND: [UserEAGDetailSelectorInput]
  OR: [UserEAGDetailSelectorInput]
}

input UserEAGDetailSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum UserEAGDetailOrderByInput {
  foobar
}

type UserJobAd {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  jobName: String
  adState: String
  reminderSetAt: Date
  lastUpdated: Date
}

input DeleteUserJobAdInput {
  selector: UserJobAdSelectorUniqueInput!
}

input SingleUserJobAdInput {
  selector: UserJobAdSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiUserJobAdInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: UserJobAdSelectorInput
  orderBy: UserJobAdOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserJobAdOutput {
  result: UserJobAd
}

type MultiUserJobAdOutput {
  results: [UserJobAd]
  totalCount: Int
}

type UserJobAdOutput {
  data: UserJobAd
}

input CreateUserJobAdInput {
  data: CreateUserJobAdDataInput!
}

input CreateUserJobAdDataInput {
  legacyData: JSON
  userId: String!
  jobName: String!
  adState: String!
  reminderSetAt: Date
  lastUpdated: Date
}

input UpdateUserJobAdInput {
  selector: UserJobAdSelectorUniqueInput!
  data: UpdateUserJobAdDataInput!
}

input UpsertUserJobAdInput {
  selector: UserJobAdSelectorUniqueInput!
  data: UpdateUserJobAdDataInput!
}

input UpdateUserJobAdDataInput {
  legacyData: JSON
  adState: String
  reminderSetAt: Date
  lastUpdated: Date
}

input UserJobAdSelectorInput {
  AND: [UserJobAdSelectorInput]
  OR: [UserJobAdSelectorInput]
}

input UserJobAdSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum UserJobAdOrderByInput {
  foobar
}

type UserMostValuablePost {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  postId: String
  post: Post
  deleted: Boolean
}

input DeleteUserMostValuablePostInput {
  selector: UserMostValuablePostSelectorUniqueInput!
}

input SingleUserMostValuablePostInput {
  selector: UserMostValuablePostSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiUserMostValuablePostInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: UserMostValuablePostSelectorInput
  orderBy: UserMostValuablePostOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserMostValuablePostOutput {
  result: UserMostValuablePost
}

type MultiUserMostValuablePostOutput {
  results: [UserMostValuablePost]
  totalCount: Int
}

type UserMostValuablePostOutput {
  data: UserMostValuablePost
}

input CreateUserMostValuablePostInput {
  data: CreateUserMostValuablePostDataInput!
}

input CreateUserMostValuablePostDataInput {
  legacyData: JSON
  userId: String!
  postId: String!
  deleted: Boolean
}

input UpdateUserMostValuablePostInput {
  selector: UserMostValuablePostSelectorUniqueInput!
  data: UpdateUserMostValuablePostDataInput!
}

input UpsertUserMostValuablePostInput {
  selector: UserMostValuablePostSelectorUniqueInput!
  data: UpdateUserMostValuablePostDataInput!
}

input UpdateUserMostValuablePostDataInput {
  legacyData: JSON
  userId: String
  postId: String
  deleted: Boolean
}

input UserMostValuablePostSelectorInput {
  AND: [UserMostValuablePostSelectorInput]
  OR: [UserMostValuablePostSelectorInput]
}

input UserMostValuablePostSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum UserMostValuablePostOrderByInput {
  foobar
}

type UserRateLimit {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  type: String
  intervalUnit: String
  intervalLength: Float
  actionsPerInterval: Float
  endedAt: Date
}

input DeleteUserRateLimitInput {
  selector: UserRateLimitSelectorUniqueInput!
}

input SingleUserRateLimitInput {
  selector: UserRateLimitSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiUserRateLimitInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: UserRateLimitSelectorInput
  orderBy: UserRateLimitOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserRateLimitOutput {
  result: UserRateLimit
}

type MultiUserRateLimitOutput {
  results: [UserRateLimit]
  totalCount: Int
}

type UserRateLimitOutput {
  data: UserRateLimit
}

input CreateUserRateLimitInput {
  data: CreateUserRateLimitDataInput!
}

input CreateUserRateLimitDataInput {
  legacyData: JSON
  userId: String!
  type: String!
  intervalUnit: String!
  intervalLength: Float!
  actionsPerInterval: Float!
  endedAt: Date
}

input UpdateUserRateLimitInput {
  selector: UserRateLimitSelectorUniqueInput!
  data: UpdateUserRateLimitDataInput!
}

input UpsertUserRateLimitInput {
  selector: UserRateLimitSelectorUniqueInput!
  data: UpdateUserRateLimitDataInput!
}

input UpdateUserRateLimitDataInput {
  legacyData: JSON
  userId: String
  type: String
  intervalUnit: String
  intervalLength: Float
  actionsPerInterval: Float
  endedAt: Date
}

input UserRateLimitSelectorInput {
  AND: [UserRateLimitSelectorInput]
  OR: [UserRateLimitSelectorInput]
}

input UserRateLimitSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum UserRateLimitOrderByInput {
  foobar
}

type UserTagRel {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  tagId: String
  tag: Tag
  userId: String
  user: User
  subforumShowUnreadInSidebar: Boolean
  subforumEmailNotifications: Boolean
  subforumHideIntroPost: Boolean
}

input DeleteUserTagRelInput {
  selector: UserTagRelSelectorUniqueInput!
}

input SingleUserTagRelInput {
  selector: UserTagRelSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiUserTagRelInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: UserTagRelSelectorInput
  orderBy: UserTagRelOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserTagRelOutput {
  result: UserTagRel
}

type MultiUserTagRelOutput {
  results: [UserTagRel]
  totalCount: Int
}

type UserTagRelOutput {
  data: UserTagRel
}

input CreateUserTagRelInput {
  data: CreateUserTagRelDataInput!
}

input CreateUserTagRelDataInput {
  legacyData: JSON
  tagId: String!
  userId: String!
  subforumShowUnreadInSidebar: Boolean
  subforumEmailNotifications: Boolean
  subforumHideIntroPost: Boolean
}

input UpdateUserTagRelInput {
  selector: UserTagRelSelectorUniqueInput!
  data: UpdateUserTagRelDataInput!
}

input UpsertUserTagRelInput {
  selector: UserTagRelSelectorUniqueInput!
  data: UpdateUserTagRelDataInput!
}

input UpdateUserTagRelDataInput {
  legacyData: JSON
  subforumShowUnreadInSidebar: Boolean
  subforumEmailNotifications: Boolean
  subforumHideIntroPost: Boolean
}

input UserTagRelSelectorInput {
  AND: [UserTagRelSelectorInput]
  OR: [UserTagRelSelectorInput]
}

input UserTagRelSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum UserTagRelOrderByInput {
  foobar
}

type User {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  moderationGuidelines(version: String): Revision
  moderationGuidelines_latest: String
  howOthersCanHelpMe(version: String): Revision
  howOthersCanHelpMe_latest: String
  howICanHelpOthers(version: String): Revision
  howICanHelpOthers_latest: String
  slug: String
  oldSlugs: [String]
  biography(version: String): Revision
  biography_latest: String
  username: String
  emails: [JSON]
  isAdmin: Boolean
  services: JSON
  hasAuth0Id: Boolean
  displayName: String
  previousDisplayName: String
  email: String
  noindex: Boolean
  groups: [String]
  pageUrl: String
  pagePath: String
  editUrl: String
  lwWikiImport: Boolean
  theme: JSON
  lastUsedTimezone: String
  whenConfirmationEmailSent: Date
  legacy: Boolean
  commentSorting: String
  sortDraftsBy: String
  reactPaletteStyle: String
  noKibitz: Boolean
  showHideKarmaOption: Boolean
  showPostAuthorCard: Boolean
  hideIntercom: Boolean
  markDownPostEditor: Boolean
  hideElicitPredictions: Boolean
  hideAFNonMemberInitialWarning: Boolean
  noSingleLineComments: Boolean
  noCollapseCommentsPosts: Boolean
  noCollapseCommentsFrontpage: Boolean
  hideCommunitySection: Boolean
  expandedFrontpageSections: JSON
  showCommunityInRecentDiscussion: Boolean
  hidePostsRecommendations: Boolean
  petrovOptOut: Boolean
  optedOutOfSurveys: Boolean
  postGlossariesPinned: Boolean
  generateJargonForDrafts: Boolean
  generateJargonForPublishedPosts: Boolean
  acceptedTos: Boolean
  hideNavigationSidebar: Boolean
  currentFrontpageFilter: String
  frontpageSelectedTab: String
  frontpageFilterSettings: JSON
  hideFrontpageFilterSettingsDesktop: Boolean
  allPostsTimeframe: String
  allPostsFilter: String
  allPostsSorting: String
  allPostsShowLowKarma: Boolean
  allPostsIncludeEvents: Boolean
  allPostsHideCommunity: Boolean
  allPostsOpenSettings: Boolean
  draftsListSorting: String
  draftsListShowArchived: Boolean
  draftsListShowShared: Boolean
  lastNotificationsCheck: Date
  karma: Float
  goodHeartTokens: Float
  moderationStyle: String
  moderatorAssistance: Boolean
  collapseModerationGuidelines: Boolean
  bannedUserIds: [String]
  bannedPersonalUserIds: [String]
  bookmarkedPostsMetadata: [JSON]
  bookmarkedPosts: [Post!]!
  hiddenPostsMetadata: [JSON]
  hiddenPosts: [Post!]!
  legacyId: String
  deleted: Boolean
  permanentDeletionRequestedAt: Date
  voteBanned: Boolean
  nullifyVotes: Boolean
  deleteContent: Boolean
  banned: Date
  IPs: [String!]
  auto_subscribe_to_my_posts: Boolean
  auto_subscribe_to_my_comments: Boolean
  autoSubscribeAsOrganizer: Boolean
  notificationCommentsOnSubscribedPost: JSON
  notificationShortformContent: JSON
  notificationRepliesToMyComments: JSON
  notificationRepliesToSubscribedComments: JSON
  notificationSubscribedUserPost: JSON
  notificationSubscribedUserComment: JSON
  notificationPostsInGroups: JSON
  notificationSubscribedTagPost: JSON
  notificationSubscribedSequencePost: JSON
  notificationPrivateMessage: JSON
  notificationSharedWithMe: JSON
  notificationAlignmentSubmissionApproved: JSON
  notificationEventInRadius: JSON
  notificationKarmaPowersGained: JSON
  notificationRSVPs: JSON
  notificationGroupAdministration: JSON
  notificationCommentsOnDraft: JSON
  notificationPostsNominatedReview: JSON
  notificationSubforumUnread: JSON
  notificationNewMention: JSON
  notificationDialogueMessages: JSON
  notificationPublishedDialogueMessages: JSON
  notificationAddedAsCoauthor: JSON
  notificationDebateCommentsOnSubscribedPost: JSON
  notificationDebateReplies: JSON
  notificationDialogueMatch: JSON
  notificationNewDialogueChecks: JSON
  notificationYourTurnMatchForm: JSON
  hideDialogueFacilitation: Boolean
  revealChecksToAdmins: Boolean
  optedInToDialogueFacilitation: Boolean
  showDialoguesList: Boolean
  showMyDialogues: Boolean
  showMatches: Boolean
  showRecommendedPartners: Boolean
  hideActiveDialogueUsers: Boolean
  karmaChangeNotifierSettings: JSON
  karmaChangeLastOpened: Date
  karmaChangeBatchStart: Date
  emailSubscribedToCurated: Boolean
  subscribedToDigest: Boolean
  unsubscribeFromAll: Boolean
  hideSubscribePoke: Boolean
  hideMeetupsPoke: Boolean
  hideHomeRHS: Boolean
  frontpagePostCount: Float
  sequenceCount: Float
  sequenceDraftCount: Float
  mongoLocation: JSON
  googleLocation: JSON
  location: String
  mapLocation: JSON
  mapLocationLatLng: LatLng
  mapLocationSet: Boolean
  mapMarkerText: String
  htmlMapMarkerText: String
  nearbyEventsNotifications: Boolean
  nearbyEventsNotificationsLocation: JSON
  nearbyEventsNotificationsMongoLocation: JSON
  nearbyEventsNotificationsRadius: Float
  nearbyPeopleNotificationThreshold: Float
  hideFrontpageMap: Boolean
  hideTaggingProgressBar: Boolean
  hideFrontpageBookAd: Boolean
  hideFrontpageBook2019Ad: Boolean
  hideFrontpageBook2020Ad: Boolean
  sunshineNotes: String
  sunshineFlagged: Boolean
  needsReview: Boolean
  sunshineSnoozed: Boolean
  snoozedUntilContentCount: Float
  reviewedByUserId: String
  reviewedByUser: User
  isReviewed: Boolean
  reviewedAt: Date
  spamRiskScore: Float!
  afKarma: Float
  voteCount: Float
  smallUpvoteCount: Float
  smallDownvoteCount: Float
  bigUpvoteCount: Float
  bigDownvoteCount: Float
  voteReceivedCount: Float
  smallUpvoteReceivedCount: Float
  smallDownvoteReceivedCount: Float
  bigUpvoteReceivedCount: Float
  bigDownvoteReceivedCount: Float
  usersContactedBeforeReview: [String]
  fullName: String
  shortformFeedId: String
  shortformFeed: Post
  viewUnreviewedComments: Boolean
  partiallyReadSequences: [JSON]
  beta: Boolean
  reviewVotesQuadratic: Boolean
  reviewVotesQuadratic2019: Boolean
  reviewVoteCount: Int!
  reviewVotesQuadratic2020: Boolean
  petrovPressedButtonDate: Date
  petrovLaunchCodeDate: Date
  defaultToCKEditor: Boolean
  signUpReCaptchaRating: Float
  noExpandUnreadCommentsReview: Boolean
  postCount: Float
  maxPostCount: Float
  posts(limit: Int = 5): [Post]
  commentCount: Float
  maxCommentCount: Float
  tagRevisionCount: Float
  abTestKey: String
  abTestOverrides: JSON
  reenableDraftJs: Boolean
  walledGardenInvite: Boolean
  hideWalledGardenUI: Boolean
  walledGardenPortalOnboarded: Boolean
  taggingDashboardCollapsed: Boolean
  usernameUnset: Boolean
  paymentEmail: String
  paymentInfo: String
  profileUpdatedAt: Date
  profileImageId: String
  jobTitle: String
  organization: String
  careerStage: [String]
  website: String
  bio: String
  htmlBio: String!
  fmCrosspostUserId: String
  linkedinProfileURL: String
  facebookProfileURL: String
  blueskyProfileURL: String
  twitterProfileURL: String
  twitterProfileURLAdmin: String
  githubProfileURL: String
  profileTagIds: [String]
  profileTags: [Tag!]!
  organizerOfGroupIds: [String]
  organizerOfGroups: [Localgroup!]!
  programParticipation: [String]
  postingDisabled: Boolean
  allCommentingDisabled: Boolean
  commentingOnOtherUsersDisabled: Boolean
  conversationsDisabled: Boolean
  associatedClientId: ClientId
  associatedClientIds: [ClientId!]
  altAccountsDetected: Boolean
  acknowledgedNewUserGuidelines: Boolean
  moderatorActions: [ModeratorAction]
  subforumPreferredLayout: String
  hideJobAdUntil: Date
  criticismTipsDismissed: Boolean
  hideFromPeopleDirectory: Boolean
  allowDatadogSessionReplay: Boolean
  afPostCount: Float
  afCommentCount: Float
  afSequenceCount: Float
  afSequenceDraftCount: Float
  reviewForAlignmentForumUserId: String
  afApplicationText: String
  afSubmittedApplication: Boolean
  rateLimitNextAbleToComment(postId: String): JSON
  rateLimitNextAbleToPost(eventForm: Boolean): JSON
  recentKarmaInfo: JSON
  hideSunshineSidebar: Boolean
  inactiveSurveyEmailSentAt: Date
  userSurveyEmailSentAt: Date
  karmaChanges(startDate: Date, endDate: Date): KarmaChanges
  recommendationSettings: JSON
}

input DeleteUserInput {
  selector: UserSelectorUniqueInput!
}

input SingleUserInput {
  selector: UserSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiUserInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: UserSelectorInput
  orderBy: UserOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserOutput {
  result: User
}

type MultiUserOutput {
  results: [User]
  totalCount: Int
}

type UserOutput {
  data: User
}

input CreateUserInput {
  data: CreateUserDataInput!
}

input CreateUserDataInput {
  legacyData: JSON
  moderationGuidelines: JSON
  howOthersCanHelpMe: JSON
  howICanHelpOthers: JSON
  biography: JSON
  username: String
  isAdmin: Boolean
  displayName: String
  previousDisplayName: String
  email: String
  groups: [String]
  theme: JSON
  lastUsedTimezone: String
  whenConfirmationEmailSent: Date
  legacy: Boolean
  commentSorting: String
  noKibitz: Boolean
  showHideKarmaOption: Boolean
  showPostAuthorCard: Boolean
  hideIntercom: Boolean
  noSingleLineComments: Boolean
  noCollapseCommentsPosts: Boolean
  noCollapseCommentsFrontpage: Boolean
  hideCommunitySection: Boolean
  expandedFrontpageSections: JSON
  showCommunityInRecentDiscussion: Boolean
  hidePostsRecommendations: Boolean
  petrovOptOut: Boolean
  optedOutOfSurveys: Boolean
  postGlossariesPinned: Boolean
  acceptedTos: Boolean
  hideNavigationSidebar: Boolean
  currentFrontpageFilter: String
  frontpageSelectedTab: String
  frontpageFilterSettings: JSON
  hideFrontpageFilterSettingsDesktop: Boolean
  allPostsTimeframe: String
  allPostsFilter: String
  allPostsSorting: String
  allPostsShowLowKarma: Boolean
  allPostsIncludeEvents: Boolean
  allPostsHideCommunity: Boolean
  allPostsOpenSettings: Boolean
  draftsListSorting: String
  draftsListShowArchived: Boolean
  draftsListShowShared: Boolean
  lastNotificationsCheck: Date
  moderationStyle: String
  moderatorAssistance: Boolean
  collapseModerationGuidelines: Boolean
  bannedUserIds: [String]
  bannedPersonalUserIds: [String]
  legacyId: String
  voteBanned: Boolean
  nullifyVotes: Boolean
  deleteContent: Boolean
  banned: Date
  auto_subscribe_to_my_posts: Boolean
  auto_subscribe_to_my_comments: Boolean
  autoSubscribeAsOrganizer: Boolean
  notificationCommentsOnSubscribedPost: JSON
  notificationShortformContent: JSON
  notificationRepliesToMyComments: JSON
  notificationRepliesToSubscribedComments: JSON
  notificationSubscribedUserPost: JSON
  notificationSubscribedUserComment: JSON
  notificationPostsInGroups: JSON
  notificationSubscribedTagPost: JSON
  notificationSubscribedSequencePost: JSON
  notificationPrivateMessage: JSON
  notificationSharedWithMe: JSON
  notificationAlignmentSubmissionApproved: JSON
  notificationEventInRadius: JSON
  notificationKarmaPowersGained: JSON
  notificationRSVPs: JSON
  notificationGroupAdministration: JSON
  notificationCommentsOnDraft: JSON
  notificationPostsNominatedReview: JSON
  notificationSubforumUnread: JSON
  notificationNewMention: JSON
  notificationDialogueMessages: JSON
  notificationPublishedDialogueMessages: JSON
  notificationAddedAsCoauthor: JSON
  notificationDebateCommentsOnSubscribedPost: JSON
  notificationDebateReplies: JSON
  notificationDialogueMatch: JSON
  notificationNewDialogueChecks: JSON
  notificationYourTurnMatchForm: JSON
  hideDialogueFacilitation: Boolean
  revealChecksToAdmins: Boolean
  optedInToDialogueFacilitation: Boolean
  showDialoguesList: Boolean!
  showMyDialogues: Boolean!
  showMatches: Boolean!
  showRecommendedPartners: Boolean!
  hideActiveDialogueUsers: Boolean
  karmaChangeNotifierSettings: JSON
  karmaChangeLastOpened: Date
  karmaChangeBatchStart: Date
  emailSubscribedToCurated: Boolean
  subscribedToDigest: Boolean
  unsubscribeFromAll: Boolean
  hideSubscribePoke: Boolean
  hideMeetupsPoke: Boolean
  hideHomeRHS: Boolean
  googleLocation: JSON
  location: String
  mapLocation: JSON
  mapMarkerText: String
  nearbyEventsNotifications: Boolean
  nearbyEventsNotificationsLocation: JSON
  nearbyEventsNotificationsRadius: Float
  nearbyPeopleNotificationThreshold: Float
  hideFrontpageMap: Boolean
  hideTaggingProgressBar: Boolean
  hideFrontpageBookAd: Boolean
  hideFrontpageBook2019Ad: Boolean
  hideFrontpageBook2020Ad: Boolean
  reviewedByUserId: String
  shortformFeedId: String
  viewUnreviewedComments: Boolean
  noExpandUnreadCommentsReview: Boolean
  profileUpdatedAt: Date!
  jobTitle: String
  organization: String
  careerStage: [String]
  website: String
  fmCrosspostUserId: String
  linkedinProfileURL: String
  facebookProfileURL: String
  blueskyProfileURL: String
  twitterProfileURL: String
  twitterProfileURLAdmin: String
  githubProfileURL: String
  profileTagIds: [String]
  organizerOfGroupIds: [String]
  programParticipation: [String]
  postingDisabled: Boolean
  allCommentingDisabled: Boolean
  commentingOnOtherUsersDisabled: Boolean
  conversationsDisabled: Boolean
  acknowledgedNewUserGuidelines: Boolean
  subforumPreferredLayout: String
  hideJobAdUntil: Date
  criticismTipsDismissed: Boolean
  hideFromPeopleDirectory: Boolean
  allowDatadogSessionReplay: Boolean
  reviewForAlignmentForumUserId: String
  afSubmittedApplication: Boolean
  hideSunshineSidebar: Boolean
  inactiveSurveyEmailSentAt: Date
  userSurveyEmailSentAt: Date
}

input UpdateUserInput {
  selector: UserSelectorUniqueInput!
  data: UpdateUserDataInput!
}

input UpsertUserInput {
  selector: UserSelectorUniqueInput!
  data: UpdateUserDataInput!
}

input UpdateUserDataInput {
  legacyData: JSON
  moderationGuidelines: JSON
  howOthersCanHelpMe: JSON
  howICanHelpOthers: JSON
  slug: String
  biography: JSON
  username: String
  isAdmin: Boolean
  displayName: String
  previousDisplayName: String
  email: String
  noindex: Boolean
  groups: [String]
  theme: JSON
  lastUsedTimezone: String
  legacy: Boolean
  commentSorting: String
  sortDraftsBy: String
  reactPaletteStyle: String
  noKibitz: Boolean
  showHideKarmaOption: Boolean
  showPostAuthorCard: Boolean
  hideIntercom: Boolean
  markDownPostEditor: Boolean
  hideElicitPredictions: Boolean
  hideAFNonMemberInitialWarning: Boolean
  noSingleLineComments: Boolean
  noCollapseCommentsPosts: Boolean
  noCollapseCommentsFrontpage: Boolean
  hideCommunitySection: Boolean
  expandedFrontpageSections: JSON
  showCommunityInRecentDiscussion: Boolean
  hidePostsRecommendations: Boolean
  petrovOptOut: Boolean
  optedOutOfSurveys: Boolean
  postGlossariesPinned: Boolean
  generateJargonForDrafts: Boolean
  generateJargonForPublishedPosts: Boolean
  acceptedTos: Boolean
  hideNavigationSidebar: Boolean
  currentFrontpageFilter: String
  frontpageSelectedTab: String
  frontpageFilterSettings: JSON
  hideFrontpageFilterSettingsDesktop: Boolean
  allPostsTimeframe: String
  allPostsFilter: String
  allPostsSorting: String
  allPostsShowLowKarma: Boolean
  allPostsIncludeEvents: Boolean
  allPostsHideCommunity: Boolean
  allPostsOpenSettings: Boolean
  draftsListSorting: String
  draftsListShowArchived: Boolean
  draftsListShowShared: Boolean
  lastNotificationsCheck: Date
  moderationStyle: String
  moderatorAssistance: Boolean
  collapseModerationGuidelines: Boolean
  bannedUserIds: [String]
  bannedPersonalUserIds: [String]
  bookmarkedPostsMetadata: [JSON]
  hiddenPostsMetadata: [JSON]
  legacyId: String
  deleted: Boolean
  permanentDeletionRequestedAt: Date
  voteBanned: Boolean
  nullifyVotes: Boolean
  deleteContent: Boolean
  banned: Date
  auto_subscribe_to_my_posts: Boolean
  auto_subscribe_to_my_comments: Boolean
  autoSubscribeAsOrganizer: Boolean
  notificationCommentsOnSubscribedPost: JSON
  notificationShortformContent: JSON
  notificationRepliesToMyComments: JSON
  notificationRepliesToSubscribedComments: JSON
  notificationSubscribedUserPost: JSON
  notificationSubscribedUserComment: JSON
  notificationPostsInGroups: JSON
  notificationSubscribedTagPost: JSON
  notificationSubscribedSequencePost: JSON
  notificationPrivateMessage: JSON
  notificationSharedWithMe: JSON
  notificationAlignmentSubmissionApproved: JSON
  notificationEventInRadius: JSON
  notificationKarmaPowersGained: JSON
  notificationRSVPs: JSON
  notificationGroupAdministration: JSON
  notificationCommentsOnDraft: JSON
  notificationPostsNominatedReview: JSON
  notificationSubforumUnread: JSON
  notificationNewMention: JSON
  notificationDialogueMessages: JSON
  notificationPublishedDialogueMessages: JSON
  notificationAddedAsCoauthor: JSON
  notificationDebateCommentsOnSubscribedPost: JSON
  notificationDebateReplies: JSON
  notificationDialogueMatch: JSON
  notificationNewDialogueChecks: JSON
  notificationYourTurnMatchForm: JSON
  hideDialogueFacilitation: Boolean
  revealChecksToAdmins: Boolean
  optedInToDialogueFacilitation: Boolean
  showDialoguesList: Boolean
  showMyDialogues: Boolean
  showMatches: Boolean
  showRecommendedPartners: Boolean
  hideActiveDialogueUsers: Boolean
  karmaChangeNotifierSettings: JSON
  karmaChangeLastOpened: Date
  karmaChangeBatchStart: Date
  emailSubscribedToCurated: Boolean
  subscribedToDigest: Boolean
  unsubscribeFromAll: Boolean
  hideSubscribePoke: Boolean
  hideMeetupsPoke: Boolean
  hideHomeRHS: Boolean
  googleLocation: JSON
  location: String
  mapLocation: JSON
  mapMarkerText: String
  nearbyEventsNotifications: Boolean
  nearbyEventsNotificationsLocation: JSON
  nearbyEventsNotificationsRadius: Float
  nearbyPeopleNotificationThreshold: Float
  hideFrontpageMap: Boolean
  hideTaggingProgressBar: Boolean
  hideFrontpageBook2019Ad: Boolean
  hideFrontpageBook2020Ad: Boolean
  sunshineNotes: String
  sunshineFlagged: Boolean
  needsReview: Boolean
  sunshineSnoozed: Boolean
  snoozedUntilContentCount: Float
  reviewedByUserId: String
  reviewedAt: Date
  fullName: String
  shortformFeedId: String
  viewUnreviewedComments: Boolean
  partiallyReadSequences: [JSON]
  beta: Boolean
  reviewVotesQuadratic: Boolean
  reviewVotesQuadratic2019: Boolean
  reviewVotesQuadratic2020: Boolean
  petrovPressedButtonDate: Date
  petrovLaunchCodeDate: Date
  defaultToCKEditor: Boolean
  signUpReCaptchaRating: Float
  noExpandUnreadCommentsReview: Boolean
  abTestKey: String
  abTestOverrides: JSON
  walledGardenInvite: Boolean
  walledGardenPortalOnboarded: Boolean
  taggingDashboardCollapsed: Boolean
  usernameUnset: Boolean
  paymentEmail: String
  paymentInfo: String
  profileUpdatedAt: Date
  profileImageId: String
  jobTitle: String
  organization: String
  careerStage: [String]
  website: String
  fmCrosspostUserId: String
  linkedinProfileURL: String
  facebookProfileURL: String
  blueskyProfileURL: String
  twitterProfileURL: String
  twitterProfileURLAdmin: String
  githubProfileURL: String
  profileTagIds: [String]
  organizerOfGroupIds: [String]
  programParticipation: [String]
  postingDisabled: Boolean
  allCommentingDisabled: Boolean
  commentingOnOtherUsersDisabled: Boolean
  conversationsDisabled: Boolean
  acknowledgedNewUserGuidelines: Boolean
  subforumPreferredLayout: String
  hideJobAdUntil: Date
  criticismTipsDismissed: Boolean
  hideFromPeopleDirectory: Boolean
  allowDatadogSessionReplay: Boolean
  reviewForAlignmentForumUserId: String
  afApplicationText: String
  afSubmittedApplication: Boolean
  hideSunshineSidebar: Boolean
  inactiveSurveyEmailSentAt: Date
  userSurveyEmailSentAt: Date
  recommendationSettings: JSON
}

input UserSelectorInput {
  AND: [UserSelectorInput]
  OR: [UserSelectorInput]
}

input UserSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum UserOrderByInput {
  foobar
}

type Vote {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  documentId: String
  collectionName: String
  userId: String
  authorIds: [String]
  authorId: String
  voteType: String
  extendedVoteType: JSON
  power: Float
  afPower: Float
  cancelled: Boolean
  isUnvote: Boolean
  votedAt: Date
  tagRel: TagRel
  comment: Comment
  post: Post
  documentIsAf: Boolean
  silenceNotification: Boolean
}

input DeleteVoteInput {
  selector: VoteSelectorUniqueInput!
}

input SingleVoteInput {
  selector: VoteSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiVoteInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: VoteSelectorInput
  orderBy: VoteOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleVoteOutput {
  result: Vote
}

type MultiVoteOutput {
  results: [Vote]
  totalCount: Int
}

type VoteOutput {
  data: Vote
}

input CreateVoteInput {
  data: CreateVoteDataInput!
}

input CreateVoteDataInput {
  legacyData: JSON
}

input UpdateVoteInput {
  selector: VoteSelectorUniqueInput!
  data: UpdateVoteDataInput!
}

input UpsertVoteInput {
  selector: VoteSelectorUniqueInput!
  data: UpdateVoteDataInput!
}

input UpdateVoteDataInput {
  legacyData: JSON
}

input VoteSelectorInput {
  AND: [VoteSelectorInput]
  OR: [VoteSelectorInput]
}

input VoteSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum VoteOrderByInput {
  foobar
}

type Query {
  advisorRequest(input: SingleAdvisorRequestInput): SingleAdvisorRequestOutput
  advisorRequests(input: MultiAdvisorRequestInput): MultiAdvisorRequestOutput
  arbitalTagContentRel(input: SingleArbitalTagContentRelInput): SingleArbitalTagContentRelOutput
  arbitalTagContentRels(input: MultiArbitalTagContentRelInput): MultiArbitalTagContentRelOutput
  ban(input: SingleBanInput): SingleBanOutput
  bans(input: MultiBanInput): MultiBanOutput
  book(input: SingleBookInput): SingleBookOutput
  books(input: MultiBookInput): MultiBookOutput
  chapter(input: SingleChapterInput): SingleChapterOutput
  chapters(input: MultiChapterInput): MultiChapterOutput
  ckEditorUserSession(input: SingleCkEditorUserSessionInput): SingleCkEditorUserSessionOutput
  ckEditorUserSessions(input: MultiCkEditorUserSessionInput): MultiCkEditorUserSessionOutput
  clientId(input: SingleClientIdInput): SingleClientIdOutput
  clientIds(input: MultiClientIdInput): MultiClientIdOutput
  collection(input: SingleCollectionInput): SingleCollectionOutput
  collections(input: MultiCollectionInput): MultiCollectionOutput
  commentModeratorAction(input: SingleCommentModeratorActionInput): SingleCommentModeratorActionOutput
  commentModeratorActions(input: MultiCommentModeratorActionInput): MultiCommentModeratorActionOutput
  comment(input: SingleCommentInput): SingleCommentOutput
  comments(input: MultiCommentInput): MultiCommentOutput
  conversation(input: SingleConversationInput): SingleConversationOutput
  conversations(input: MultiConversationInput): MultiConversationOutput
  curationNotice(input: SingleCurationNoticeInput): SingleCurationNoticeOutput
  curationNotices(input: MultiCurationNoticeInput): MultiCurationNoticeOutput
  dialogueCheck(input: SingleDialogueCheckInput): SingleDialogueCheckOutput
  dialogueChecks(input: MultiDialogueCheckInput): MultiDialogueCheckOutput
  dialogueMatchPreference(input: SingleDialogueMatchPreferenceInput): SingleDialogueMatchPreferenceOutput
  dialogueMatchPreferences(input: MultiDialogueMatchPreferenceInput): MultiDialogueMatchPreferenceOutput
  digestPost(input: SingleDigestPostInput): SingleDigestPostOutput
  digestPosts(input: MultiDigestPostInput): MultiDigestPostOutput
  digest(input: SingleDigestInput): SingleDigestOutput
  digests(input: MultiDigestInput): MultiDigestOutput
  electionCandidate(input: SingleElectionCandidateInput): SingleElectionCandidateOutput
  electionCandidates(input: MultiElectionCandidateInput): MultiElectionCandidateOutput
  electionVote(input: SingleElectionVoteInput): SingleElectionVoteOutput
  electionVotes(input: MultiElectionVoteInput): MultiElectionVoteOutput
  elicitQuestionPrediction(input: SingleElicitQuestionPredictionInput): SingleElicitQuestionPredictionOutput
  elicitQuestionPredictions(input: MultiElicitQuestionPredictionInput): MultiElicitQuestionPredictionOutput
  elicitQuestion(input: SingleElicitQuestionInput): SingleElicitQuestionOutput
  elicitQuestions(input: MultiElicitQuestionInput): MultiElicitQuestionOutput
  featuredResource(input: SingleFeaturedResourceInput): SingleFeaturedResourceOutput
  featuredResources(input: MultiFeaturedResourceInput): MultiFeaturedResourceOutput
  forumEvent(input: SingleForumEventInput): SingleForumEventOutput
  forumEvents(input: MultiForumEventInput): MultiForumEventOutput
  gardenCode(input: SingleGardenCodeInput): SingleGardenCodeOutput
  gardenCodes(input: MultiGardenCodeInput): MultiGardenCodeOutput
  googleServiceAccountSession(input: SingleGoogleServiceAccountSessionInput): SingleGoogleServiceAccountSessionOutput
  googleServiceAccountSessions(input: MultiGoogleServiceAccountSessionInput): MultiGoogleServiceAccountSessionOutput
  jargonTerm(input: SingleJargonTermInput): SingleJargonTermOutput
  jargonTerms(input: MultiJargonTermInput): MultiJargonTermOutput
  lWEvent(input: SingleLWEventInput): SingleLWEventOutput
  lWEvents(input: MultiLWEventInput): MultiLWEventOutput
  llmConversation(input: SingleLlmConversationInput): SingleLlmConversationOutput
  llmConversations(input: MultiLlmConversationInput): MultiLlmConversationOutput
  localgroup(input: SingleLocalgroupInput): SingleLocalgroupOutput
  localgroups(input: MultiLocalgroupInput): MultiLocalgroupOutput
  message(input: SingleMessageInput): SingleMessageOutput
  messages(input: MultiMessageInput): MultiMessageOutput
  moderationTemplate(input: SingleModerationTemplateInput): SingleModerationTemplateOutput
  moderationTemplates(input: MultiModerationTemplateInput): MultiModerationTemplateOutput
  moderatorAction(input: SingleModeratorActionInput): SingleModeratorActionOutput
  moderatorActions(input: MultiModeratorActionInput): MultiModeratorActionOutput
  multiDocument(input: SingleMultiDocumentInput): SingleMultiDocumentOutput
  multiDocuments(input: MultiMultiDocumentInput): MultiMultiDocumentOutput
  notification(input: SingleNotificationInput): SingleNotificationOutput
  notifications(input: MultiNotificationInput): MultiNotificationOutput
  petrovDayAction(input: SinglePetrovDayActionInput): SinglePetrovDayActionOutput
  petrovDayActions(input: MultiPetrovDayActionInput): MultiPetrovDayActionOutput
  podcastEpisode(input: SinglePodcastEpisodeInput): SinglePodcastEpisodeOutput
  podcastEpisodes(input: MultiPodcastEpisodeInput): MultiPodcastEpisodeOutput
  podcast(input: SinglePodcastInput): SinglePodcastOutput
  podcasts(input: MultiPodcastInput): MultiPodcastOutput
  postEmbedding(input: SinglePostEmbeddingInput): SinglePostEmbeddingOutput
  postEmbeddings(input: MultiPostEmbeddingInput): MultiPostEmbeddingOutput
  postRelation(input: SinglePostRelationInput): SinglePostRelationOutput
  postRelations(input: MultiPostRelationInput): MultiPostRelationOutput
  postViewTime(input: SinglePostViewTimeInput): SinglePostViewTimeOutput
  postViewTimes(input: MultiPostViewTimeInput): MultiPostViewTimeOutput
  postViews(input: SinglePostViewsInput): SinglePostViewsOutput
  postViewses(input: MultiPostViewsInput): MultiPostViewsOutput
  post(input: SinglePostInput): SinglePostOutput
  posts(input: MultiPostInput): MultiPostOutput
  rSSFeed(input: SingleRSSFeedInput): SingleRSSFeedOutput
  rSSFeeds(input: MultiRSSFeedInput): MultiRSSFeedOutput
  report(input: SingleReportInput): SingleReportOutput
  reports(input: MultiReportInput): MultiReportOutput
  reviewVote(input: SingleReviewVoteInput): SingleReviewVoteOutput
  reviewVotes(input: MultiReviewVoteInput): MultiReviewVoteOutput
  reviewWinnerArt(input: SingleReviewWinnerArtInput): SingleReviewWinnerArtOutput
  reviewWinnerArts(input: MultiReviewWinnerArtInput): MultiReviewWinnerArtOutput
  reviewWinner(input: SingleReviewWinnerInput): SingleReviewWinnerOutput
  reviewWinners(input: MultiReviewWinnerInput): MultiReviewWinnerOutput
  revision(input: SingleRevisionInput): SingleRevisionOutput
  revisions(input: MultiRevisionInput): MultiRevisionOutput
  sequence(input: SingleSequenceInput): SingleSequenceOutput
  sequences(input: MultiSequenceInput): MultiSequenceOutput
  splashArtCoordinate(input: SingleSplashArtCoordinateInput): SingleSplashArtCoordinateOutput
  splashArtCoordinates(input: MultiSplashArtCoordinateInput): MultiSplashArtCoordinateOutput
  spotlight(input: SingleSpotlightInput): SingleSpotlightOutput
  spotlights(input: MultiSpotlightInput): MultiSpotlightOutput
  subscription(input: SingleSubscriptionInput): SingleSubscriptionOutput
  subscriptions(input: MultiSubscriptionInput): MultiSubscriptionOutput
  surveyQuestion(input: SingleSurveyQuestionInput): SingleSurveyQuestionOutput
  surveyQuestions(input: MultiSurveyQuestionInput): MultiSurveyQuestionOutput
  surveyResponse(input: SingleSurveyResponseInput): SingleSurveyResponseOutput
  surveyResponses(input: MultiSurveyResponseInput): MultiSurveyResponseOutput
  surveySchedule(input: SingleSurveyScheduleInput): SingleSurveyScheduleOutput
  surveySchedules(input: MultiSurveyScheduleInput): MultiSurveyScheduleOutput
  survey(input: SingleSurveyInput): SingleSurveyOutput
  surveys(input: MultiSurveyInput): MultiSurveyOutput
  tagFlag(input: SingleTagFlagInput): SingleTagFlagOutput
  tagFlags(input: MultiTagFlagInput): MultiTagFlagOutput
  tagRel(input: SingleTagRelInput): SingleTagRelOutput
  tagRels(input: MultiTagRelInput): MultiTagRelOutput
  tag(input: SingleTagInput): SingleTagOutput
  tags(input: MultiTagInput): MultiTagOutput
  typingIndicator(input: SingleTypingIndicatorInput): SingleTypingIndicatorOutput
  typingIndicators(input: MultiTypingIndicatorInput): MultiTypingIndicatorOutput
  userEAGDetail(input: SingleUserEAGDetailInput): SingleUserEAGDetailOutput
  userEAGDetails(input: MultiUserEAGDetailInput): MultiUserEAGDetailOutput
  userJobAd(input: SingleUserJobAdInput): SingleUserJobAdOutput
  userJobAds(input: MultiUserJobAdInput): MultiUserJobAdOutput
  userMostValuablePost(input: SingleUserMostValuablePostInput): SingleUserMostValuablePostOutput
  userMostValuablePosts(input: MultiUserMostValuablePostInput): MultiUserMostValuablePostOutput
  userRateLimit(input: SingleUserRateLimitInput): SingleUserRateLimitOutput
  userRateLimits(input: MultiUserRateLimitInput): MultiUserRateLimitOutput
  userTagRel(input: SingleUserTagRelInput): SingleUserTagRelOutput
  userTagRels(input: MultiUserTagRelInput): MultiUserTagRelOutput
  user(input: SingleUserInput): SingleUserOutput
  users(input: MultiUserInput): MultiUserOutput
  vote(input: SingleVoteInput): SingleVoteOutput
  votes(input: MultiVoteInput): MultiVoteOutput
}

type Mutation {
  createAdvisorRequest(data: CreateAdvisorRequestDataInput!): AdvisorRequestOutput
  updateAdvisorRequest(selector: AdvisorRequestSelectorUniqueInput!, data: UpdateAdvisorRequestDataInput!): AdvisorRequestOutput
  createArbitalTagContentRel(data: CreateArbitalTagContentRelDataInput!): ArbitalTagContentRelOutput
  updateArbitalTagContentRel(selector: ArbitalTagContentRelSelectorUniqueInput!, data: UpdateArbitalTagContentRelDataInput!): ArbitalTagContentRelOutput
  createBan(data: CreateBanDataInput!): BanOutput
  updateBan(selector: BanSelectorUniqueInput!, data: UpdateBanDataInput!): BanOutput
  createBook(data: CreateBookDataInput!): BookOutput
  updateBook(selector: BookSelectorUniqueInput!, data: UpdateBookDataInput!): BookOutput
  createChapter(data: CreateChapterDataInput!): ChapterOutput
  updateChapter(selector: ChapterSelectorUniqueInput!, data: UpdateChapterDataInput!): ChapterOutput
  createCollection(data: CreateCollectionDataInput!): CollectionOutput
  updateCollection(selector: CollectionSelectorUniqueInput!, data: UpdateCollectionDataInput!): CollectionOutput
  createCommentModeratorAction(data: CreateCommentModeratorActionDataInput!): CommentModeratorActionOutput
  updateCommentModeratorAction(selector: CommentModeratorActionSelectorUniqueInput!, data: UpdateCommentModeratorActionDataInput!): CommentModeratorActionOutput
  createComment(data: CreateCommentDataInput!): CommentOutput
  updateComment(selector: CommentSelectorUniqueInput!, data: UpdateCommentDataInput!): CommentOutput
  createConversation(data: CreateConversationDataInput!): ConversationOutput
  updateConversation(selector: ConversationSelectorUniqueInput!, data: UpdateConversationDataInput!): ConversationOutput
  createCurationNotice(data: CreateCurationNoticeDataInput!): CurationNoticeOutput
  updateCurationNotice(selector: CurationNoticeSelectorUniqueInput!, data: UpdateCurationNoticeDataInput!): CurationNoticeOutput
  createDialogueMatchPreference(data: CreateDialogueMatchPreferenceDataInput!): DialogueMatchPreferenceOutput
  updateDialogueMatchPreference(selector: DialogueMatchPreferenceSelectorUniqueInput!, data: UpdateDialogueMatchPreferenceDataInput!): DialogueMatchPreferenceOutput
  createDigestPost(data: CreateDigestPostDataInput!): DigestPostOutput
  updateDigestPost(selector: DigestPostSelectorUniqueInput!, data: UpdateDigestPostDataInput!): DigestPostOutput
  createDigest(data: CreateDigestDataInput!): DigestOutput
  updateDigest(selector: DigestSelectorUniqueInput!, data: UpdateDigestDataInput!): DigestOutput
  createElectionCandidate(data: CreateElectionCandidateDataInput!): ElectionCandidateOutput
  updateElectionCandidate(selector: ElectionCandidateSelectorUniqueInput!, data: UpdateElectionCandidateDataInput!): ElectionCandidateOutput
  createElectionVote(data: CreateElectionVoteDataInput!): ElectionVoteOutput
  updateElectionVote(selector: ElectionVoteSelectorUniqueInput!, data: UpdateElectionVoteDataInput!): ElectionVoteOutput
  createElicitQuestion(data: CreateElicitQuestionDataInput!): ElicitQuestionOutput
  updateElicitQuestion(selector: ElicitQuestionSelectorUniqueInput!, data: UpdateElicitQuestionDataInput!): ElicitQuestionOutput
  createForumEvent(data: CreateForumEventDataInput!): ForumEventOutput
  updateForumEvent(selector: ForumEventSelectorUniqueInput!, data: UpdateForumEventDataInput!): ForumEventOutput
  createGardenCode(data: CreateGardenCodeDataInput!): GardenCodeOutput
  updateGardenCode(selector: GardenCodeSelectorUniqueInput!, data: UpdateGardenCodeDataInput!): GardenCodeOutput
  createGoogleServiceAccountSession(data: CreateGoogleServiceAccountSessionDataInput!): GoogleServiceAccountSessionOutput
  updateGoogleServiceAccountSession(selector: GoogleServiceAccountSessionSelectorUniqueInput!, data: UpdateGoogleServiceAccountSessionDataInput!): GoogleServiceAccountSessionOutput
  createJargonTerm(data: CreateJargonTermDataInput!): JargonTermOutput
  updateJargonTerm(selector: JargonTermSelectorUniqueInput!, data: UpdateJargonTermDataInput!): JargonTermOutput
  createLWEvent(data: CreateLWEventDataInput!): LWEventOutput
  updateLWEvent(selector: LWEventSelectorUniqueInput!, data: UpdateLWEventDataInput!): LWEventOutput
  createLlmConversation(data: CreateLlmConversationDataInput!): LlmConversationOutput
  updateLlmConversation(selector: LlmConversationSelectorUniqueInput!, data: UpdateLlmConversationDataInput!): LlmConversationOutput
  createLocalgroup(data: CreateLocalgroupDataInput!): LocalgroupOutput
  updateLocalgroup(selector: LocalgroupSelectorUniqueInput!, data: UpdateLocalgroupDataInput!): LocalgroupOutput
  createMessage(data: CreateMessageDataInput!): MessageOutput
  updateMessage(selector: MessageSelectorUniqueInput!, data: UpdateMessageDataInput!): MessageOutput
  createModerationTemplate(data: CreateModerationTemplateDataInput!): ModerationTemplateOutput
  updateModerationTemplate(selector: ModerationTemplateSelectorUniqueInput!, data: UpdateModerationTemplateDataInput!): ModerationTemplateOutput
  createModeratorAction(data: CreateModeratorActionDataInput!): ModeratorActionOutput
  updateModeratorAction(selector: ModeratorActionSelectorUniqueInput!, data: UpdateModeratorActionDataInput!): ModeratorActionOutput
  createMultiDocument(data: CreateMultiDocumentDataInput!): MultiDocumentOutput
  updateMultiDocument(selector: MultiDocumentSelectorUniqueInput!, data: UpdateMultiDocumentDataInput!): MultiDocumentOutput
  createNotification(data: CreateNotificationDataInput!): NotificationOutput
  updateNotification(selector: NotificationSelectorUniqueInput!, data: UpdateNotificationDataInput!): NotificationOutput
  createPetrovDayAction(data: CreatePetrovDayActionDataInput!): PetrovDayActionOutput
  updatePetrovDayAction(selector: PetrovDayActionSelectorUniqueInput!, data: UpdatePetrovDayActionDataInput!): PetrovDayActionOutput
  createPodcastEpisode(data: CreatePodcastEpisodeDataInput!): PodcastEpisodeOutput
  updatePodcastEpisode(selector: PodcastEpisodeSelectorUniqueInput!, data: UpdatePodcastEpisodeDataInput!): PodcastEpisodeOutput
  createPostEmbedding(data: CreatePostEmbeddingDataInput!): PostEmbeddingOutput
  updatePostEmbedding(selector: PostEmbeddingSelectorUniqueInput!, data: UpdatePostEmbeddingDataInput!): PostEmbeddingOutput
  createPostViewTime(data: CreatePostViewTimeDataInput!): PostViewTimeOutput
  updatePostViewTime(selector: PostViewTimeSelectorUniqueInput!, data: UpdatePostViewTimeDataInput!): PostViewTimeOutput
  createPostViews(data: CreatePostViewsDataInput!): PostViewsOutput
  updatePostViews(selector: PostViewsSelectorUniqueInput!, data: UpdatePostViewsDataInput!): PostViewsOutput
  createPost(data: CreatePostDataInput!): PostOutput
  updatePost(selector: PostSelectorUniqueInput!, data: UpdatePostDataInput!): PostOutput
  createRSSFeed(data: CreateRSSFeedDataInput!): RSSFeedOutput
  updateRSSFeed(selector: RSSFeedSelectorUniqueInput!, data: UpdateRSSFeedDataInput!): RSSFeedOutput
  createReport(data: CreateReportDataInput!): ReportOutput
  updateReport(selector: ReportSelectorUniqueInput!, data: UpdateReportDataInput!): ReportOutput
  createReviewWinnerArt(data: CreateReviewWinnerArtDataInput!): ReviewWinnerArtOutput
  updateReviewWinnerArt(selector: ReviewWinnerArtSelectorUniqueInput!, data: UpdateReviewWinnerArtDataInput!): ReviewWinnerArtOutput
  createReviewWinner(data: CreateReviewWinnerDataInput!): ReviewWinnerOutput
  updateReviewWinner(selector: ReviewWinnerSelectorUniqueInput!, data: UpdateReviewWinnerDataInput!): ReviewWinnerOutput
  updateRevision(selector: RevisionSelectorUniqueInput!, data: UpdateRevisionDataInput!): RevisionOutput
  createSequence(data: CreateSequenceDataInput!): SequenceOutput
  updateSequence(selector: SequenceSelectorUniqueInput!, data: UpdateSequenceDataInput!): SequenceOutput
  createSplashArtCoordinate(data: CreateSplashArtCoordinateDataInput!): SplashArtCoordinateOutput
  updateSplashArtCoordinate(selector: SplashArtCoordinateSelectorUniqueInput!, data: UpdateSplashArtCoordinateDataInput!): SplashArtCoordinateOutput
  createSpotlight(data: CreateSpotlightDataInput!): SpotlightOutput
  updateSpotlight(selector: SpotlightSelectorUniqueInput!, data: UpdateSpotlightDataInput!): SpotlightOutput
  createSubscription(data: CreateSubscriptionDataInput!): SubscriptionOutput
  createSurveyQuestion(data: CreateSurveyQuestionDataInput!): SurveyQuestionOutput
  updateSurveyQuestion(selector: SurveyQuestionSelectorUniqueInput!, data: UpdateSurveyQuestionDataInput!): SurveyQuestionOutput
  createSurveyResponse(data: CreateSurveyResponseDataInput!): SurveyResponseOutput
  updateSurveyResponse(selector: SurveyResponseSelectorUniqueInput!, data: UpdateSurveyResponseDataInput!): SurveyResponseOutput
  createSurveySchedule(data: CreateSurveyScheduleDataInput!): SurveyScheduleOutput
  updateSurveySchedule(selector: SurveyScheduleSelectorUniqueInput!, data: UpdateSurveyScheduleDataInput!): SurveyScheduleOutput
  createSurvey(data: CreateSurveyDataInput!): SurveyOutput
  updateSurvey(selector: SurveySelectorUniqueInput!, data: UpdateSurveyDataInput!): SurveyOutput
  createTagFlag(data: CreateTagFlagDataInput!): TagFlagOutput
  updateTagFlag(selector: TagFlagSelectorUniqueInput!, data: UpdateTagFlagDataInput!): TagFlagOutput
  createTagRel(data: CreateTagRelDataInput!): TagRelOutput
  updateTagRel(selector: TagRelSelectorUniqueInput!, data: UpdateTagRelDataInput!): TagRelOutput
  createTag(data: CreateTagDataInput!): TagOutput
  updateTag(selector: TagSelectorUniqueInput!, data: UpdateTagDataInput!): TagOutput
  createUserEAGDetail(data: CreateUserEAGDetailDataInput!): UserEAGDetailOutput
  updateUserEAGDetail(selector: UserEAGDetailSelectorUniqueInput!, data: UpdateUserEAGDetailDataInput!): UserEAGDetailOutput
  createUserJobAd(data: CreateUserJobAdDataInput!): UserJobAdOutput
  updateUserJobAd(selector: UserJobAdSelectorUniqueInput!, data: UpdateUserJobAdDataInput!): UserJobAdOutput
  createUserMostValuablePost(data: CreateUserMostValuablePostDataInput!): UserMostValuablePostOutput
  updateUserMostValuablePost(selector: UserMostValuablePostSelectorUniqueInput!, data: UpdateUserMostValuablePostDataInput!): UserMostValuablePostOutput
  createUserRateLimit(data: CreateUserRateLimitDataInput!): UserRateLimitOutput
  updateUserRateLimit(selector: UserRateLimitSelectorUniqueInput!, data: UpdateUserRateLimitDataInput!): UserRateLimitOutput
  createUserTagRel(data: CreateUserTagRelDataInput!): UserTagRelOutput
  updateUserTagRel(selector: UserTagRelSelectorUniqueInput!, data: UpdateUserTagRelDataInput!): UserTagRelOutput
  createUser(data: CreateUserDataInput!): UserOutput
  updateUser(selector: UserSelectorUniqueInput!, data: UpdateUserDataInput!): UserOutput
}

type EmailPreview {
  to: String
  subject: String
  html: String
  text: String
}

extend type Query {
  EmailPreview(notificationIds: [String], postId: String): [EmailPreview]
}

type ArbitalLinkedPage {
  _id: String!
  name: String!
  slug: String!
}

type ArbitalLinkedPages {
  faster: [ArbitalLinkedPage]
  slower: [ArbitalLinkedPage]
  moreTechnical: [ArbitalLinkedPage]
  lessTechnical: [ArbitalLinkedPage]
  requirements: [ArbitalLinkedPage]
  teaches: [ArbitalLinkedPage]
  parents: [ArbitalLinkedPage]
  children: [ArbitalLinkedPage]
}

type SocialPreviewType {
  _id: String
  imageId: String
  imageUrl: String
  text: String
}

scalar ContentTypeData

type ContentType {
  type: String
  data: ContentTypeData
}

type TagContributor {
  user: User
  contributionScore: Int!
  currentAttributionCharCount: Int
  numCommits: Int!
  voteCount: Int!
}

type TagContributorsList {
  contributors: [TagContributor!]
  totalCount: Int!
}

type UserLikingTag {
  _id: String!
  displayName: String!
}

type LatLng {
  lat: Float!
  lng: Float!
}

type RecommendResumeSequence {
  sequence: Sequence
  collection: Collection
  nextPost: Post!
  numRead: Int
  numTotal: Int
  lastReadTime: Date
}

extend type Query {
  ContinueReading: [RecommendResumeSequence!]
  Recommendations(count: Int, algorithm: JSON): [Post!]
}

extend type Mutation {
  dismissRecommendation(postId: String): Boolean
}

type CommentCountTag {
  name: String!
  comment_count: Int!
}

type TopCommentedTagUser {
  _id: ID!
  username: String!
  displayName: String!
  total_power: Float!
  tag_comment_counts: [CommentCountTag!]!
}

type UpvotedUser {
  _id: ID!
  username: String!
  displayName: String!
  total_power: Float!
  power_values: String!
  vote_counts: Int!
  total_agreement: Float!
  agreement_values: String!
  recently_active_matchmaking: Boolean!
}

type UserDialogueUsefulData {
  dialogueUsers: [User]
  topUsers: [UpvotedUser]
  activeDialogueMatchSeekers: [User]
}

type NewUserCompletedProfile {
  username: String
  slug: String
  displayName: String
  subscribedToDigest: Boolean
  usernameUnset: Boolean
}

type UserCoreTagReads {
  tagId: String
  userReadCount: Int
}

extend type Mutation {
  NewUserCompleteProfile(username: String!, subscribeToDigest: Boolean!, email: String, acceptedTos: Boolean): NewUserCompletedProfile
  UserExpandFrontpageSection(section: String!, expanded: Boolean!): Boolean
  UserUpdateSubforumMembership(tagId: String!, member: Boolean!): User
}

extend type Query {
  UserReadsPerCoreTag(userId: String!): [UserCoreTagReads]
  GetRandomUser(userIsAuthor: String!): User
  IsDisplayNameTaken(displayName: String!): Boolean!
}

type SuggestedFeedSubscriptionUsersResult {
  results: [User!]!
}

extend type Query {
  SuggestedFeedSubscriptionUsers(limit: Int): SuggestedFeedSubscriptionUsersResult
}

type VoteResultPost {
  document: Post!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVotePost(documentId: String, voteType: String, extendedVote: JSON): Post
  performVotePost(documentId: String, voteType: String, extendedVote: JSON): VoteResultPost
}

type VoteResultComment {
  document: Comment!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteComment(documentId: String, voteType: String, extendedVote: JSON): Comment
  performVoteComment(documentId: String, voteType: String, extendedVote: JSON): VoteResultComment
}

type VoteResultTagRel {
  document: TagRel!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteTagRel(documentId: String, voteType: String, extendedVote: JSON): TagRel
  performVoteTagRel(documentId: String, voteType: String, extendedVote: JSON): VoteResultTagRel
}

type VoteResultRevision {
  document: Revision!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteRevision(documentId: String, voteType: String, extendedVote: JSON): Revision
  performVoteRevision(documentId: String, voteType: String, extendedVote: JSON): VoteResultRevision
}

type VoteResultElectionCandidate {
  document: ElectionCandidate!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteElectionCandidate(documentId: String, voteType: String, extendedVote: JSON): ElectionCandidate
  performVoteElectionCandidate(documentId: String, voteType: String, extendedVote: JSON): VoteResultElectionCandidate
}

type VoteResultTag {
  document: Tag!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteTag(documentId: String, voteType: String, extendedVote: JSON): Tag
  performVoteTag(documentId: String, voteType: String, extendedVote: JSON): VoteResultTag
}

type VoteResultMultiDocument {
  document: MultiDocument!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteMultiDocument(documentId: String, voteType: String, extendedVote: JSON): MultiDocument
  performVoteMultiDocument(documentId: String, voteType: String, extendedVote: JSON): VoteResultMultiDocument
}

extend type Mutation {
  moderateComment(commentId: String, deleted: Boolean, deletedPublic: Boolean, deletedReason: String): Comment
}

type CommentsWithReactsResult {
  results: [Comment!]!
}

extend type Query {
  CommentsWithReacts(limit: Int): CommentsWithReactsResult
}

type PopularCommentsResult {
  results: [Comment!]!
}

extend type Query {
  PopularComments(limit: Int): PopularCommentsResult
}

type PostKarmaChange {
  _id: String
  scoreChange: Int
  postId: String
  title: String
  slug: String
  addedReacts: [ReactionChange!]
  eaAddedReacts: JSON
}

type CommentKarmaChange {
  _id: String
  scoreChange: Int
  commentId: String
  description: String
  postId: String
  postTitle: String
  postSlug: String
  tagSlug: String
  tagName: String
  tagCommentType: String
  addedReacts: [ReactionChange!]
  eaAddedReacts: JSON
}

type RevisionsKarmaChange {
  _id: String
  scoreChange: Int
  tagId: String
  tagSlug: String
  tagName: String
  addedReacts: [ReactionChange!]
  eaAddedReacts: JSON
}

type ReactionChange {
  reactionType: String!
  userId: String
}

type KarmaChangesSimple {
  posts: [PostKarmaChange]
  comments: [CommentKarmaChange]
  tagRevisions: [RevisionsKarmaChange]
}

type KarmaChanges {
  totalChange: Int
  startDate: Date
  endDate: Date
  nextBatchDate: Date
  updateFrequency: String
  posts: [PostKarmaChange]
  comments: [CommentKarmaChange]
  tagRevisions: [RevisionsKarmaChange]
  todaysKarmaChanges: KarmaChangesSimple
  thisWeeksKarmaChanges: KarmaChangesSimple
}

type UniqueClientViewsSeries {
  uniqueClientViews: Int
  date: Date
}

type PostAnalyticsResult {
  allViews: Int
  uniqueClientViews: Int
  uniqueClientViews10Sec: Int
  medianReadingTime: Int
  uniqueClientViews5Min: Int
  uniqueClientViewsSeries: [UniqueClientViewsSeries]
}

type PostAnalytics2Result {
  _id: String
  title: String
  slug: String
  postedAt: Date
  views: Int
  uniqueViews: Int
  reads: Int
  meanReadingTime: Float
  karma: Int
  comments: Int
}

type MultiPostAnalyticsResult {
  posts: [PostAnalytics2Result]
  totalCount: Int!
}

type AnalyticsSeriesValue {
  date: Date
  views: Int
  reads: Int
  karma: Int
  comments: Int
}

extend type Query {
  PostAnalytics(postId: String!): PostAnalyticsResult!
  MultiPostAnalytics(userId: String, postIds: [String], sortBy: String, desc: Boolean, limit: Int): MultiPostAnalyticsResult!
  AnalyticsSeries(userId: String, postIds: [String], startDate: Date, endDate: Date): [AnalyticsSeriesValue]
}

type ArbitalPageData {
  html: String
  title: String
}

extend type Query {
  ArbitalPageData(pageAlias: String): ArbitalPageData
}

type CoronaVirusDataRow {
  accepted: String
  imp: String
  link: String
  shortDescription: String
  url: String
  description: String
  domain: String
  type: String
  reviewerThoughts: String
  foundVia: String
  sourceLink: String
  sourceLinkDomain: String
  lastUpdated: String
  title: String
  dateAdded: String
  category: String
}

type CoronaVirusDataSchema {
  range: String
  majorDimension: String
  values: [CoronaVirusDataRow!]
}

extend type Query {
  CoronaVirusData: CoronaVirusDataSchema
}

type ElicitUser {
  isQuestionCreator: Boolean
  displayName: String
  _id: String
  sourceUserId: String
  lwUser: User
}

type ElicitPrediction {
  _id: String
  predictionId: String
  prediction: Float
  createdAt: Date
  notes: String
  creator: ElicitUser
  sourceUrl: String
  sourceId: String
  binaryQuestionId: String
}

type ElicitBlockData {
  _id: String
  title: String
  notes: String
  resolvesBy: Date
  resolution: Boolean
  predictions: [ElicitPrediction]
}

extend type Query {
  ElicitBlockData(questionId: String): ElicitBlockData
}

extend type Mutation {
  MakeElicitPrediction(questionId: String, prediction: Int): ElicitBlockData
}

type NotificationCounts {
  checkedAt: Date!
  unreadNotifications: Int!
  unreadPrivateMessages: Int!
  faviconBadgeNumber: Int!
}

extend type Query {
  unreadNotificationCounts: NotificationCounts!
}

extend type Mutation {
  MarkAllNotificationsAsRead: Boolean
  sendNewDialogueMessageNotification(postId: String!, dialogueHtml: String!): Boolean!
}

type NotificationDisplaysResult {
  results: [JSON!]!
}

extend type Query {
  NotificationDisplays(type: String, limit: Int): NotificationDisplaysResult
}

extend type Query {
  Lightcone2024FundraiserStripeAmounts: [Int!]
}

type PetrovDay2024CheckNumberOfIncomingData {
  count: Int
}

extend type Query {
  PetrovDay2024CheckNumberOfIncoming: PetrovDay2024CheckNumberOfIncomingData
  petrov2024checkIfNuked: Boolean
}

type PetrovDayCheckIfIncomingData {
  launched: Boolean
  createdAt: Date
}

type PetrovDayLaunchMissileData {
  launchCode: String
  createdAt: Date
}

extend type Query {
  PetrovDayCheckIfIncoming: PetrovDayCheckIfIncomingData
}

extend type Mutation {
  PetrovDayLaunchMissile(launchCode: String): PetrovDayLaunchMissileData
}

type GivingSeasonHeart {
  userId: String!
  displayName: String!
  x: Float!
  y: Float!
  theta: Float!
}

extend type Mutation {
  submitReviewVote(postId: String, qualitativeScore: Int, quadraticChange: Int, newQuadraticScore: Int, comment: String, year: String, dummy: Boolean, reactions: [String]): Post
  AddGivingSeasonHeart(electionName: String!, x: Float!, y: Float!, theta: Float!): [GivingSeasonHeart!]!
  RemoveGivingSeasonHeart(electionName: String!): [GivingSeasonHeart!]!
}

extend type Query {
  GivingSeasonHearts(electionName: String!): [GivingSeasonHeart!]!
}

extend type Query {
  UsersReadPostsOfTargetUser(userId: String!, targetUserId: String!, limit: Int): [Post!]
  UserReadHistory(limit: Int, filter: PostReviewFilter, sort: PostReviewSort): UserReadHistoryResult
  PostsUserCommentedOn(limit: Int, filter: PostReviewFilter, sort: PostReviewSort): UserReadHistoryResult
  PostIsCriticism(args: JSON): Boolean
  DigestPlannerData(digestId: String, startDate: Date, endDate: Date): [DigestPlannerPost]
  DigestPosts(num: Int): [Post]
  CanAccessGoogleDoc(fileUrl: String!): Boolean
}

extend type Mutation {
  ImportGoogleDoc(fileUrl: String!, postId: String): Post
}

type UserReadHistoryResult {
  posts: [Post!]
}

type PostsUserCommentedOnResult {
  posts: [Post!]
}

input PostReviewFilter {
  startDate: Date
  endDate: Date
  minKarma: Int
  showEvents: Boolean
}

input PostReviewSort {
  karma: Boolean
}

type DigestPlannerPost {
  post: Post
  digestPost: DigestPost
  rating: Int
}

type RecombeeRecommendedPost {
  post: Post!
  scenario: String
  recommId: String
  generatedAt: Date
  curated: Boolean
  stickied: Boolean
}

type VertexRecommendedPost {
  post: Post!
  attributionId: String
}

type PostWithApprovedJargon {
  post: Post!
  jargonTerms: [JargonTerm!]
}

type DigestHighlightsResult {
  results: [Post!]!
}

extend type Query {
  DigestHighlights(limit: Int): DigestHighlightsResult
}

type DigestPostsThisWeekResult {
  results: [Post!]!
}

extend type Query {
  DigestPostsThisWeek(limit: Int): DigestPostsThisWeekResult
}

type CuratedAndPopularThisWeekResult {
  results: [Post!]!
}

extend type Query {
  CuratedAndPopularThisWeek(limit: Int): CuratedAndPopularThisWeekResult
}

type RecentlyActiveDialoguesResult {
  results: [Post!]!
}

extend type Query {
  RecentlyActiveDialogues(limit: Int): RecentlyActiveDialoguesResult
}

type MyDialoguesResult {
  results: [Post!]!
}

extend type Query {
  MyDialogues(limit: Int): MyDialoguesResult
}

type GoogleVertexPostsResult {
  results: [VertexRecommendedPost!]!
}

extend type Query {
  GoogleVertexPosts(settings: JSON, limit: Int): GoogleVertexPostsResult
}

type CrossedKarmaThresholdResult {
  results: [Post!]!
}

extend type Query {
  CrossedKarmaThreshold(limit: Int): CrossedKarmaThresholdResult
}

type RecombeeLatestPostsResult {
  results: [RecombeeRecommendedPost!]!
}

extend type Query {
  RecombeeLatestPosts(settings: JSON, limit: Int): RecombeeLatestPostsResult
}

type RecombeeHybridPostsResult {
  results: [RecombeeRecommendedPost!]!
}

extend type Query {
  RecombeeHybridPosts(settings: JSON, limit: Int): RecombeeHybridPostsResult
}

type PostsWithActiveDiscussionResult {
  results: [Post!]!
}

extend type Query {
  PostsWithActiveDiscussion(limit: Int): PostsWithActiveDiscussionResult
}

type PostsBySubscribedAuthorsResult {
  results: [Post!]!
}

extend type Query {
  PostsBySubscribedAuthors(limit: Int): PostsBySubscribedAuthorsResult
}

type PostsWithApprovedJargonResult {
  results: [PostWithApprovedJargon!]!
}

extend type Query {
  PostsWithApprovedJargon(limit: Int): PostsWithApprovedJargonResult
}

extend type Mutation {
  revokeGoogleServiceAccountTokens: Boolean!
}

extend type Mutation {
  alignmentComment(commentId: String, af: Boolean): Comment
  alignmentPost(postId: String, af: Boolean): Post
}

type AllTagsActivityFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [AllTagsActivityFeedEntryType!]
}

type AllTagsActivityFeedEntryType {
  type: String!
  tagCreated: Tag
  tagRevision: Revision
  tagDiscussionComment: Comment
}

extend type Query {
  AllTagsActivityFeed(limit: Int, cutoff: Date, offset: Int): AllTagsActivityFeedQueryResults!
}

type RecentDiscussionFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [RecentDiscussionFeedEntryType!]
}

type RecentDiscussionFeedEntryType {
  type: String!
  postCommented: Post
  shortformCommented: Post
  tagDiscussed: Tag
  tagRevised: Revision
}

extend type Query {
  RecentDiscussionFeed(limit: Int, cutoff: Date, offset: Int, af: Boolean): RecentDiscussionFeedQueryResults!
}

type SubscribedPostAndComments {
  _id: String!
  post: Post!
  comments: [Comment!]
  expandCommentIds: [String!]
  postIsFromSubscribedUser: Boolean!
}

type SubscribedFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubscribedFeedEntryType!]
}

type SubscribedFeedEntryType {
  type: String!
  postCommented: SubscribedPostAndComments
}

extend type Query {
  SubscribedFeed(limit: Int, cutoff: Date, offset: Int, af: Boolean): SubscribedFeedQueryResults!
}

type TagHistoryFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [TagHistoryFeedEntryType!]
}

type TagHistoryFeedEntryType {
  type: String!
  tagCreated: Tag
  tagApplied: TagRel
  tagRevision: Revision
  tagDiscussionComment: Comment
  lensRevision: Revision
  summaryRevision: Revision
  wikiMetadataChanged: FieldChange
  lensOrSummaryMetadataChanged: FieldChange
}

extend type Query {
  TagHistoryFeed(limit: Int, cutoff: Date, offset: Int, tagId: String!, options: JSON): TagHistoryFeedQueryResults!
}

type SubforumMagicFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumMagicFeedEntryType!]
}

type SubforumMagicFeedEntryType {
  type: String!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumMagicFeed(limit: Int, cutoff: Float, offset: Int, tagId: String!, af: Boolean): SubforumMagicFeedQueryResults!
}

type SubforumTopFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumTopFeedEntryType!]
}

type SubforumTopFeedEntryType {
  type: String!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumTopFeed(limit: Int, cutoff: Int, offset: Int, tagId: String!, af: Boolean): SubforumTopFeedQueryResults!
}

type SubforumRecentCommentsFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumRecentCommentsFeedEntryType!]
}

type SubforumRecentCommentsFeedEntryType {
  type: String!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumRecentCommentsFeed(limit: Int, cutoff: Date, offset: Int, tagId: String!, af: Boolean): SubforumRecentCommentsFeedQueryResults!
}

type SubforumNewFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumNewFeedEntryType!]
}

type SubforumNewFeedEntryType {
  type: String!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumNewFeed(limit: Int, cutoff: Date, offset: Int, tagId: String!, af: Boolean): SubforumNewFeedQueryResults!
}

type SubforumOldFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumOldFeedEntryType!]
}

type SubforumOldFeedEntryType {
  type: String!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumOldFeed(limit: Int, cutoff: Date, offset: Int, tagId: String!, af: Boolean): SubforumOldFeedQueryResults!
}

extend type Mutation {
  markConversationRead(conversationId: String!): Boolean!
  sendEventTriggeredDM(eventType: String!): Boolean!
}

input SurveyQuestionInfo {
  _id: String
  question: String!
  format: String!
}

extend type Query {
  CurrentFrontpageSurvey: SurveySchedule
}

extend type Mutation {
  editSurvey(surveyId: String!, name: String!, questions: [SurveyQuestionInfo!]!): Survey
}

type DocumentDeletion {
  userId: String
  documentId: String!
  netChange: String!
  type: String
  docFields: MultiDocument
  createdAt: Date!
}

type TagUpdates {
  tag: Tag!
  revisionIds: [String!]
  commentCount: Int
  commentIds: [String!]
  lastRevisedAt: Date
  lastCommentedAt: Date
  added: Int
  removed: Int
  users: [User!]
  documentDeletions: [DocumentDeletion!]
}

type TagPreviewWithSummaries {
  tag: Tag!
  lens: MultiDocument
  summaries: [MultiDocument!]!
}

type TagWithTotalCount {
  tags: [Tag!]!
  totalCount: Int!
}

extend type Mutation {
  mergeTags(sourceTagId: String!, targetTagId: String!, transferSubtags: Boolean!, redirectSource: Boolean!): Boolean
  promoteLensToMain(lensId: String!): Boolean
}

extend type Query {
  TagUpdatesInTimeBlock(before: Date!, after: Date!): [TagUpdates!]
  TagUpdatesByUser(userId: String!, limit: Int!, skip: Int!): [TagUpdates!]
  RandomTag: Tag!
  ActiveTagCount: Int!
  TagPreview(slug: String!, hash: String): TagPreviewWithSummaries
  TagsByCoreTagId(coreTagId: String, limit: Int, searchTagIds: [String]): TagWithTotalCount!
}

type MostReadTopic {
  slug: String
  name: String
  shortName: String
  count: Int
}

type TagReadLikelihoodRatio {
  tagId: String
  tagName: String
  tagShortName: String
  userReadCount: Int
  readLikelihoodRatio: Float
}

type MostReadAuthor {
  _id: String
  slug: String
  displayName: String
  profileImageId: String
  count: Int
  engagementPercentile: Float
}

type TopCommentContents {
  html: String
}

type TopComment {
  _id: String
  postedAt: Date
  postId: String
  postTitle: String
  postSlug: String
  baseScore: Int
  extendedScore: JSON
  contents: TopCommentContents
}

type MostReceivedReact {
  name: String
  count: Int
}

type CombinedKarmaVals {
  date: Date!
  postKarma: Int!
  commentKarma: Int!
}

type WrappedDataByYear {
  engagementPercentile: Float
  postsReadCount: Int
  totalSeconds: Int
  daysVisited: [String]
  mostReadTopics: [MostReadTopic]
  relativeMostReadCoreTopics: [TagReadLikelihoodRatio]
  mostReadAuthors: [MostReadAuthor]
  topPosts: [Post]
  postCount: Int
  authorPercentile: Float
  topComment: TopComment
  commentCount: Int
  commenterPercentile: Float
  topShortform: Comment
  shortformCount: Int
  shortformPercentile: Float
  karmaChange: Int
  combinedKarmaVals: [CombinedKarmaVals]
  mostReceivedReacts: [MostReceivedReact]
  personality: String!
}

extend type Query {
  UserWrappedDataByYear(userId: String!, year: Int!): WrappedDataByYear
}

extend type Mutation {
  RefreshDbSettings: Boolean
}

type Site {
  title: String
  url: String
  logoUrl: String
}

extend type Query {
  SiteData: Site
}

type LoginReturnData {
  token: String
}

extend type Mutation {
  login(username: String, password: String): LoginReturnData
  signup(username: String, email: String, password: String, subscribeToCurated: Boolean, reCaptchaToken: String, abTestKey: String): LoginReturnData
  logout: LoginReturnData
  resetPassword(email: String): String
}

extend type Query {
  latestDialogueMessages(dialogueId: String!, numMessages: Int!): [String!]
}

extend type Mutation {
  AddForumEventVote(forumEventId: String!, x: Float!, delta: Float, postIds: [String]): Boolean
  RemoveForumEventVote(forumEventId: String!): Boolean
  RemoveForumEventSticker(forumEventId: String!, stickerId: String!): Boolean
}

extend type Query {
  getLinkSharedPost(postId: String!, linkSharingKey: String!): Post
}

extend type Mutation {
  unlockPost(postId: String!, linkSharingKey: String!): Post
  revertPostToRevision(postId: String!, revisionId: String!): Post
}

type MigrationsDashboardData {
  migrations: [MigrationStatus!]
}

type MigrationStatus {
  name: String!
  dateWritten: String
  runs: [MigrationRun!]
  lastRun: String
}

type MigrationRun {
  name: String!
  started: Date!
  finished: Date
  succeeded: Boolean
}

extend type Query {
  MigrationsDashboard: MigrationsDashboardData
}

extend type Query {
  GetAllReviewWinners: [Post!]!
}

extend type Mutation {
  sendVertexViewItemEvent(postId: String!, attributionId: String): Boolean!
  sendVertexMediaCompleteEvent(postId: String!, attributionId: String): Boolean!
  sendVertexViewHomePageEvent: Boolean!
}

type CoauthorStatus {
  userId: String
  confirmed: Boolean
  requested: Boolean
}

type ExternalPost {
  _id: String!
  slug: String
  title: String
  url: String
  postedAt: Date
  createdAt: Date
  userId: String
  modifiedAt: Date
  draft: Boolean
  content: String
  coauthorStatuses: [CoauthorStatus]
}

type ExternalPostImportData {
  alreadyExists: Boolean
  post: ExternalPost
}

extend type Mutation {
  importUrlAsDraftPost(url: String!): ExternalPostImportData!
}

input AutosaveContentType {
  type: String
  value: ContentTypeData
}

extend type Query {
  convertDocument(document: JSON, targetFormat: String): JSON
  latestGoogleDocMetadata(postId: String!, version: String): JSON
}

extend type Mutation {
  revertTagToRevision(tagId: String!, revertToRevisionId: String!): Tag
  autosaveRevision(postId: String!, contents: AutosaveContentType!): Revision
}

type ModeratorIPAddressInfo {
  ip: String!
  userIds: [String!]!
}

extend type Query {
  moderatorViewIPAddress(ipAddress: String!): ModeratorIPAddressInfo
}

extend type Mutation {
  lockThread(commentId: String!, until: String): Boolean!
  unlockThread(commentId: String!): Boolean!
}

extend type Mutation {
  reorderSummaries(parentDocumentId: String!, parentDocumentCollectionName: String!, summaryIds: [String!]!): Boolean
}

extend type Mutation {
  publishAndDeDuplicateSpotlight(spotlightId: String): Spotlight
}

extend type Mutation {
  upsertUserTypingIndicator(documentId: String!): TypingIndicator
}

extend type Mutation {
  acceptCoauthorRequest(postId: String, userId: String, accept: Boolean): Post
}

extend type Mutation {
  setIsBookmarked(postId: String!, isBookmarked: Boolean!): User!
}

extend type Mutation {
  setIsHidden(postId: String!, isHidden: Boolean!): User!
}

extend type Mutation {
  markAsReadOrUnread(postId: String, isRead: Boolean): Boolean
  markPostCommentsRead(postId: String!): Boolean
}

type RssPostChangeInfo {
  isChanged: Boolean!
  newHtml: String!
  htmlDiff: String!
}

extend type Mutation {
  resyncRssFeed(feedId: String!): Boolean!
}

extend type Query {
  RssPostChanges(postId: String!): RssPostChangeInfo!
}

extend type Mutation {
  updateContinueReading(sequenceId: String!, postId: String!): Boolean
}

extend type Mutation {
  getNewJargonTerms(postId: String!, glossaryPrompt: String, examplePost: String, exampleTerm: String, exampleAltTerm: String, exampleDefinition: String): [JargonTerm]
}

extend type Mutation {
  RSVPToEvent(postId: String, name: String, email: String, private: Boolean, response: String): Post
  CancelRSVPToEvent(postId: String, name: String, userId: String): Post
}

extend type Query {
  AdminMetadata: String
}

extend type Mutation {
  addOrUpvoteTag(tagId: String, postId: String): TagRel
  addTags(postId: String, tagIds: [String]): Boolean
}

extend type Mutation {
  analyticsEvent(events: [JSON!], now: Date): Boolean
}

extend type Query {
  currentUser: User
}

extend type Query {
  SearchSynonyms: [String!]!
}

extend type Mutation {
  UpdateSearchSynonyms(synonyms: [String!]!): [String!]!
}

extend type Mutation {
  useEmailToken(token: String, args: JSON): JSON
}

extend type Mutation {
  connectCrossposter(token: String): String
  unlinkCrossposter: String
}

extend type Query {
  getCrosspost(args: JSON): JSON
}

extend type Query {
  RevisionsDiff(collectionName: String!, fieldName: String!, id: String, beforeRev: String, afterRev: String!, trim: Boolean): String
}

extend type Mutation {
  observeRecommendation(postId: String!): Boolean
  clickRecommendation(postId: String!): Boolean
}

extend type Mutation {
  increasePostViewCount(postId: String): Float
}

extend type Mutation {
  generateCoverImagesForPost(postId: String!, prompt: String): [ReviewWinnerArt]
}

extend type Mutation {
  flipSplashArtImage(reviewWinnerArtId: String!): Boolean
}
