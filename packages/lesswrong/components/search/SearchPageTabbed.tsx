import React, { FC, RefObject, ReactElement, useEffect, useRef, useState } from 'react';
import { Components, registerComponent } from '../../lib/vulcan-lib/components';
import qs from 'qs';
import type { SearchState } from 'react-instantsearch/connectors';
import { Hits, Configure, SearchBox, Pagination, connectStats, connectScrollTo } from 'react-instantsearch-dom';
import { InstantSearch } from '../../lib/utils/componentsWithChildren';
import { isEAForum, taggingNameIsSet, taggingNamePluralCapitalSetting, taggingNameSetting } from '../../lib/instanceSettings';
import Tab from '@/lib/vendor/@material-ui/core/src/Tab';
import Tabs from '@/lib/vendor/@material-ui/core/src/Tabs';
import InfoIcon from '@/lib/vendor/@material-ui/icons/src/Info';
import IconButton from '@/lib/vendor/@material-ui/core/src/IconButton';
import moment from 'moment';
import { useSearchAnalytics } from './useSearchAnalytics';
import {
  getSearchClient,
  SearchIndexCollectionName,
  collectionIsSearchIndexed,
  isSearchEnabled,
  ElasticSorting,
  defaultElasticSorting,
  elasticSortingToUrlParam,
  getElasticIndexNameWithSorting,
  isValidElasticSorting,
} from '../../lib/search/searchUtil';
import Modal from '@/lib/vendor/@material-ui/core/src/Modal';
import classNames from 'classnames';
import { useCurrentUser } from '../common/withUser';
import { userHasPeopleDirectory } from '../../lib/betas';
import { Link } from "../../lib/reactRouterWrapper";
import { useLocation, useNavigate } from "../../lib/routeUtil";

const hitsPerPage = 10

const styles = (theme: ThemeType) => ({
  root: {
    width: "100%",
    maxWidth: 1200,
    display: 'flex',
    columnGap: 40,
    padding: '0 10px',
    margin: "auto",
    [theme.breakpoints.down('sm')]: {
      display: 'block',
      paddingTop: 24,
    }
  },
  filtersColumnWrapper: {
    [theme.breakpoints.down('sm')]: {
      display: 'none'
    },
  },
  filtersModal: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
  },
  filtersModalContent: {
    maxWidth: "max-content",
    background: theme.palette.grey[0],
    borderRadius: theme.borderRadius.default,
    padding: '20px',
    overflowY: 'auto',
    zIndex: 10001
  },
  resultsColumn: {
    flex: '1 1 0',
  },
  searchIcon: {
    marginLeft: 12
  },
  searchBoxRow: {
    display: "flex",
    alignItems: "center",
    marginBottom: 15,
    gap: '16px',
    [theme.breakpoints.down('xs')]: {
      marginBottom: 12,
    },
  },
  funnelIconButton: {
    [theme.breakpoints.up('md')]: {
      display: 'none'
    },
  },
  funnelIconLW: {
    fill: theme.palette.grey[1000],
  },
  funnelIconEA: {
    stroke: theme.palette.grey[1000],
  },
  searchInputArea: {
    flex: 1,
    display: "flex",
    alignItems: "center",
    maxWidth: 625,
    height: 48,
    border: theme.palette.border.slightlyIntense2,
    borderRadius: 3,
    "& .ais-SearchBox": {
      display: 'inline-block',
      position: 'relative',
      width: '100%',
      marginLeft: 12,
      height: 46,
      whiteSpace: 'nowrap',
      boxSizing: 'border-box',
    },
    "& .ais-SearchBox-form": {
      height: '100%'
    },
    "& .ais-SearchBox-submit":{
      display: "none"
    },
    // This is a class generated by React InstantSearch, which we don't have direct control over so
    // are doing a somewhat hacky thing to style it.
    "& .ais-SearchBox-input": {
      height: "100%",
      width: "100%",
      paddingRight: 0,
      verticalAlign: "bottom",
      borderStyle: "none",
      boxShadow: "none",
      backgroundColor: "transparent",
      fontSize: 'inherit',
      "-webkit-appearance": "none",
      cursor: "text",
      ...theme.typography.body2,
    },
  },
  searchHelp: {
    [theme.breakpoints.down('sm')]: {
      display: "none",
    },
  },
  infoIcon: {
    fontSize: 20,
    fill: theme.palette.grey[800],
  },
  tabs: {
    margin: '0 auto 20px',
    '& .MuiTab-root': {
      minWidth: 110,
      [theme.breakpoints.down('xs')]: {
        minWidth: 50
      }
    },
    '& .MuiTab-labelContainer': {
      fontSize: '1rem'
    }
  },
  resultCount: {
    fontFamily: theme.typography.fontFamily,
    fontWeight: 400,
    fontSize: 14,
    color: theme.palette.grey[700],
    marginBottom: 20
  },
  pagination: {
    ...theme.typography.commentStyle,
    fontSize: 16,
    '& li': {
      padding: 8
    },
    '& .ais-Pagination-item': {
      color: theme.palette.primary.main,
    },
    '& .ais-Pagination-item--firstPage': {
      paddingLeft: 0
    },
    '& .ais-Pagination-item--page': {
      fontWeight: 600
    },
    '& .ais-Pagination-item--selected': {
      color: theme.palette.grey[900]
    },
    '& .ais-Pagination-item--disabled': {
      color: theme.palette.grey[500]
    }
  },
  peopleDirectory: {
    display: "block",
    padding: "16px 12px",
    fontSize: 14,
    fontWeight: 600,
    fontFamily: theme.palette.fonts.sansSerifStack,
    color: theme.palette.primary.main,
    background: theme.palette.primaryAlpha(0.05),
    borderRadius: theme.borderRadius.small,
    marginBottom: 20,
    maxWidth: 585,
    "&:hover": {
      opacity: 0.8,
    },
  },
});

export type ExpandedSearchState = SearchState & {
  contentType?: SearchIndexCollectionName,
  refinementList?: {
    tags: Array<string>|''
  }
}

// shows total # of results
const Stats = ({ nbHits, className }: {
  nbHits: number,
  className: string
}) => {
  return <div className={className}>
    {nbHits} result{nbHits === 1 ? '' : 's'}
  </div>
}
const CustomStats = connectStats(Stats)

const ScrollTo: FC<{
  targetRef: RefObject<HTMLDivElement>,
  value: string,
  hasNotChanged: boolean,
  children: ReactElement,
}> = ({targetRef, value, hasNotChanged, children}) => {
  const prevValue = useRef(value);
  useEffect(() => {
    if (value !== prevValue.current && hasNotChanged) {
      targetRef.current?.scrollIntoView({
        behavior: "smooth",
      });
    }
    prevValue.current = value;
  }, [targetRef, value, hasNotChanged]);
  return children;
}
const CustomScrollTo = connectScrollTo(ScrollTo);

const SearchPageTabbed = ({classes}: {
  classes: ClassesType<typeof styles>,
}) => {
  const scrollToRef = useRef<HTMLDivElement>(null);
  const navigate = useNavigate();
  const { location, query } = useLocation()
  const captureSearch = useSearchAnalytics();
  const currentUser = useCurrentUser();

  // store these values for the search filter
  const pastDay = useRef(moment().subtract(24, 'hours').valueOf())
  const pastWeek = useRef(moment().subtract(7, 'days').valueOf())
  const pastMonth = useRef(moment().subtract(1, 'months').valueOf())
  const pastYear = useRef(moment().subtract(1, 'years').valueOf())
  const dateRangeValues = [pastDay, pastWeek, pastMonth, pastYear];

  // initialize the tab & search state from the URL
  const [tab, setTab] = useState<SearchIndexCollectionName>(() => {
    const contentType = query.contentType as SearchIndexCollectionName
    return collectionIsSearchIndexed(contentType) ? contentType : 'Posts'
  })
  const [tagsFilter, setTagsFilter] = useState<Array<string>>(
    [query.tags ?? []].flatMap(tags => tags)
  )

  const {sort: initialSorting, ...initialSearchState} = qs.parse(location.search.slice(1));
  const [searchState, setSearchState] = useState<ExpandedSearchState>(initialSearchState);
  const [sorting, setSorting] = useState<ElasticSorting>(
    isValidElasticSorting(initialSorting) ? initialSorting : defaultElasticSorting,
  );

  const [modalOpen, setModalOpen] = useState(false);

  const onSortingChange = (newSorting: string) => {
    if (!isValidElasticSorting(newSorting)) {
      throw new Error("Invalid search sorting: " + newSorting);
    }
    setSorting(newSorting);
    navigate({
      ...location,
      search: qs.stringify({
        ...searchState,
        sort: elasticSortingToUrlParam(newSorting),
      }),
    }, {replace: true});
  }

  const {
    ErrorBoundary, ExpandedUsersSearchHit, ExpandedPostsSearchHit, ExpandedCommentsSearchHit,
    ExpandedTagsSearchHit, ExpandedSequencesSearchHit, LWTooltip, ForumIcon
  } = Components;

  // we try to keep the URL synced with the search state
  const updateUrl = (search: ExpandedSearchState, tags: Array<string>) => {
    navigate({
      ...location,
      search: qs.stringify({
        contentType: search.contentType,
        query: search.query,
        tags,
        toggle: search.toggle,
        page: search.page,
        sort: elasticSortingToUrlParam(sorting),
      })
    }, {replace: true})
  }

  const handleChangeTab = (_: React.ChangeEvent, value: SearchIndexCollectionName) => {
    setTab(value);
    setSorting(defaultElasticSorting);
    setSearchState({...searchState, contentType: value, page: 1});
  }
  // filters that we want to persist when changing content type tabs need to be handled separately
  // (currently that's just the tags filter)
  const handleUpdateTagsFilter = (tags: Array<string>) => {
    setTagsFilter(tags)
    updateUrl(searchState, tags)
  }
  
  const onSearchStateChange = (updatedSearchState: ExpandedSearchState) => {
    // clear tags filter if the tag refinements list is empty
    const clearTagFilters = updatedSearchState.refinementList?.tags === ''
    if (clearTagFilters)
      setTagsFilter([])
      
    updateUrl(updatedSearchState, clearTagFilters ? [] : tagsFilter)
    setSearchState(updatedSearchState)
  }

  useEffect(() => {
    if (searchState.query) {
      captureSearch("searchPageTabbed", searchState);
    }
  }, [searchState, captureSearch])

  useEffect(() => {
    if (query.query !== searchState?.query) {
      setSearchState((current) => ({
        ...current,
        page: "1",
        query: query.query,
      }));
    }
  }, [query.query, searchState?.query]);

  if (!isSearchEnabled()) {
    return <div className={classes.root}>
      Search is disabled (ElasticSearch not configured on server)
    </div>
  }
  
  // component for search results depends on which content type tab we're on
  const hitComponents = {
    'Posts': ExpandedPostsSearchHit,
    'Comments': ExpandedCommentsSearchHit,
    'Tags': ExpandedTagsSearchHit,
    'Sequences': ExpandedSequencesSearchHit,
    'Users': ExpandedUsersSearchHit
  }
  const HitComponent = hitComponents[tab]

  return <div className={classes.root}>
    <InstantSearch
      indexName={getElasticIndexNameWithSorting(tab, sorting)}
      searchClient={getSearchClient({emptyStringSearchResults: "default"})}
      searchState={searchState}
      onSearchStateChange={onSearchStateChange}
    >

      <div className={classes.filtersColumnWrapper}>
        <Components.SearchFilters
          tab={tab}
          tagsFilter={tagsFilter}
          handleUpdateTagsFilter={handleUpdateTagsFilter}
          onSortingChange={onSortingChange}
          sorting={sorting}
          dateRangeValues={dateRangeValues}
          setModalOpen={setModalOpen}
        />
      </div>

      <div className={classes.resultsColumn}>
        <div className={classes.searchBoxRow}>
          <div className={classes.searchInputArea}>
            <ForumIcon icon="Search" className={classes.searchIcon}/>
            {/* Ignored because SearchBox is incorrectly annotated as not taking null for its reset prop, when
              * null is the only option that actually suppresses the extra X button.
            // @ts-ignore */}
            <SearchBox defaultRefinement={query.query} reset={null} focusShortcuts={[]} autoFocus={true} />
            <div onClick={() => setModalOpen(true)}>
              <IconButton className={classes.funnelIconButton}>
                <ForumIcon icon="Funnel" className={classNames({[classes.funnelIconLW]: !isEAForum, [classes.funnelIconEA]: isEAForum})}/>
              </IconButton>
            </div>
          </div>
          <LWTooltip
            title={`"Quotes" and -minus signs are supported. Use user:"Jane Doe" or ${taggingNameSetting.get()}:"Expected value" to filter by user or ${taggingNameSetting.get()}.`}
            className={classes.searchHelp}
          >
            <InfoIcon className={classes.infoIcon}/>
          </LWTooltip>
        </div>

        <div ref={scrollToRef} />

        <Modal
          open={modalOpen}
          onClose={() => setModalOpen(false)}
          aria-labelledby="search-filters-modal"
          aria-describedby="search-filters-modal"
          className={classNames(classes.filtersModal)}
          keepMounted
        >
          <div className={classes.filtersModalContent}>
            <Components.SearchFilters
              tab={tab}
              tagsFilter={tagsFilter}
              handleUpdateTagsFilter={handleUpdateTagsFilter}
              onSortingChange={onSortingChange}
              sorting={sorting}
              dateRangeValues={dateRangeValues}
              setModalOpen={setModalOpen}
            />
          </div>
        </Modal>

        <Tabs
          value={tab}
          onChange={handleChangeTab}
          className={classes.tabs}
          textColor="primary"
          aria-label="select content type to search"
          scrollable
          scrollButtons="off"
        >
          <Tab label="Posts" value="Posts" />
          <Tab label="Comments" value="Comments" />
          <Tab label={taggingNameIsSet.get() ? taggingNamePluralCapitalSetting.get() : 'Tags and Wiki'} value="Tags" />
          <Tab label="Sequences" value="Sequences" />
          <Tab label="Users" value="Users" />
        </Tabs>

        <ErrorBoundary>
          <Configure hitsPerPage={hitsPerPage} />
          <CustomStats className={classes.resultCount} />
          {userHasPeopleDirectory(currentUser) && tab === "Users" && searchState?.query &&
            <Link
              to={`/people-directory?query=${encodeURIComponent(searchState.query)}`}
              className={classes.peopleDirectory}
            >
              -&gt; View results in People directory (beta)
            </Link>
          }
          <CustomScrollTo targetRef={scrollToRef}>
            <Hits hitComponent={(props) => <HitComponent {...props} />} />
          </CustomScrollTo>
          <Pagination showLast className={classes.pagination} />
        </ErrorBoundary>
      </div>
    </InstantSearch>
  </div>
}

const SearchPageTabbedComponent = registerComponent("SearchPageTabbed", SearchPageTabbed, {styles})

declare global {
  interface ComponentTypes {
    SearchPageTabbed: typeof SearchPageTabbedComponent
  }
}
