import { v4 } from 'uuid';
import { AsyncLocalStorage } from 'async_hooks';
import LRU from 'lru-cache';

import { queuePerfMetric } from './analyticsWriter';
import type { Request, Response, NextFunction } from 'express';
import { performanceMetricLoggingEnabled, performanceMetricLoggingSqlSampleRate } from '../lib/instanceSettings';
import { getClientIP } from './utils/getClientIP';

type IncompletePerfMetricProps = Pick<PerfMetric, 'op_type' | 'op_name' | 'parent_trace_id' | 'extra_data' | 'client_path' | 'gql_string' | 'sql_string' | 'ip' | 'user_agent' | 'user_id'>;

interface AsyncLocalStorageContext {
  requestPerfMetric?: IncompletePerfMetric;
  inDbRepoMethod?: boolean;
}

export const asyncLocalStorage = new AsyncLocalStorage<AsyncLocalStorageContext>();

export function setAsyncStoreValue<T extends keyof AsyncLocalStorageContext>(key: T, value: AsyncLocalStorageContext[T] | ((previousValue: AsyncLocalStorageContext[T]) => AsyncLocalStorageContext[T])) {
  const store = asyncLocalStorage.getStore();
  if (store) {
    if (typeof value === 'function') {
      store[key] = value(store[key]);
    } else {
      store[key] = value;
    }
  }
};

export function generateTraceId() {
  return v4();
}

export function getParentTraceId() {
  const store = asyncLocalStorage.getStore();

  let parentTraceIdField;
  if (store) {
    parentTraceIdField = { parent_trace_id: store.requestPerfMetric?.trace_id }
  } else {
    parentTraceIdField = {};
  }

  return parentTraceIdField;
}

export function openPerfMetric(props: IncompletePerfMetricProps, startedAtOverride?: Date): IncompletePerfMetric {
  return {
    ...props,
    started_at: startedAtOverride ?? new Date(),
    trace_id: v4(),
  };
}

export function closePerfMetric(openPerfMetric: IncompletePerfMetric, endedAtOverride?: Date) {
  const perfMetric = {
    ...openPerfMetric,
    ended_at: endedAtOverride ?? new Date()
  };

  queuePerfMetric(perfMetric);
}

export function wrapWithPerfMetric<T extends () => AnyBecauseHard>(operation: T, perfMetricGenerator: () => IncompletePerfMetric): ReturnType<T> {
  if (!performanceMetricLoggingEnabled.get()) {
    return operation();
  }

  const openedPerfMetric = perfMetricGenerator();
  const result = operation();
  if (result instanceof Promise) {
    return result.then((res) => {
      closePerfMetric(openedPerfMetric);
      return res;
    }) as ReturnType<T>;
  }

  closePerfMetric(openedPerfMetric);
  return result;
}

export function addStartRenderTimeToPerfMetric() {
  setAsyncStoreValue('requestPerfMetric', (incompletePerfMetric) => {
    if (!incompletePerfMetric) {
      // eslint-disable-next-line no-console
      console.log('Missing perf metric for the current request in the asyncLocalStorage context when trying to add start render time to it!');
      return;
    }
    
    return {
      ...incompletePerfMetric,
      render_started_at: new Date()
    };
  });
}

const fiftyThreeBits = Math.pow(2, 53);

/**
 * Modified form of https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
 * Returns a pseudorandom number between 0 and 1 by hashing the input
 */
export function cyrb53Rand(str: string, seed = 0) {
  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
  for(let i = 0, ch; i < str.length; i++) {
      ch = str.charCodeAt(i);
      h1 = Math.imul(h1 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1  = Math.imul(h1 ^ (h1 >>> 16), 2246822507);
  h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);
  h2  = Math.imul(h2 ^ (h2 >>> 16), 2246822507);
  h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909);

  return ((4294967296 * (2097151 & h2)) + (h1 >>> 0)) / fiftyThreeBits;
};

// Let's not recompute each trace ID's hash for every child operation we might want to sample
const SAMPLE_TRACE_CACHE = new LRU<string, boolean>({ max: 500 });

function sampleSqlQueryPerfMetric(parentTraceId: string) {
  const cachedShouldSample = SAMPLE_TRACE_CACHE.get(parentTraceId);
  if (typeof cachedShouldSample === 'boolean') return cachedShouldSample;

  const sampleRate = performanceMetricLoggingSqlSampleRate.get();
  const parentTraceHash = cyrb53Rand(parentTraceId);
  const shouldSample = sampleRate > parentTraceHash;

  SAMPLE_TRACE_CACHE.set(parentTraceId, shouldSample);

  return shouldSample;
}

export function recordSqlQueryPerfMetric(sqlString: string, startTime: number, endTime: number) {
  if (!performanceMetricLoggingEnabled.get()) {
    return;
  }

  const store = asyncLocalStorage.getStore();

  const parentTraceId = store?.requestPerfMetric?.trace_id;
  // Don't sample anything that doesn't have a parent trace id
  // This will miss some stuff generated by e.g. cron jobs or server-sent events, but it's not worth the headache
  if (!parentTraceId || !sampleSqlQueryPerfMetric(parentTraceId)) {
    return;
  }

  // We're already recording repo methods in their entirety,
  // so it doesn't seem helpful to separately record the raw SQL queries that get executed by them
  if (!store?.inDbRepoMethod) {
    const partialMetric = openPerfMetric({
      op_type: 'sql_query',
      op_name: 'compiled', // TODO: what do we even record here?
      parent_trace_id: parentTraceId,
      sql_string: sqlString
    }, new Date(startTime));
  
    closePerfMetric(partialMetric, new Date(endTime));
  }
}

/**
 * We have a dedicated function to send off the perf metric for the top-level request
 * This is because we track it in the async local storage context,
 * and we want to be careful not to send it multiple times, or leave it accessible after it's been sent off
 */
export function closeRequestPerfMetric() {
  const store = asyncLocalStorage.getStore();
  if (!store) {
    // eslint-disable-next-line no-console
    console.log('Missing asyncLocalStorage context when trying to close the perf metric for the current request!');
    return;
  }

  if (!store.requestPerfMetric) {
    // eslint-disable-next-line no-console
    console.log('Missing perf metric for the current request in the asyncLocalStorage context when trying to close it!');
    return;
  }

  closePerfMetric(store.requestPerfMetric);
  setAsyncStoreValue('requestPerfMetric', undefined);
}

export function perfMetricMiddleware(req: Request, res: Response, next: NextFunction) {
  if (!performanceMetricLoggingEnabled.get()) {
    return next();
  }

  const perfMetric = openPerfMetric({
    op_type: 'request',
    op_name: req.originalUrl,
    client_path: req.headers['request-origin-path'] as string,
    ip: getClientIP(req),
    user_agent: req.headers["user-agent"],
    user_id: req.user?._id,
  });

  res.on('finish', () => {
    closeRequestPerfMetric();
  });
  
  // This starts an async context for requests that pass through this middleware
  asyncLocalStorage.run<void, []>({ requestPerfMetric: perfMetric }, next);
}
