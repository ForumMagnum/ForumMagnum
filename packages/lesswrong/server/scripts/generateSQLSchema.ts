import { format as sqlFormatter } from 'sql-formatter';
import { getAllCollections, isValidCollectionName } from "@/server/collections/allCollections";
import Table from "@/server/sql/Table";
import CreateTableQuery from "@/server/sql/CreateTableQuery";
import { writeFileSync } from 'node:fs'
import path from 'path';
import { PostgresFunction, postgresFunctions } from '../postgresFunctions';
import { PostgresExtension, postgresExtensions } from '../postgresExtensions';
import CreateExtensionQuery from '@/server/sql/CreateExtensionQuery';
import CreateIndexQuery from '@/server/sql/CreateIndexQuery';
import { sqlInterpolateArgs } from '@/server/sql/Type';
import type { CustomPgIndex } from '../../lib/utils/databaseIndexSet';
import { PostgresView, getAllPostgresViews } from '../postgresView';
import TableIndex from '@/server/sql/TableIndex';
import { getAllIndexes } from '../databaseIndexes/allIndexes';
import PgCollection from '../sql/PgCollection';

const acceptedSchemePath = (rootPath: string) => path.join(rootPath, "schema/accepted_schema.sql");

const schemaFileHeaderTemplate = `-- GENERATED FILE
-- Do not edit this file directly. Instead, start a server and run "yarn generate"
-- as described in the README. This file should nevertheless be checked in to version control.

`

declare global {
  type SchemaDependency =
    {type: "extension", name: PostgresExtension} |
    {type: "collection", name: CollectionNameString} |
    {type: "function", name: string} |
    {type: "view", name: string};
}

abstract class Node {
  public dependencies: SchemaDependency[] = [];

  addDependency(dependency: SchemaDependency) {
    this.dependencies.push(dependency);
  }

  abstract getName(): string;
  abstract getQuery(): {compile(): {sql: string, args: any[]}};

  getHeader(): string {
    const type = this.constructor.name.replace(/(_|Node)/g, "");
    return `-- ${type} "${this.getName()}"`;
  }

  getSource(): string {
    const {sql, args} = this.getQuery().compile();
    return sqlInterpolateArgs(sql, args).trim();
  }

  getAnnotatedSource(): string {
    const source = this.getSource();
    const hasSemi = source[source.length - 1] === ";";
    return `${this.getHeader()}\n${source}${hasSemi ? "" : ";"}\n`;
  }
}

class ExtensionNode extends Node {
  constructor(private extension: PostgresExtension) {
    super();
  }

  getName() {
    return this.extension;
  }

  getQuery() {
    return new CreateExtensionQuery(this.extension);
  }
}

class TableNode extends Node {
  constructor(private table: Table<DbObject>) {
    super();
  }

  getName() {
    return this.table.getName();
  }

  getQuery() {
    return new CreateTableQuery(this.table);
  }
}

class IndexNode extends Node {
  constructor(
    private table: Table<DbObject>,
    private index: TableIndex<DbObject>,
  ) {
    super();
    this.addDependency({
      type: "collection",
      name: table.getName() as CollectionNameString,
    });
  }

  getName() {
    return this.index.getName();
  }

  getQuery() {
    return new CreateIndexQuery({ table: this.table, index: this.index, ifNotExists: true, allowConcurrent: false });
  }
}

class CustomIndexNode extends Node {
  private static nameRegex = /^\s*CREATE\s+(UNIQUE\s+)?INDEX\s+(CONCURRENTLY\s+)?(IF\s+NOT\s+EXISTS\s+)?"?([a-zA-Z0-9_]+)/i;
  private static targetRegex = /.*ON\s+(public\.)?"([A-Za-z0-9_]+)"/i;
  private static concurrentRegex = /\s+CONCURRENTLY\s+/gi;

  private name: string;

  constructor(private index: CustomPgIndex) {
    super();
    const {source, options} = index;
    const name = source.match(CustomIndexNode.nameRegex)?.[4];
    if (!name) {
      throw new Error(`Can't parse name for custom index: ${source}`);
    }
    this.name = name;

    const target = source.match(CustomIndexNode.targetRegex)?.[2];
    if (!target) {
      throw new Error(`Can't parse target for custom index "${name}"`);
    }
    const dependency: SchemaDependency = isValidCollectionName(target)
      ? {type: "collection", name: target}
      : {type: "view", name: target};
    this.addDependency(dependency);

    this.dependencies = this.dependencies.concat(options?.dependencies ?? []);
  }

  getName() {
    return this.name;
  }

  getQuery() {
    return {
      compile: () => ({
        sql: this.index.source.trim().replace(CustomIndexNode.concurrentRegex, " "),
        args: [],
      }),
    };
  }
}

class FunctionNode extends Node {
  private static nameRegex = /^\s*CREATE\s+(OR\s+REPLACE\s+)?FUNCTION\s+([a-zA-Z0-9_]+)/i;

  private name: string;

  constructor(private func: PostgresFunction) {
    super();
    const name = func.source.match(FunctionNode.nameRegex)?.[2];
    if (!name) {
      throw new Error(`Can't find name for function: ${func.source}`);
    }
    const overload = func.overload ? `_${func.overload}` : "";
    this.name = name + overload;
    this.dependencies = this.dependencies.concat(func.dependencies ?? []);
  }

  getName() {
    return this.name;
  }

  getQuery() {
    return {
      compile: () => ({
        sql: this.func.source.trim(),
        args: [],
      }),
    };
  }
}

class ViewNode extends Node {
  constructor(private view: PostgresView) {
    super();
  }

  getName() {
    return this.view.getName();
  }

  getQuery() {
    return {
      compile: () => ({
        sql: this.view.getCreateViewQuery().trim(),
        args: [],
      }),
    };
  }
}

class Graph {
  private nodes: Record<string, Node> = {};

  addNode(node: Node) {
    const name = node.getName();
    if (this.nodes[name]) {
      throw new Error(`Duplicate node names: "${name}"`);
    }
    this.nodes[name] = node;
  }

  addNodes(nodes: Node[]) {
    for (const node of nodes) {
      this.addNode(node);
    }
  }

  linearize(): Node[] {
    const stack: Node[] = [];
    const unvisited = new Set<string>(Object.keys(this.nodes));

    const depthFirstSearch = (nodeName: string, parents: string[]) => {
      if (parents.includes(nodeName)) {
        throw new Error(`Dependency cycle detected for ${nodeName} via ${parents}`);
      }

      const node = this.nodes[nodeName];
      if (!node) {
        throw new Error(`Invalid node: "${nodeName}"`);
      }

      if (!unvisited.has(nodeName)) {
        return;
      }
      unvisited.delete(nodeName);

      for (const dependency of node.dependencies) {
        depthFirstSearch(dependency.name, [...parents, nodeName]);
      }

      stack.push(node);
    }

    unvisited.forEach((node) => depthFirstSearch(node, []));

    return stack;
  }
}

const buildSchemaSQL = () => {
  const graph = new Graph();
  graph.addNodes(postgresExtensions.map((e) => new ExtensionNode(e)));
  const allIndexes = getAllIndexes();
  graph.addNodes(getAllCollections().flatMap((collection) => {
    const collectionName = collection.collectionName;
    if (collection instanceof PgCollection) {
      // Because of some import issues (probably related to `repl` setup) I haven't figured out yet,
      // we need to call `buildPostgresTable` here to make sure the fields on the table exist.
      collection.buildPostgresTable();
      const table = collection.getTable();
      const tableIndexes = (allIndexes.mongoStyleIndexes[collectionName] ?? []).map((i) => new TableIndex(table.getName(), i.key, i.options));
      const indexes: Node[] = tableIndexes.map((i) => new IndexNode(table, i));
      return indexes.concat(new TableNode(table));
    }
    return [];
  }));
  const customPgIndexes = getAllIndexes().customPgIndexes;
  graph.addNodes(customPgIndexes.map((i) => new CustomIndexNode(i)));
  graph.addNodes(postgresFunctions.map((f) => new FunctionNode(f)));
  graph.addNodes(getAllPostgresViews().flatMap((view) => {
    const indexQueries = view.getCreateIndexQueries();
    const indexes: Node[] = indexQueries.map((source) => new CustomIndexNode({source}));
    return indexes.concat(new ViewNode(view));
  }));
  const nodes = graph.linearize();
  const rawSchema = nodes.map((n) => n.getAnnotatedSource()).join("\n");
  const schemaFileContents = sqlFormatter(rawSchema, {
    language: "postgresql",
    linesBetweenQueries: 1,
    tabWidth: 2,
    useTabs: false,
    keywordCase: "upper",
    dataTypeCase: "upper",
    functionCase: "upper",
    identifierCase: "preserve",
    logicalOperatorNewline: "after",
    paramTypes: {
      positional: false,
      numbered: [],
      named: [],
      quoted: [],
      custom: [],
    },
  });
  return schemaFileHeaderTemplate + schemaFileContents + "\n";
}

export const generateSQLSchema = (rootPath: string|null = null) => {
  const sqlSchema = buildSchemaSQL();
  writeFileSync(acceptedSchemePath(rootPath ?? process.cwd()), sqlSchema);
}

