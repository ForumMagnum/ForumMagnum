import mysql from 'mysql2/promise';

// The following Typescript types were generated by LLM-translation of Arbital's
// mysql schema. Comments are from the Arbital codebase.

// When a page's alias is changed, we add a row in this table.
type AliasRedirectsRow = { //{{_}}
  // The old alias.
  oldAlias: string;
  // The new alias.
  newAlias: string;
};

// TODO: we are not actually using this table ATM, but probably should.
// This table contains all the anchors. An anchor determines a specific place
// inside a page, including the paragraph and the specific text within it.
type AnchorsRow = { //{{_}}
  // Id of this anchor.
  id: number;
  // Text of the paragraph the anchor is in.
  paragraph: string;
  // Text within the paragraph. If empty, assume it's attached to the entire
  // pararaph.
  text: string;
  // Offset of the text inside the paragraph.
  offset: number;
  // When this was created.
  createdAt: Date;
};

// A row for every answer. An answer is a pointer to another page, and it's always
// attached to a question.
type AnswersRow = { //{{_}}
  // Id of this answer.
  id: number;
  // Id of the question this answer is for. FK into pages.
  questionId: string;
  // Id of the user who added this string. FK into users.
  answerPageId: string;
  // Id of the user who added this answer. FK into users.
  userId: string;
  // Date this answer was created.
  createdAt: Date;
};

// This table contains an entry for every change that a page undergoes.
type ChangeLogsRow = { //{{_}}
  // Unique update id. PK.
  id: number;
  // Likeable id for this changelog. Partial FK into likes.
  // Note that this is not set until the first time this changelog is liked.
  likeableId: number;
  // The user who caused this event. FK into users.
  userId: string;
  // The affected page. FK into pages.
  pageId: string;
  // Optional edit number of the affected page. Partial FK into pages.
  edit: number;
  // Type of update
  type: string;
  // When this update was created.
  createdAt: Date;
  // This is set for various events. E.g. if a new parent is added, this will
  // be set to the parent id.
  auxPageId: string;
  // So that we can show what changed in the change log.
  oldSettingsValue: string;
  newSettingsValue: string;
};

// An entry for every content request pair (page and type)
type ContentRequestsRow = { //{{_}}
  // Id of the request.
  id: number;
  // The page the request was made for. FK into pages.
  pageId: string;
  // Type of request. E.g. slowDown, speedUp, etc.
  type: string;
  // Id by which we track likes. FK into likes.
  likeableId: number;
  // Date this entry was created.
  createdAt: Date;
};

// This table contains all the subscriptions to discussions (page or comments).
type DiscussionSubscriptionsRow = { //{{_}}
  // User id of the subscriber. FK into users.
  userId: string;
  // Id of page/comment the user is subscribed to. FK into pageInfos.
  toPageId: string;
  // When this subscription was created.
  createdAt: Date;
};

// This table contains all domain pairs that are friendly with each other.
type DomainFriendsRow = { //{{_}}
  // Domain id. FK into domains.
  domainId: number;
  // Id of another domain this domain is friends with. FK into domains.
  friendId: number;
  // When this friendship was originally created.
  createdAt: Date;
  // Id of the user who created the friendship. FK into users.
  createdBy: string;
};

// An entry for every member in a domain.
type DomainMembersRow = { //{{_}}
  // Id of the domain. FK into domains.
  domainId: number;
  // Id of the user member. FK into users.
  userId: string;
  // Date this user was added.
  createdAt: Date;
  // User's role in this domain.
  role: string;
};

// This table contains all domains and relevant info.
export type DomainsRow = { //{{_}}
  // Domain id.
  id: number;
  // Id of the home page for this domain. FK into pageInfos.
  pageId: string;
  // When this page was originally created.
  createdAt: Date;
  // Id of the user who created the page. FK into users.
  createdBy: string;
  // Alias name of the domain.
  alias: string;
  // ============ Various domain settings ============
  // If true, any registered user can comment.
  canUsersComment: boolean;
  // If true, any registered user can propose a comment.
  canUsersProposeComment: boolean;
  // If true, any registered user can propose an edit.
  canUsersProposeEdits: boolean;
};

// This table contains all the feed pages.
type FeedPagesRow = { //{{_}}
  // Id of the domain feed. FK into domains.
  domainId: number;
  // Id of the page in the feed. FK into pageInfos.
  pageId: string;
  // Id of the user who submitted it to the feed. FK into users.
  submitterId: string;
  // When this submission was made.
  createdAt: Date;
  // Score for this feed page, determining where it appears in the feed.
  score: number;
};

// An entry for every invite.
type InvitesRow = { //{{_}}
  // Id of user sending invite. FK into users.
  fromUserId: string;
  // Id of domain that this invite is for. FK into domains.
  domainId: number;
  // Role the invited user will receive.
  role: string;
  // Email address to send invite to.
  toEmail: string;
  // Date this invite was created.
  createdAt: Date;
  // If a user claimed this invite, this is their id. FK into users.
  toUserId: string;
  // Date this invite was claimed
  claimedAt: Date;
  // When the invite email was sent.
  emailSentAt: Date;
};

// A table for keeping track of the last time the user saw various things
type LastViewsRow = { //{{_}}
  // Id of the user who viewed the thing.
  userId: string;
  // The thing the user viewed.
  viewName: string;
  // The last time the user viewed the thing.
  viewedAt: Date;
};

// Each row is a page-user pair with the date and time when the user has last seen the page.
type LastVisitsRow = { //{{_}}
  // FK into users.
  userId: string;
  // Page id. FK into pages.
  pageId: string;
  // Date of the first visit.
  createdAt: Date;
  // Date of the last visit.
  updatedAt: Date;
};

// This table contains all information about lens relationships.
export type LensesRow = { //{{_}}
  // Id of the lens relationships.
  id: number;
  // Id of the page that has the lens. FK into pageInfos.
  pageId: string;
  // Id of the lens page. FK into pageInfos.
  lensId: string;
  // Ordering index when sorting the page's lenses.
  lensIndex: number;
  // Lens name that shows up in the tab.
  lensName: string;
  // Lens subtitle that shows up in the tab.
  lensSubtitle: string;
  // Id of the user who created the relationship. FK into users.
  createdBy: string;
  // When this lens relationship was originally created.
  createdAt: Date;
  // Id of the last user who updated the relationship. FK into users.
  updatedBy: string;
  // When this relationship was updated last.
  updatedAt: Date;
};

// A table for keeping track of likeableIds
type LikeableIdsRow = { //{{_}}
  // Id of the likeable.
  id: number;
};

// An entry for every like a user cast for a likeable object, such as a page
// or changelog.
type LikesRow = { //{{_}}
  // Id of the user who liked. FK into users.
  userId: string;
  // Id of the likeable this like is for.
  likeableId: number;
  // User's trust when they made the like. FK into userTrustSnapshots
  userTrustSnapshotId: number;
  // Like value [-1,1].
  value: number;
  // Date this like was created.
  createdAt: Date;
  // Date this like was updated.
  updatedAt: Date;
};

// When a parent page has a link to a child page, we add a row in this table.
type LinksRow = { //{{_}}
  // Id of the parent page. FK into pages.
  parentId: string;
  // Alias or id of the child claim.
  childAlias: string;
};

// This table contains all the maintainance subscriptions.
type MaintainerSubscriptionsRow = { //{{_}}
  // User id of the subscriber. FK into users.
  userId: string;
  // Id of the page the user is subscribed to. FK into pageInfos.
  toPageId: string;
  // When this subscription was created.
  createdAt: Date;
};

// This table contains all the marks. A mark is an annotation that's attached
// to a page at a specific location.
type MarksRow = { //{{_}}
  // Id of this mark.
  id: number;
  // Type of this mark.
  type: string;
  // Id of the page this mark is on. FK into pageInfos.
  pageId: string;
  // Which edit was live when this mark was created.
  edit: number;
  // Id of the user who created this mark. FK into users.
  creatorId: string;
  // When this was created.
  createdAt: Date;
  // User's snapshotted requisites. FK into userRequisitePairSnapshots.
  requisiteSnapshotId: number;
  // Optional text associated with this mark.
  text: string;
  // Set to true when mark owner submitted the mark and it
  // can be shown to authors.
  isSubmitted: boolean;
  // Text of the paragraph the anchor is in.
  anchorContext: string;
  // Text the comment is attached to.
  anchorText: string;
  // Offset of the text into the context.
  anchorOffset: number;
  // If an author resolves this mark, this variable is set. It might be set to
  // the page the mark is on (e.g. for "typo" marks) or to the question page id
  // to which the mark was linked (e.g. for "query" marks).
  // FK into pageInfos.
  resolvedPageId: string;
  // Id of the user who resolved / dismissed the mark. FK into users.
  resolvedBy: string;
  // When this mark was resolved.
  resolvedAt: Date;
  // ============= Variables specifically for query-typed marks =============
  // Set to true once there is an answer that works for the given user.
  answered: boolean;
  // When this mark was answered.
  answeredAt: Date;
};

// This table contains various information about the pages. This info is not
// dependent on any specific edit number.
export type PageInfosRow = { //{{_}}
  // Id of the page the info is for.
  pageId: string;
  // Likeable id for this page. Partial FK into likes.
  // Note that this is not set until the first time this page is liked.
  likeableId: number;
  // Edit number currently used to display the page. 0 if this page hasn't
  // been published.
  currentEdit: number;
  // Maximum edit number used by this page.
  maxEdit: number;
  // When this page was originally created.
  createdAt: Date;
  // Id of the user who created the page. FK into users.
  createdBy: string;
  // Alias name of the page.
  alias: string;
  // Page's type.
  type: "group"|"wiki"|"comment"|"question";
  // How to sort the page's children.
  sortChildrenBy: string;
  // True iff the page has a probability vote.
  hasVote: boolean;
  // Type of the vote this page has. If empty string, it has never been set.
  // But once voting is set, it can only be turned on/off, the type cannot be
  // changed.
  voteType: string;
  // If true, votes on this page are anonymous
  votesAnonymous: boolean;
  // If true, this page teaches its requisites indirectly (e.g. by providing links).
  indirectTeacher: boolean;
  // True iff this page is currently in a deleted state.
  isDeleted: boolean;
  // If set, this page has been merged into the mergedInto page id. FK into pageInfos.
  mergedInto: string;
  // Number of different users who looked at this page.
  viewCount: number;
  // When this page has been added to the Featured section
  featuredAt: Date;
  // If set, when this page is published, it will be submitted to this domain
  submitToDomainId: number;
  // === Permission settings ===
  // see: who can see the page
  // edit: who can do things to the page
  // If set, only users in this domain can see the page. FK into domains.
  seeDomainId: number;
  // If set, only users in this domain can do things to the page. FK into domains.
  editDomainId: number;
  // If set, the page is locked by this user. FK into users.
  lockedBy: string;
  // Time until the user has this lock.
  lockedUntil: Date;
  // == Following variables are set for some specific pages. ==
  // If this page is a lens, this is its ordering index when sorting its parent's
  // lenses from most simple to most technical.
  lensIndex: number;
  // If true, this comment is meant for editors only.
  isEditorComment: boolean;
  // If true, this comment has been approved by a reviewer.
  isApprovedComment: boolean;
  // If true, this comment thread is resolved and should be hidden.
  isResolved: boolean;
  // If set, this page is a link to an external resource with this url.
  externalUrl: string;
};

// Each row describes a parent-child page relationship.
type PagePairsRow = { //{{_}}
  id: number;
  // Parent page id. FK into pages.
  parentId: string;
  // Child page id. Part of the FK into pages.
  childId: string;
  // Type of the relationship.
  // parent: parentId is a parent of childId
  // tag: parentId is a tag of childId
  // requirement: parentId is a requirement of childId
  // subject: parentId is a subject that childId teaches
  // Easy way to memorize: {parentId} is {childId}'s {type}
  // Other way to memorize: for each of the relationships you can add
  // on the relationship tab of the edit page, the page you're editing
  // is the child.
  type: "parent"|"tag"|"subject"|"requirement";
  // Id of the user who added this relationships. FK into pages.
  creatorId: string;
  // When this relationship was created.
  createdAt: Date;
  // A pair is considered published the first time its parent and child
  // are both published and not deleted. (Once everPublisehd is set to
  // true, it does not going back to being false even if its parent
  // and child pages are deleted.)
  everPublished: boolean;
  // For requirements and subjects, this sets the level of the understanding
  // required / taught
  level: number;
  // Determines if the requirement is strong or weak.
  // For requirements this is strong/weak.
  // For subjects this is teaches/expands.
  isStrong: boolean;
};

// This table contains all the edits for all the pages, including the original edit.
// Each row is one edit for a given page.
export type PagesRow = { //{{_}}
  // Id of the page the edit is for.
  pageId: string;
  // The edit (version) number. Always >0.
  edit: number;
  // Edit number that preceded this edit. Used to detect when a user has an edit
  // that's been obsoleted by a newly published edit.
  prevEdit: number;
  // True iff this is the edit currently used to display the page.
  isLiveEdit: boolean;
  // True iff this is a minor edit.
  isMinorEdit: boolean;
  // True iff this is a snapshot saved by the creatorId user.
  isSnapshot: boolean;
  // True iff this is an autosave for the creatorId user. There is at most one
  // autosave per user per page.
  isAutosave: boolean;
  // User id of the creator of this edit.
  creatorId: string;
  // When this edit was created.
  createdAt: Date;
  // Title of the page.
  title: string;
  // Clickbait of the page.
  clickbait: string;
  // Text of the page.
  text: string;
  // Meta-text for the page. This contains meta-data like clickbait, summary,
  // masteries, etc...
  metaText: string;
  // Number of TODOs in this page.
  todoCount: number;
  // == Following variables are set for inline comments and questions. ==
  // Text of the paragraph the anchor is in.
  anchorContext: string;
  // Text the comment is attached to.
  anchorText: string;
  // Offset of the text into the context.
  anchorOffset: number;
  // A message saying what this edit is about.
  editSummary: string;
  // == Following variables are set for some specific pages. ==
  // Text associated with the snapshot.
  snapshotText: string;
};

// This table contains all the summaries for all the pages.
export type PageSummariesRow = { //{{_}}
  // Id of the page the summary is for.
  pageId: string;
  // Name of the summary.
  name: string;
  // Text of the summary.
  text: string;
};

// This table contains pages that have been submitted to a domain.
type PageToDomainSubmissionsRow = { //{{_}}
  // Id of the submitted page. FK into pageInfos.
  pageId: string;
  // Id of the domain it's submitted to. FK into pageInfos.
  domainId: string;
  // When this submission was originally created.
  createdAt: Date;
  // Id of the user who submitted. FK into users.
  submitterId: string;
  // When this submission was approved.
  approvedAt: Date;
  // Id of the user who approved the submission. FK into users.
  approverId: string;
};

// This table contains a row for each path a user has started.
type PathInstancesRow = { //{{_}}
  // Id of this entry.
  id: number;
  // User who started this path. FK into users.
  userId: string;
  // Id of the page guide that started this path. FK into pageInfos.
  guideId: string;
  // Comma separated list of page ids which this path has. FK into pageInfos.
  pageIds: string;
  // Comma separated list of which page added the corresponding page to pageIds. FK into pageInfos.
  sourcePageIds: string;
  // Index of the page the user is on.
  progress: number;
  // When this instance was created.
  createdAt: Date;
  // When this instance was updated last.
  updatedAt: Date;
  // Optional. If set, the user copied the path from this instance.
  originalInstanceId: number;
  // Set to true when the user finished the path.
  isFinished: boolean;
};

// This table contains what pages belong to which paths.
type PathPagesRow = { //{{_}}
  // Id of this entry.
  id: number;
  // Id of the page guide that starts this path. FK into pageInfos.
  guideId: string;
  // Id of one of the pages on the path. FK into pageInfos.
  pathPageId: string;
  // Ordering index when ordering the pages in a path.
  pathIndex: number;
  // Id of the user who created the relationship. FK into users.
  createdBy: string;
  // When this lens relationship was originally created.
  createdAt: Date;
  // Id of the last user who updated the relationship. FK into users.
  updatedBy: string;
  // When this relationship was updated last.
  updatedAt: Date;
};

// An entry for every project we have
type ProjectsRow = { //{{_}}
  // Project id.
  id: number;
  // The page which describes this project. FK into pages.
  projectPageId: string;
  // The first page the reader should go to. FK into pages.
  startPageId: string;
  // State of the project. "finished", "inProgress", or "requested"
  state: string;
  // Id by which we track who wants to read this. FK into likes.
  readLikeableId: number;
  // Id by which we track who wants to write this. FK into likes.
  writeLikeableId: number;
  // Date this entry was created.
  createdAt: Date;
};

// An entry for every red link.
type RedLinksRow = { //{{_}}
  // Alias of the red link.
  alias: string;
  // Id by which we track likes. Partial FK into likes.
  likeableId: number;
  // Date this entry was created.
  createdAt: Date;
};

// An entry for every search string that's attached to a page.
type SearchStringsRow = { //{{_}}
  // Id of this search string.
  id: number;
  // Id of the page this string is for. FK into pages.
  pageId: string;
  // Id of the user who added this string. FK into users.
  userId: string;
  // String's text.
  text: string;
  // Date this string was created.
  createdAt: Date;
};

// An update is a notification for the user that something new has happened, e.g.
// there was a new comment. Updates are created only when a user is subscribed to
// something, usually a page.
//
// When the user visits the update pages, all the counts are zeroed out, since
// the user has been made aware of all the updates.
type UpdatesRow = { //{{_}}
  // Unique update id. PK.
  id: number;
  // The update is for this user. FK into users.
  userId: string;
  // The update was generated by this user. FK into users.
  byUserId: string;
  // Type of update
  type: string;
  // When this update was created.
  createdAt: Date;
  // Whether the user has seen this update.
  seen: boolean;
  // Whether the user has dismissed this update.
  dismissed: boolean;
  // True if this update has been emailed out.
  emailed: boolean;
  // User got this update because they are subscribed to "this thing". FK into
  // pages.
  subscribedToId: string;
  // User will be directed to "this thing" for more information about the update.
  goToPageId: string;
  // ==== Optional vars ====
  // Only set if type is 'pageInfoEdit'. Used to show what changed on the updates page.
  // FK into changeLogs.
  changeLogId: string;
  // Only set if the update is about a mark. FK into marks.
  markId: number;
};

// An entry for every mastery a user knows.
type UserMasteryPairsRow = { //{{_}}
  // Id of the user. FK into users.
  userId: string;
  // Id of the mastery. FK into pages.
  masteryId: string;
  // Date this entry was created.
  createdAt: Date;
  // Date this entry was updated.
  updatedAt: Date;
  // Set if the user has this mastery.
  has: boolean;
  // Set if the user wants to read this.
  wants: boolean;
  // Level of understanding.
  level: number;
  // Id of the page where the user marked the mastery learned
  taughtBy: string;
  // User's trust when they learned the mastery. FK into userTrustSnapshots
  trustSnapshotId: number;
};

// This table contains an entry for each (user, page object) pair, where
// the object can store some user specific data. For example, multiple choice
// questions can store the user's answer.
type UserPageObjectPairsRow = { //{{_}}
  // Id of the user the user is for. FK into users.
  userId: string;
  // Id of the page the info is for.
  pageId: string;
  // Page's published edit at the time this value was set.
  edit: number;
  // Alias name of the object.
  object: string;
  // When this value was originally created at.
  createdAt: Date;
  // When this value was updated.
  updatedAt: Date;
  // Whatever value the object decides to set here.
  value: string;
};

// When we snapshot all user's requisites, we store them in this table. Each snapshot
// has the same id, but takes up multiple rows.
type UserRequisitePairSnapshotsRow = { //{{_}}
  // Id of the snapshot. Note that this is not unique per row.
  id: number;
  // Id of the user. FK into users.
  userId: string;
  // Id of the requisite. FK into pages.
  requisiteId: string;
  // Date this entry was created.
  createdAt: Date;
  // Set if the user has this mastery.
  has: boolean;
  // Set if the user wants to read this.
  wants: boolean;
};

// An entry for every user that has ever done anything in our system.
type UsersRow = { //{{_}}
  // PK. User's unique id.
  id: string;
  // Date this user was added to the table.
  createdAt: Date;
  // User's email.
  email: string;
  // User's self-assigned first name.
  firstName: string;
  // User's self-assigned last name.
  lastName: string;
  // If the user added FB, this is their userId
  fbUserId: string;
  // Date of the last website visit.
  lastWebsiteVisit: Date;
  // True iff the user is an admin.
  isAdmin: boolean;
  // True iff the user is trusted to send invites.
  isTrusted: boolean;
  // Date of the last updates email.
  updateEmailSentAt: Date;
  // Can only be set manually by an admin via DB console. Used for debugging.
  // The system will load the information for the given user, instead of this user.
  pretendToBeUserId: string;
  // If the user asked to be invited to Slack. It's very possible that the user
  // is already a Slack member, but this field isn't set.
  isSlackMember: boolean;
  // ============================= Settings ====================================
  // How frequently to send update emails.
  emailFrequency: string;
  // How many updates before sending an update email.
  emailThreshold: number;
  // If true, don't do a live preview of MathJax.
  ignoreMathjax: boolean;
  // If true, show the advanced editor mode for new users.
  showAdvancedEditorMode: boolean;
};

// This table contains all the subscriptions to users.
type UserSubscriptionsRow = { //{{_}}
  // User id of the subscriber. FK into users.
  userId: string;
  // Id of the user this user is subscribed to. FK into users.
  toUserId: string;
  // When this subscription was created.
  createdAt: Date;
};

// Each row is a page-user pair with the date and time
// when the user has last seen the page.
type VisitsRow = { //{{_}}
  // If the user is logged in, user's id. FK into users.
  userId: string;
  // Session id. If the user is *not* logged in, the userId will be the same as this value.
  sessionId: string;
  // Analytics id. Base64-encoded Sha256 hash of the session id.
  analyticsId: string;
  // IP address of the user's computer.
  ipAddress: string;
  // Page id. FK into pages.
  pageId: string;
  // When this visit occured.
  createdAt: Date;
};

// An entry for every probability vote a user casts for a question. There could be
// multiple votes from one user for the same page.
type VotesRow = { //{{_}}
  // PK. Vote's unique id.
  id: number;
  // Id of the user who voted. FK into users.
  userId: string;
  // Id of the page this vote is for. FK into pages.
  pageId: string;
  // Vote value. Special values are:
  // -1: mu
  // -2: no vote
  value: number;
  // Date this like was created.
  createdAt: Date;
};

export type WholeArbitalDatabase = { //{{_}}
  aliasRedirects: AliasRedirectsRow[];
  // anchors: Wasn't in the exported DB and a comment says it's unused
  //anchors: AnchorsRow[];
  answers: AnswersRow[];
  changeLogs: ChangeLogsRow[];
  contentRequests: ContentRequestsRow[];
  discussionSubscriptions: DiscussionSubscriptionsRow[];
  domainFriends: DomainFriendsRow[];
  domainMembers: DomainMembersRow[];
  domains: DomainsRow[];
  feedPages: FeedPagesRow[];
  invites: InvitesRow[];
  lastViews: LastViewsRow[];
  lastVisits: LastVisitsRow[];
  lenses: LensesRow[];
  likeableIds: LikeableIdsRow[];
  likes: LikesRow[];
  links: LinksRow[];
  maintainerSubscriptions: MaintainerSubscriptionsRow[];
  marks: MarksRow[];
  pageInfos: PageInfosRow[];
  pagePairs: PagePairsRow[];
  pages: PagesRow[];
  pageSummaries: PageSummariesRow[];
  pageToDomainSubmissions: PageToDomainSubmissionsRow[];
  pathInstances: PathInstancesRow[];
  pathPages: PathPagesRow[];
  projects: ProjectsRow[];
  redLinks: RedLinksRow[];
  searchStrings: SearchStringsRow[];
  updates: UpdatesRow[];
  userMasteryPairs: UserMasteryPairsRow[];
  userPageObjectPairs: UserPageObjectPairsRow[];
  userRequisitePairSnapshots: UserRequisitePairSnapshotsRow[];
  users: UsersRow[];
  userSubscriptions: UserSubscriptionsRow[];
  // visits: Excluded (for now at least) from export for file-size/convenience
  //visits: VisitsRow[];
  votes: VotesRow[];
};

const TABLE_PAGINATION_LIMITS = {
  pages: 5000,
  pathInstances: 20000,
  userMasteryPairs: 80000,
  userPageObjectPairs: 80000,
} as const;

export async function loadArbitalDatabase(connection: mysql.Connection): Promise<WholeArbitalDatabase> {
  let database: WholeArbitalDatabase = {
    aliasRedirects: [],
    answers: [],
    changeLogs: [],
    contentRequests: [],
    discussionSubscriptions: [],
    domainFriends: [],
    domainMembers: [],
    domains: [],
    feedPages: [],
    invites: [],
    lastViews: [],
    lastVisits: [],
    lenses: [],
    likeableIds: [],
    likes: [],
    links: [],
    maintainerSubscriptions: [],
    marks: [],
    pageInfos: [],
    pagePairs: [],
    pages: [],
    pageSummaries: [],
    pageToDomainSubmissions: [],
    pathInstances: [],
    pathPages: [],
    projects: [],
    redLinks: [],
    searchStrings: [],
    updates: [],
    userMasteryPairs: [],
    userPageObjectPairs: [],
    userRequisitePairSnapshots: [],
    users: [],
    userSubscriptions: [],
    votes: [],
  };

  // Load data for each table
  for (const tableName of Object.keys(database)) {
    if (tableName === 'lastVisits' || tableName === 'pathInstances' || tableName === 'userMasteryPairs' || tableName === 'userPageObjectPairs') continue;

    // Pages are large, and don't fit into a single query (grpc has a message size limit)
    // So we paginate through them based on createdAt with a limit of 1000
    if (tableName in TABLE_PAGINATION_LIMITS) {
      const limit = TABLE_PAGINATION_LIMITS[tableName as keyof typeof TABLE_PAGINATION_LIMITS];
      let offset = 0;
      let loadMore = true;
      while (loadMore) {
        const query = `SELECT * FROM ${tableName} ORDER BY createdAt LIMIT ${limit} OFFSET ${offset}`;
        const [rows] = await connection.query(query);
        (database as any)[tableName].push(...(rows as any));
        offset += (rows as any).length;
        loadMore = (rows as any).length === limit;
      }
    } else {
      const query = `SELECT * FROM ${tableName}`
      const [rows] = await connection.query(query);
      (database as any)[tableName] = (rows as any);
    }
  }

  return database;
}
