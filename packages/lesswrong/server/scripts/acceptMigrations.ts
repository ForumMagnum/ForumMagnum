import { readFile, readdir, writeFile } from 'node:fs/promises'
import path from 'path';

const ROOT_PATH = path.join(__dirname, "../../../");
const schemaChangelogPath = (rootPath: string) => path.join(rootPath, "schema/schema_changelog.json");
export const migrationsPath = (rootPath: string) => path.join(rootPath, "packages/lesswrong/server/migrations");

export interface SchemaChangelogEntry {
  acceptsSchemaHash: string
  acceptedByMigration?: string
  timestamp: string
}

export const migrationNameToDate = (name: string): Date => {
  const s = name.split(".")[0];
  if (s.length !== 15 || s[8] !== "T") {
    throw new Error(`Invalid migration name: '${s}'`);
  }
  if (name.match(/^.*\.auto\.ts$/)) {
    throw new Error(`You must rename the migration from 'auto' to something more recognizable: ${name}`);
  }
  const stamp = `${s.slice(0, 4)}-${s.slice(4, 6)}-${s.slice(6, 11)}:${s.slice(11, 13)}:${s.slice(13, 15)}.000Z`;
  return new Date(stamp);
}

export const migrationNameToTime = (name: string): number => {
  return migrationNameToDate(name).getTime();
}

const assertNoDuplicateTimestamps = (entries: SchemaChangelogEntry[]) => {
  const timestamps = entries.map(e => e.timestamp);
  const uniqueTimestamps = new Set(timestamps);
  if (timestamps.length !== uniqueTimestamps.size) {
    throw new Error(`Duplicate timestamps: ${timestamps.sort()}`);
  }
}

const getSchemaChangelogEntries = async (rootPath: string): Promise<SchemaChangelogEntry[]> => {
  const schemaChangelog = await readFile(schemaChangelogPath(rootPath), 'utf8');
  return JSON.parse(schemaChangelog);
}

const getMigrationChangelogEntries = async (rootPath: string): Promise<SchemaChangelogEntry[]> => {
  const migrationFiles = (
    (await readdir(migrationsPath(rootPath), { withFileTypes: true }))
      .filter(dirent => dirent.isFile())
      .map(dirent => path.join(migrationsPath(rootPath), dirent.name))
  );
  
  const migrationChangelogEntries: SchemaChangelogEntry[] = [];
  for (const migrationFile of migrationFiles) {
    // NOTE: I'm using this regex hack rather than importing because esbuild doesn't support
    // dynamic imports, I would very much like to change this
    const acceptsHashRegex = new RegExp(/^export const acceptsSchemaHash = ["'](.*)["']/);
    const contents = (await readFile(migrationFile)).toString().split("\n");
    const acceptsHashLine = contents.find(line => acceptsHashRegex.test(line));
    
    if (!acceptsHashLine) continue;

    const match = acceptsHashRegex.exec(acceptsHashLine);
    
    if (!match) throw new Error(`Invalid acceptsHashLine: ${acceptsHashLine}`);
    
    const acceptsHash = match[1];
    const migrationName = path.basename(migrationFile);
    const timestamp = migrationNameToDate(migrationName);
    
    migrationChangelogEntries.push({
      acceptsSchemaHash: acceptsHash,
      acceptedByMigration: migrationName,
      timestamp: timestamp.toISOString(),
    });
  }
  
  return migrationChangelogEntries;
}

const arrayToTimestampMap = (array: SchemaChangelogEntry[]): Record<string, SchemaChangelogEntry> => {
  const map: Record<string, SchemaChangelogEntry> = {};
  for (const entry of array) {
    map[entry.timestamp] = entry;
  }
  return map;
}

/**
 * There are two ways you can "accept" a schema change, by adding a migration file with `export const acceptsSchemaHash = "..."`,
 * or by manually editing schema_changelog.json. This function merges changes accepted by migrations into schema_changelog.json. In doing this, we want to:
 * - Preserve manually added entries in schema_changelog.json (i.e. entries without acceptedByMigration)
 * - Assert that all the acceptedByMigration files still exist
 */
const updateSchemaChangelogWithMigrationEntries = async ({
  schemaChangelogEntries,
  migrationChangelogEntries}: {
  schemaChangelogEntries: SchemaChangelogEntry[],
  migrationChangelogEntries: SchemaChangelogEntry[]
}) => {
  assertNoDuplicateTimestamps(schemaChangelogEntries);
  assertNoDuplicateTimestamps(migrationChangelogEntries);

  const schemaChangelogEntriesMap = arrayToTimestampMap(schemaChangelogEntries);
  const migrationChangelogEntriesMap = arrayToTimestampMap(migrationChangelogEntries);
  
  const newSchemaChangelogEntries: SchemaChangelogEntry[] = [];
  
  for (const timestamp in migrationChangelogEntriesMap) {
    if (schemaChangelogEntriesMap[timestamp]) {
      const existingEntry = schemaChangelogEntriesMap[timestamp];
      const newEntry = migrationChangelogEntriesMap[timestamp];
      if (existingEntry.acceptsSchemaHash !== newEntry.acceptsSchemaHash ||
          existingEntry.acceptedByMigration !== newEntry.acceptedByMigration) {
          const existingString = JSON.stringify(existingEntry);
          const newString = JSON.stringify(newEntry);
          throw new Error(`Cannot change accepted migration: ${timestamp}. The entry in schema_changelog.json is ${existingString}`
            + ` but the entry generated by the migration file is ${newString}`);
      }
    } else {
      // eslint-disable-next-line no-console
      console.log("Adding new entry to schema_changelog.json:\n", migrationChangelogEntriesMap[timestamp]);
    }
    newSchemaChangelogEntries.push(migrationChangelogEntriesMap[timestamp]);
  }
  
  const manualEntries = schemaChangelogEntries.filter(entry => !migrationChangelogEntriesMap[entry.timestamp]);
  
  // Assert that the manual entries are in fact manual, if they have an acceptedByMigration field this
  // probably means that the migration file was deleted
  const invalidManualEntries = manualEntries.filter(entry => entry.acceptedByMigration)
  if (invalidManualEntries.length) {
    // eslint-disable-next-line no-console
    console.error(`There are entries with an acceptedByMigration field in schema_changelog.json where the corresponding migration can't be found. ` +
    `This is probably because the migration files were deleted. If you really do want to delete these files then remove these entries from schema_changelog.json:`, invalidManualEntries)
    throw new Error();
  }
  
  newSchemaChangelogEntries.push(...manualEntries);
  return newSchemaChangelogEntries.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
}

export const acceptMigrations = async ({write=true, rootPath=ROOT_PATH}: {write: boolean, rootPath: string}): Promise<SchemaChangelogEntry> => {
  const schemaChangelogEntries = await getSchemaChangelogEntries(rootPath);
  const migrationChangelogEntries = await getMigrationChangelogEntries(rootPath);

  const newSchemaChangelogEntries = await updateSchemaChangelogWithMigrationEntries({schemaChangelogEntries, migrationChangelogEntries});
   
  if (write) {
    await writeFile(schemaChangelogPath(rootPath), JSON.stringify(newSchemaChangelogEntries, null, 2));
  } else {
    if (JSON.stringify(newSchemaChangelogEntries) !== JSON.stringify(schemaChangelogEntries)) {
      throw new Error(`schema_changelog.json is out of date. Run 'yarn acceptmigrations' to update it.`);
    }
  }

  return newSchemaChangelogEntries[newSchemaChangelogEntries.length - 1];
}
