import { generatedFileHeader, assert, simplSchemaTypeToTypescript, graphqlTypeToTypescript, generateAllowedValuesTypeString, autoUnindent } from './typeGenerationUtils';
import { allSchemas, getSchema, getSimpleSchema } from '@/lib/schema/allSchemas';
import groupBy from 'lodash/groupBy';
import { graphqlTypeToCollectionName } from "../../lib/vulcan-lib/collections";
import { getAllCollections, getCollection, isValidCollectionName } from "@/server/collections/allCollections";
import orderBy from 'lodash/orderBy';
import type { FieldNode, FragmentDefinitionNode } from 'graphql';
import { FragmentFromSource, FragmentsFromSource, findFragmentsInSource } from './findGraphql';

const fragmentFileHeader = generatedFileHeader+`//
// Contains Typescript signatures for fragments, generated by
// server/codegen/generateFragmentTypes.ts.
//
`

export function generateFragmentTypes(collectionNameToTypeName: Record<string, string>, typeNameToCollectionName: Record<string, string>): string {
  const allFragments = findFragmentsInSource(collectionNameToTypeName);
  const fragmentNames = Object.keys(allFragments);
  const sortedFragmentNames: Array<string> = orderBy(fragmentNames, f=>f);

  const sb: Array<string> = [];
  for (let fragmentName of sortedFragmentNames) {
    sb.push(generateFragmentTypeDefinition(allFragments[fragmentName], typeNameToCollectionName));
  }
  
  sb.push(generateFragmentsIndexType(allFragments));
  sb.push(generateCollectionNamesByFragmentNameType(allFragments, typeNameToCollectionName));
  sb.push(generateCollectionNamesIndexType());
  sb.push(generateCollectionNamesWithCreatedAtIndexType());
  sb.push(generateCollectionNamesWithSlugIndexType());
  
  return fragmentFileHeader + sb.join('');
}

export function generateFragmentsGqlFile(collectionNameToTypeName: Record<string, string>) {
  const allFragments = findFragmentsInSource(collectionNameToTypeName);
  const fragmentNames = Object.keys(allFragments);
  const sortedFragmentNames: Array<string> = orderBy(fragmentNames, f=>f);

  const sb: Array<string> = [];
  for (let fragmentName of sortedFragmentNames) {
    const fragmentText = allFragments[fragmentName].fragmentText
    sb.push(autoUnindent(fragmentText));
  }
  
  return sb.join("\n\n");
}

function fragmentNameToCollectionName(fragment: FragmentFromSource): CollectionNameString {
  const typeName = fragment.graphqlType;
  const collectionName = graphqlTypeToCollectionName(typeName);
  return collectionName;
}

function generateFragmentTypeDefinition(fragment: FragmentFromSource, typeNameToCollectionName: Record<string, string>): string {
  const collectionName = typeNameToCollectionName[fragment.graphqlType] as CollectionNameString;
  const collection = isValidCollectionName(collectionName) ? getCollection(collectionName) : null;
  
  return fragmentToInterface(fragment.fragmentName, fragment.parsedFragment, collection);
}

function generateFragmentsIndexType(allFragments: FragmentsFromSource): string {
  const fragmentNames: string[] = orderBy(Object.keys(allFragments), f=>f);
  const sb: Array<string> = [];
  
  sb.push('interface FragmentTypes {\n');
  for (let fragmentName of fragmentNames) {
    sb.push(`  ${fragmentName}: ${fragmentName}\n`);
  }
  sb.push('}\n\n');
  
  const fragmentNamesByCollection = groupBy(fragmentNames, (f: FragmentName): CollectionNameString => fragmentNameToCollectionName(allFragments[f]));
  sb.push(`interface FragmentTypesByCollection {\n`);
  for (const collectionName of orderBy(Object.keys(fragmentNamesByCollection), c=>c)) {
    sb.push(`  ${collectionName}: `);
    sb.push(fragmentNamesByCollection[collectionName].map(f=>`"${f}"`).join("|"));
    sb.push("\n");
  }
  sb.push('}\n\n');
  
  return sb.join('');
}

function generateCollectionNamesByFragmentNameType(fragments: FragmentsFromSource, typeNameToCollectionName: Record<string, string>): string {
  const fragmentNames: string[] = orderBy(Object.keys(fragments), f=>f);
  const sb: Array<string> = [];
  
  sb.push(`interface CollectionNamesByFragmentName {\n`);
  for (let fragmentName of fragmentNames) {
    const graphqlType = fragments[fragmentName].graphqlType;
    const collectionName = (typeNameToCollectionName as any)[graphqlType];
    if (isValidCollectionName(collectionName)) {
      sb.push(`  ${fragmentName}: "${collectionName}"\n`);
    } else {
      sb.push(`  ${fragmentName}: never\n`);
    }
  }
  sb.push('}\n\n');
  
  return sb.join('');
}

const generateCollectionNameList = (
  name: string,
  collectionNames: CollectionNameString[],
): string =>
  `type ${name} = ${collectionNames.map(c => `"${c}"`).join('|')}\n\n`;

const generateCollectionNamesIndexType = () =>
  generateCollectionNameList("CollectionNameString", getAllCollections().map(c => c.collectionName));

const generateCollectionNamesWithCreatedAtIndexType = () =>
  generateCollectionNameList(
    "CollectionNameWithCreatedAt",
    Object.entries(allSchemas).filter(([_, schema]) => 'createdAt' in schema).map(([collectionName]) => collectionName as CollectionNameString),
  );

const generateCollectionNamesWithSlugIndexType = () =>
  generateCollectionNameList(
    "CollectionNameWithSlug",
    Object.entries(allSchemas).filter(([_, schema]) => 'slug' in schema).map(([collectionName]) => collectionName as CollectionNameString),
  );

function fragmentToInterface(interfaceName: string, parsedFragment: FragmentDefinitionNode|FieldNode, collection: CollectionBase<CollectionNameString> | null): string {
  const sb: Array<string> = [];
  
  const spreadFragments = getSpreadFragments(parsedFragment);
  const inheritanceStr = spreadFragments.length>0 ? ` extends ${spreadFragments.join(', ')}` : "";
  
  sb.push(`interface ${interfaceName}${inheritanceStr} { // fragment on ${collection?.collectionName ?? "non-collection type"}\n`);
  
  const allSubfragments: Array<string> = [];
  for (let selection of parsedFragment.selectionSet?.selections ?? []) {
    switch(selection.kind) {
      case "Field":
        const { fieldType, subfragment } = getFragmentFieldType(interfaceName, selection, collection)
        sb.push(`  readonly ${selection.name.value}: ${fieldType},\n`);
        if (subfragment)
          allSubfragments.push(subfragment);
        break;
      case "FragmentSpread":
        break;
      default:
        sb.push(`  UNRECOGNIZED: ${selection.kind}\n`);
        break;
    }
  }
  
  sb.push('}\n\n');
  for (let subfragment of allSubfragments)
    sb.push(subfragment);
  return sb.join('');
}

function getSpreadFragments(parsedFragment: AnyBecauseTodo): Array<string> {
  const spreadFragmentNames: Array<string> = [];
  for (let selection of parsedFragment.selectionSet.selections) {
    if(selection.kind === "FragmentSpread") {
      spreadFragmentNames.push(selection.name.value);
    }
  }
  return spreadFragmentNames;
}

function getFragmentFieldType(fragmentName: string, parsedFragmentField: FieldNode, collection: AnyBecauseTodo):
  { fieldType: string, subfragment: string|null }
{
  if (collection === null) {
    // Fragments may not correspond to a collection, if eg they're on a graphql
    // type defined with addGraphQLSchema. In that case, emit a type with the
    // right set of fields but with every field having type `any` because sadly
    // we aren't yet tracking down the schema definition.
    return { fieldType: "any", subfragment: null };
  }

  const fieldName: string = parsedFragmentField.name.value;
  if (fieldName === "__typename") {
    return { fieldType: "string", subfragment: null };
  }
  const schema = getSchema(collection.collectionName);
  const simpleSchemaWrapper = getSimpleSchema(collection.collectionName);
  const simpleSchema = simpleSchemaWrapper._schema;
  // There are two ways a field name can appear in a schema. The first is as a
  // regular field with that name. The second is as a resolver with that name,
  // which may be attached to a field with the same name or a different name.
  // If there's a resolver, it takes precedence.
  
  let fieldType: string|null = null;
  
  // Check for a field with a resolver by this name
  for (let schemaFieldName of Object.keys(schema)) {
    const fieldWithResolver = schema[schemaFieldName];
    if (fieldWithResolver?.graphql?.resolver && schemaFieldName === fieldName) {
      if (fieldWithResolver.graphql.typescriptType) {
        fieldType = fieldWithResolver.graphql.typescriptType;
      } else if (fieldWithResolver.graphql?.validation?.allowedValues) {
        fieldType = generateAllowedValuesTypeString(fieldWithResolver.graphql.validation.allowedValues, fieldWithResolver);
      } else {
        assert(!!fieldWithResolver.graphql.outputType);
        fieldType = graphqlTypeToTypescript(fieldWithResolver.graphql.outputType);
      }
      break;
    }
  }
  
  // Check for regular presence in the schema
  if (!fieldType) {
    if (fieldName in simpleSchema) {
      const fieldSchema = schema[fieldName];
      const fieldSimpleSchema = simpleSchema[fieldName];
      assert(!!fieldSimpleSchema?.type && !!fieldSchema);
      if (fieldSimpleSchema?.typescriptType && fieldSimpleSchema?.blackbox) {
        fieldType = fieldSimpleSchema.typescriptType;
      } else if (fieldSchema.graphql?.validation?.allowedValues) {
        fieldType = generateAllowedValuesTypeString(fieldSchema.graphql.validation.allowedValues, fieldSchema);
      } else if (fieldSchema.graphql?.validation?.simpleSchema) {
        fieldType = simplSchemaTypeToTypescript(simpleSchema, fieldName, fieldSimpleSchema.type);
      } else if (fieldSchema.graphql?.outputType) {
        fieldType = graphqlTypeToTypescript(fieldSchema.graphql?.outputType);
      } else {
        fieldType = simplSchemaTypeToTypescript(simpleSchema, fieldName, fieldSimpleSchema.type);
      }
    }
  }
  
  // If neither found, error (fragment contains a field that isn't in the schema)
  if (!fieldType) {
    throw new Error(`Fragment ${fragmentName} contains field ${fieldName} on type ${collection.collectionName} which is not in the schema`);
  }

  const {collection: subfieldCollection, nullable} = subfragmentTypeToCollection(fieldType);

  // Now check if the field has a sub-selector
  if ((parsedFragmentField.selectionSet?.selections?.length ?? 0) > 0) {
    // As a special case, if the sub-selector spreads a fragment and has no
    // other fields, use that fragment's type
    if (parsedFragmentField.selectionSet?.selections.length === 1
      && parsedFragmentField.selectionSet?.selections[0].kind === "FragmentSpread")
    {
      const subfragmentName = parsedFragmentField.selectionSet?.selections[0].name.value;
      if (fieldType.startsWith("Array<")) {
        return {
          fieldType: nullable ? `Array<${subfragmentName}>|null` : `Array<${subfragmentName}>`,
          subfragment: null
        };
      } else {
        return {
          fieldType: nullable ? `${subfragmentName}|null` : subfragmentName,
          subfragment: null
        };
      }
    }
    else
    {
      if (typeof fieldType !== "string") throw new Error("fieldType is not a string: was "+JSON.stringify(fieldType));
      if (!subfieldCollection) {
        // eslint-disable-next-line no-console
        console.log(`Field ${fieldName} in fragment ${fragmentName} has type ${fieldType} which does not identify a collection`);
        //throw new Error(`Field ${fieldName} in fragment ${fragmentName} has type ${fieldType} which does not identify a collection`);
        return {
          fieldType, subfragment: null
        };
      }
      const subfragmentName = `${fragmentName}_${fieldName}`;
      const subfragment = fragmentToInterface(subfragmentName, parsedFragmentField, subfieldCollection);
      
      // If it's an array type, then it's an array of that subfragment. Otherwise it's an instance of that subfragmetn.
      if (fieldType.startsWith("Array<")) {
        return {
          fieldType: nullable ? `Array<${subfragmentName}>|null` : `Array<${subfragmentName}>`,
          subfragment: subfragment,
        };
      } else {
        return {
          fieldType: nullable ? `${subfragmentName}|null` : subfragmentName,
          subfragment: subfragment,
        };
      }
    }
  } else {
    return {
      fieldType, subfragment: null
    };
  }
}

// Given the type of a field (as a string which is a Typescript type), where
// that field is a collection type with optional array- or nullable-wrapping,
// return the collection.
function subfragmentTypeToCollection(fieldType: string): {
  collection: CollectionBase<any>|null,
  nullable: boolean,
}{
  if (fieldType.startsWith("Array<") && fieldType.endsWith(">")) {
    return {
      collection: subfragmentTypeToCollection(fieldType.substr(6, fieldType.length-7)).collection,
      nullable: false,
    };
  } else if (fieldType.endsWith("|null")) {
    return {
      collection: subfragmentTypeToCollection(fieldType.substr(0, fieldType.length-5)).collection,
      nullable: true,
    };
  } else if (fieldType.endsWith("!")) {
    return {
      collection: subfragmentTypeToCollection(fieldType.substr(0, fieldType.length-1)).collection,
      nullable: false
    };
  } else {
    const collectionName = graphqlTypeToCollectionName(fieldType);
    if (isValidCollectionName(collectionName)) {
      return {
        collection: getCollection(collectionName),
        nullable: false
      };
    } else {
      return {
        collection: null,
        nullable: false
      }
    }
  }
}
